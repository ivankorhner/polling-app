
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>seed: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/ivankorhner/polling-app/cmd/seed/main.go (0.0%)</option>
				
				<option value="file1">github.com/ivankorhner/polling-app/cmd/server/main.go (0.0%)</option>
				
				<option value="file2">github.com/ivankorhner/polling-app/internal/config/config.go (0.0%)</option>
				
				<option value="file3">github.com/ivankorhner/polling-app/internal/ent/client.go (0.0%)</option>
				
				<option value="file4">github.com/ivankorhner/polling-app/internal/ent/ent.go (0.0%)</option>
				
				<option value="file5">github.com/ivankorhner/polling-app/internal/ent/enttest/enttest.go (0.0%)</option>
				
				<option value="file6">github.com/ivankorhner/polling-app/internal/ent/hook/hook.go (0.0%)</option>
				
				<option value="file7">github.com/ivankorhner/polling-app/internal/ent/migrate/migrate.go (0.0%)</option>
				
				<option value="file8">github.com/ivankorhner/polling-app/internal/ent/migrate/schema.go (0.0%)</option>
				
				<option value="file9">github.com/ivankorhner/polling-app/internal/ent/mutation.go (0.0%)</option>
				
				<option value="file10">github.com/ivankorhner/polling-app/internal/ent/poll.go (0.0%)</option>
				
				<option value="file11">github.com/ivankorhner/polling-app/internal/ent/poll/poll.go (0.0%)</option>
				
				<option value="file12">github.com/ivankorhner/polling-app/internal/ent/poll/where.go (0.0%)</option>
				
				<option value="file13">github.com/ivankorhner/polling-app/internal/ent/poll_create.go (0.0%)</option>
				
				<option value="file14">github.com/ivankorhner/polling-app/internal/ent/poll_delete.go (0.0%)</option>
				
				<option value="file15">github.com/ivankorhner/polling-app/internal/ent/poll_query.go (0.0%)</option>
				
				<option value="file16">github.com/ivankorhner/polling-app/internal/ent/poll_update.go (0.0%)</option>
				
				<option value="file17">github.com/ivankorhner/polling-app/internal/ent/polloption.go (0.0%)</option>
				
				<option value="file18">github.com/ivankorhner/polling-app/internal/ent/polloption/polloption.go (0.0%)</option>
				
				<option value="file19">github.com/ivankorhner/polling-app/internal/ent/polloption/where.go (0.0%)</option>
				
				<option value="file20">github.com/ivankorhner/polling-app/internal/ent/polloption_create.go (0.0%)</option>
				
				<option value="file21">github.com/ivankorhner/polling-app/internal/ent/polloption_delete.go (0.0%)</option>
				
				<option value="file22">github.com/ivankorhner/polling-app/internal/ent/polloption_query.go (0.0%)</option>
				
				<option value="file23">github.com/ivankorhner/polling-app/internal/ent/polloption_update.go (0.0%)</option>
				
				<option value="file24">github.com/ivankorhner/polling-app/internal/ent/runtime.go (0.0%)</option>
				
				<option value="file25">github.com/ivankorhner/polling-app/internal/ent/schema/poll.go (0.0%)</option>
				
				<option value="file26">github.com/ivankorhner/polling-app/internal/ent/schema/poll_option.go (0.0%)</option>
				
				<option value="file27">github.com/ivankorhner/polling-app/internal/ent/schema/user.go (0.0%)</option>
				
				<option value="file28">github.com/ivankorhner/polling-app/internal/ent/schema/vote.go (0.0%)</option>
				
				<option value="file29">github.com/ivankorhner/polling-app/internal/ent/tx.go (0.0%)</option>
				
				<option value="file30">github.com/ivankorhner/polling-app/internal/ent/user.go (0.0%)</option>
				
				<option value="file31">github.com/ivankorhner/polling-app/internal/ent/user/user.go (0.0%)</option>
				
				<option value="file32">github.com/ivankorhner/polling-app/internal/ent/user/where.go (0.0%)</option>
				
				<option value="file33">github.com/ivankorhner/polling-app/internal/ent/user_create.go (0.0%)</option>
				
				<option value="file34">github.com/ivankorhner/polling-app/internal/ent/user_delete.go (0.0%)</option>
				
				<option value="file35">github.com/ivankorhner/polling-app/internal/ent/user_query.go (0.0%)</option>
				
				<option value="file36">github.com/ivankorhner/polling-app/internal/ent/user_update.go (0.0%)</option>
				
				<option value="file37">github.com/ivankorhner/polling-app/internal/ent/vote.go (0.0%)</option>
				
				<option value="file38">github.com/ivankorhner/polling-app/internal/ent/vote/vote.go (0.0%)</option>
				
				<option value="file39">github.com/ivankorhner/polling-app/internal/ent/vote/where.go (0.0%)</option>
				
				<option value="file40">github.com/ivankorhner/polling-app/internal/ent/vote_create.go (0.0%)</option>
				
				<option value="file41">github.com/ivankorhner/polling-app/internal/ent/vote_delete.go (0.0%)</option>
				
				<option value="file42">github.com/ivankorhner/polling-app/internal/ent/vote_query.go (0.0%)</option>
				
				<option value="file43">github.com/ivankorhner/polling-app/internal/ent/vote_update.go (0.0%)</option>
				
				<option value="file44">github.com/ivankorhner/polling-app/internal/logging/context.go (0.0%)</option>
				
				<option value="file45">github.com/ivankorhner/polling-app/internal/logging/logging.go (0.0%)</option>
				
				<option value="file46">github.com/ivankorhner/polling-app/internal/server/health.go (0.0%)</option>
				
				<option value="file47">github.com/ivankorhner/polling-app/internal/server/middleware/http.go (0.0%)</option>
				
				<option value="file48">github.com/ivankorhner/polling-app/internal/server/middleware/middleware.go (0.0%)</option>
				
				<option value="file49">github.com/ivankorhner/polling-app/internal/server/middleware/recover.go (0.0%)</option>
				
				<option value="file50">github.com/ivankorhner/polling-app/internal/server/middleware/requestid.go (0.0%)</option>
				
				<option value="file51">github.com/ivankorhner/polling-app/internal/server/middleware/timeout.go (0.0%)</option>
				
				<option value="file52">github.com/ivankorhner/polling-app/internal/server/pollscreate.go (73.6%)</option>
				
				<option value="file53">github.com/ivankorhner/polling-app/internal/server/pollsdelete.go (70.6%)</option>
				
				<option value="file54">github.com/ivankorhner/polling-app/internal/server/pollsget.go (80.5%)</option>
				
				<option value="file55">github.com/ivankorhner/polling-app/internal/server/response.go (85.7%)</option>
				
				<option value="file56">github.com/ivankorhner/polling-app/internal/server/routes.go (0.0%)</option>
				
				<option value="file57">github.com/ivankorhner/polling-app/internal/server/users.go (86.2%)</option>
				
				<option value="file58">github.com/ivankorhner/polling-app/internal/server/validation.go (100.0%)</option>
				
				<option value="file59">github.com/ivankorhner/polling-app/internal/server/votes.go (74.6%)</option>
				
				<option value="file60">github.com/ivankorhner/polling-app/internal/testutil/testdb.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "database/sql"
        "log/slog"
        "os"

        "entgo.io/ent/dialect"
        entsql "entgo.io/ent/dialect/sql"
        _ "github.com/jackc/pgx/v5/stdlib"

        "github.com/ivankorhner/polling-app/internal/config"
        "github.com/ivankorhner/polling-app/internal/ent"
        "github.com/ivankorhner/polling-app/internal/logging"
)

func main() <span class="cov0" title="0">{
        ctx := context.Background()
        cfg := config.LoadConfig()
        logger := logging.NewLogger(slog.LevelInfo)

        if err := run(ctx, cfg, logger); err != nil </span><span class="cov0" title="0">{
                logger.LogAttrs(ctx, slog.LevelError, "seed failed", slog.Any("error", err))
                os.Exit(1)
        }</span>
}

func run(ctx context.Context, cfg *config.Config, logger *slog.Logger) error <span class="cov0" title="0">{
        // Connect to database
        db, err := sql.Open("pgx", cfg.DatabaseURL())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer db.Close()

        drv := entsql.OpenDB(dialect.Postgres, db)
        client := ent.NewClient(ent.Driver(drv))
        defer client.Close()

        logger.Info("seeding database with demo data")

        // Create users
        user1, err := client.User.Create().
                SetUsername("alice").
                SetEmail("alice@example.com").
                Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">user2, err := client.User.Create().
                SetUsername("bob").
                SetEmail("bob@example.com").
                Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create polls
        <span class="cov0" title="0">poll1, err := client.Poll.Create().
                SetOwnerID(user1.ID).
                SetTitle("What's your favorite programming language?").
                Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">poll2, err := client.Poll.Create().
                SetOwnerID(user2.ID).
                SetTitle("Best web framework?").
                Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create poll options for poll1
        <span class="cov0" title="0">opt1, err := client.PollOption.Create().
                SetPollID(poll1.ID).
                SetText("Go").
                Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">opt2, err := client.PollOption.Create().
                SetPollID(poll1.ID).
                SetText("Rust").
                Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = client.PollOption.Create().
                SetPollID(poll1.ID).
                SetText("Python").
                Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create poll options for poll2
        <span class="cov0" title="0">_, err = client.PollOption.Create().
                SetPollID(poll2.ID).
                SetText("React").
                Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = client.PollOption.Create().
                SetPollID(poll2.ID).
                SetText("Vue").
                Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create votes (vote_count is now calculated dynamically)
        <span class="cov0" title="0">_, err = client.Vote.Create().
                SetPollID(poll1.ID).
                SetOptionID(opt1.ID).
                SetUserID(user1.ID).
                Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = client.Vote.Create().
                SetPollID(poll1.ID).
                SetOptionID(opt2.ID).
                SetUserID(user2.ID).
                Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">logger.Info("database seeded successfully",
                slog.Int("users", 2),
                slog.Int("polls", 2),
                slog.Int("options", 5),
                slog.Int("votes", 2),
        )

        return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "context"
        "database/sql"
        "log/slog"
        "net/http"
        "os"
        "os/signal"
        "time"

        "entgo.io/ent/dialect"
        entsql "entgo.io/ent/dialect/sql"
        _ "github.com/jackc/pgx/v5/stdlib"

        "github.com/ivankorhner/polling-app/internal/config"
        "github.com/ivankorhner/polling-app/internal/ent"
        "github.com/ivankorhner/polling-app/internal/logging"
        "github.com/ivankorhner/polling-app/internal/server"
)

func run(
        ctx context.Context,
        config *config.Config,
) error <span class="cov0" title="0">{
        ctx, cancel := signal.NotifyContext(ctx, os.Interrupt)
        defer cancel()

        logger := logging.NewLogger(slog.LevelInfo)
        slog.SetDefault(logger)

        // Open database connection with pooling configuration
        db, err := sql.Open("pgx", config.DatabaseURL())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer db.Close()

        // Configure connection pool
        db.SetMaxOpenConns(25)                  // Maximum number of open connections
        db.SetMaxIdleConns(5)                   // Maximum number of idle connections
        db.SetConnMaxLifetime(5 * time.Minute)  // Maximum lifetime of a connection
        db.SetConnMaxIdleTime(10 * time.Minute) // Maximum idle time of a connection

        // Create Ent driver with the configured connection pool
        drv := entsql.OpenDB(dialect.Postgres, db)
        client := ent.NewClient(ent.Driver(drv))
        defer client.Close()

        slog.LogAttrs(
                ctx,
                slog.LevelInfo,
                "database connection established",
                slog.String("host", config.DBHost),
                slog.Int("port", config.DBPort),
                slog.String("database", config.DBName),
        )

        httpServer := &amp;http.Server{
                Addr:         config.Addr(),
                Handler:      server.AddRoutes(ctx, config, logger, db, client),
                ErrorLog:     slog.NewLogLogger(logger.Handler(), slog.LevelInfo),
                ReadTimeout:  5 * time.Second,
                WriteTimeout: 10 * time.Second,
                IdleTimeout:  120 * time.Second,
        }

        serverErrors := make(chan error, 1)
        go func() </span><span class="cov0" title="0">{
                slog.LogAttrs(
                        ctx,
                        slog.LevelInfo,
                        "server starting",
                        slog.String("addr", config.Addr()),
                )
                serverErrors &lt;- httpServer.ListenAndServe()
        }</span>()

        // wait for interrupt or server error
        <span class="cov0" title="0">select </span>{
        case err := &lt;-serverErrors:<span class="cov0" title="0">
                return err</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                slog.LogAttrs(
                        ctx,
                        slog.LevelInfo,
                        "shutting down server",
                )
                shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 30*time.Second)
                defer shutdownCancel()

                if err := httpServer.Shutdown(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func main() <span class="cov0" title="0">{
        ctx := context.Background()
        cfg := config.LoadConfig()

        if err := run(ctx, cfg); err != nil </span><span class="cov0" title="0">{
                slog.LogAttrs(
                        ctx,
                        slog.LevelError,
                        "application error",
                        slog.Any("error", err),
                )
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package config

import (
        "fmt"
        "os"
        "strconv"
        "time"
)

// Config holds the application configuration
type Config struct {
        // HTTP Server config
        Port       int
        Host       string
        APITimeout time.Duration

        // Database config
        DBHost     string
        DBPort     int
        DBUser     string
        DBPassword string
        DBName     string
}

// LoadConfig loads configuration from environment variables with defaults
func LoadConfig() *Config <span class="cov0" title="0">{
        cfg := &amp;Config{
                // HTTP defaults
                Port:       8080,
                Host:       "localhost",
                APITimeout: 30 * time.Second,

                // Database defaults
                DBHost:     "localhost",
                DBPort:     5432,
                DBUser:     "polling",
                DBPassword: "polling",
                DBName:     "polling_app",
        }

        // Override HTTP config from environment variables
        if port := os.Getenv("PORT"); port != "" </span><span class="cov0" title="0">{
                if p, err := strconv.Atoi(port); err == nil </span><span class="cov0" title="0">{
                        cfg.Port = p
                }</span>
        }

        <span class="cov0" title="0">if host := os.Getenv("HOST"); host != "" </span><span class="cov0" title="0">{
                cfg.Host = host
        }</span>

        <span class="cov0" title="0">if timeout := os.Getenv("API_TIMEOUT"); timeout != "" </span><span class="cov0" title="0">{
                if t, err := time.ParseDuration(timeout); err == nil </span><span class="cov0" title="0">{
                        cfg.APITimeout = t
                }</span>
        }

        // Override database config from environment variables
        <span class="cov0" title="0">if dbHost := os.Getenv("DB_HOST"); dbHost != "" </span><span class="cov0" title="0">{
                cfg.DBHost = dbHost
        }</span>

        <span class="cov0" title="0">if dbPort := os.Getenv("DB_PORT"); dbPort != "" </span><span class="cov0" title="0">{
                if p, err := strconv.Atoi(dbPort); err == nil </span><span class="cov0" title="0">{
                        cfg.DBPort = p
                }</span>
        }

        <span class="cov0" title="0">if dbUser := os.Getenv("DB_USER"); dbUser != "" </span><span class="cov0" title="0">{
                cfg.DBUser = dbUser
        }</span>

        <span class="cov0" title="0">if dbPassword := os.Getenv("DB_PASSWORD"); dbPassword != "" </span><span class="cov0" title="0">{
                cfg.DBPassword = dbPassword
        }</span>

        <span class="cov0" title="0">if dbName := os.Getenv("DB_NAME"); dbName != "" </span><span class="cov0" title="0">{
                cfg.DBName = dbName
        }</span>

        <span class="cov0" title="0">return cfg</span>
}

// Addr returns the address to listen on
func (c *Config) Addr() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:%d", c.Host, c.Port)
}</span>

// DatabaseURL returns the PostgreSQL connection string
func (c *Config) DatabaseURL() string <span class="cov0" title="0">{
        return fmt.Sprintf("postgres://%s:%s@%s:%d/%s?sslmode=disable",
                c.DBUser,
                c.DBPassword,
                c.DBHost,
                c.DBPort,
                c.DBName,
        )
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "context"
        "errors"
        "fmt"
        "log"
        "reflect"

        "github.com/ivankorhner/polling-app/internal/ent/migrate"

        "entgo.io/ent"
        "entgo.io/ent/dialect"
        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
        "github.com/ivankorhner/polling-app/internal/ent/poll"
        "github.com/ivankorhner/polling-app/internal/ent/polloption"
        "github.com/ivankorhner/polling-app/internal/ent/user"
        "github.com/ivankorhner/polling-app/internal/ent/vote"
)

// Client is the client that holds all ent builders.
type Client struct {
        config
        // Schema is the client for creating, migrating and dropping schema.
        Schema *migrate.Schema
        // Poll is the client for interacting with the Poll builders.
        Poll *PollClient
        // PollOption is the client for interacting with the PollOption builders.
        PollOption *PollOptionClient
        // User is the client for interacting with the User builders.
        User *UserClient
        // Vote is the client for interacting with the Vote builders.
        Vote *VoteClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client <span class="cov0" title="0">{
        client := &amp;Client{config: newConfig(opts...)}
        client.init()
        return client
}</span>

func (c *Client) init() <span class="cov0" title="0">{
        c.Schema = migrate.NewSchema(c.driver)
        c.Poll = NewPollClient(c.config)
        c.PollOption = NewPollOptionClient(c.config)
        c.User = NewUserClient(c.config)
        c.Vote = NewVoteClient(c.config)
}</span>

type (
        // config is the configuration for the client and its builder.
        config struct {
                // driver used for executing database requests.
                driver dialect.Driver
                // debug enable a debug logging.
                debug bool
                // log used for logging on debug mode.
                log func(...any)
                // hooks to execute on mutations.
                hooks *hooks
                // interceptors to execute on queries.
                inters *inters
        }
        // Option function to configure the client.
        Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config <span class="cov0" title="0">{
        cfg := config{log: log.Println, hooks: &amp;hooks{}, inters: &amp;inters{}}
        cfg.options(opts...)
        return cfg
}</span>

// options applies the options on the config object.
func (c *config) options(opts ...Option) <span class="cov0" title="0">{
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(c)
        }</span>
        <span class="cov0" title="0">if c.debug </span><span class="cov0" title="0">{
                c.driver = dialect.Debug(c.driver, c.log)
        }</span>
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option <span class="cov0" title="0">{
        return func(c *config) </span><span class="cov0" title="0">{
                c.debug = true
        }</span>
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option <span class="cov0" title="0">{
        return func(c *config) </span><span class="cov0" title="0">{
                c.log = fn
        }</span>
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option <span class="cov0" title="0">{
        return func(c *config) </span><span class="cov0" title="0">{
                c.driver = driver
        }</span>
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) <span class="cov0" title="0">{
        switch driverName </span>{
        case dialect.MySQL, dialect.Postgres, dialect.SQLite:<span class="cov0" title="0">
                drv, err := sql.Open(driverName, dataSourceName)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return NewClient(append(options, Driver(drv))...), nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported driver: %q", driverName)</span>
        }
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) <span class="cov0" title="0">{
        if _, ok := c.driver.(*txDriver); ok </span><span class="cov0" title="0">{
                return nil, ErrTxStarted
        }</span>
        <span class="cov0" title="0">tx, err := newTx(ctx, c.driver)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ent: starting a transaction: %w", err)
        }</span>
        <span class="cov0" title="0">cfg := c.config
        cfg.driver = tx
        return &amp;Tx{
                ctx:        ctx,
                config:     cfg,
                Poll:       NewPollClient(cfg),
                PollOption: NewPollOptionClient(cfg),
                User:       NewUserClient(cfg),
                Vote:       NewVoteClient(cfg),
        }, nil</span>
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) <span class="cov0" title="0">{
        if _, ok := c.driver.(*txDriver); ok </span><span class="cov0" title="0">{
                return nil, errors.New("ent: cannot start a transaction within a transaction")
        }</span>
        <span class="cov0" title="0">tx, err := c.driver.(interface {
                BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
        }).BeginTx(ctx, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ent: starting a transaction: %w", err)
        }</span>
        <span class="cov0" title="0">cfg := c.config
        cfg.driver = &amp;txDriver{tx: tx, drv: c.driver}
        return &amp;Tx{
                ctx:        ctx,
                config:     cfg,
                Poll:       NewPollClient(cfg),
                PollOption: NewPollOptionClient(cfg),
                User:       NewUserClient(cfg),
                Vote:       NewVoteClient(cfg),
        }, nil</span>
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//        client.Debug().
//                Poll.
//                Query().
//                Count(ctx)
func (c *Client) Debug() *Client <span class="cov0" title="0">{
        if c.debug </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">cfg := c.config
        cfg.driver = dialect.Debug(c.driver, c.log)
        client := &amp;Client{config: cfg}
        client.init()
        return client</span>
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error <span class="cov0" title="0">{
        return c.driver.Close()
}</span>

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) <span class="cov0" title="0">{
        c.Poll.Use(hooks...)
        c.PollOption.Use(hooks...)
        c.User.Use(hooks...)
        c.Vote.Use(hooks...)
}</span>

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) <span class="cov0" title="0">{
        c.Poll.Intercept(interceptors...)
        c.PollOption.Intercept(interceptors...)
        c.User.Intercept(interceptors...)
        c.Vote.Intercept(interceptors...)
}</span>

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) <span class="cov0" title="0">{
        switch m := m.(type) </span>{
        case *PollMutation:<span class="cov0" title="0">
                return c.Poll.mutate(ctx, m)</span>
        case *PollOptionMutation:<span class="cov0" title="0">
                return c.PollOption.mutate(ctx, m)</span>
        case *UserMutation:<span class="cov0" title="0">
                return c.User.mutate(ctx, m)</span>
        case *VoteMutation:<span class="cov0" title="0">
                return c.Vote.mutate(ctx, m)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("ent: unknown mutation type %T", m)</span>
        }
}

// PollClient is a client for the Poll schema.
type PollClient struct {
        config
}

// NewPollClient returns a client for the Poll from the given config.
func NewPollClient(c config) *PollClient <span class="cov0" title="0">{
        return &amp;PollClient{config: c}
}</span>

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `poll.Hooks(f(g(h())))`.
func (c *PollClient) Use(hooks ...Hook) <span class="cov0" title="0">{
        c.hooks.Poll = append(c.hooks.Poll, hooks...)
}</span>

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `poll.Intercept(f(g(h())))`.
func (c *PollClient) Intercept(interceptors ...Interceptor) <span class="cov0" title="0">{
        c.inters.Poll = append(c.inters.Poll, interceptors...)
}</span>

// Create returns a builder for creating a Poll entity.
func (c *PollClient) Create() *PollCreate <span class="cov0" title="0">{
        mutation := newPollMutation(c.config, OpCreate)
        return &amp;PollCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// CreateBulk returns a builder for creating a bulk of Poll entities.
func (c *PollClient) CreateBulk(builders ...*PollCreate) *PollCreateBulk <span class="cov0" title="0">{
        return &amp;PollCreateBulk{config: c.config, builders: builders}
}</span>

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PollClient) MapCreateBulk(slice any, setFunc func(*PollCreate, int)) *PollCreateBulk <span class="cov0" title="0">{
        rv := reflect.ValueOf(slice)
        if rv.Kind() != reflect.Slice </span><span class="cov0" title="0">{
                return &amp;PollCreateBulk{err: fmt.Errorf("calling to PollClient.MapCreateBulk with wrong type %T, need slice", slice)}
        }</span>
        <span class="cov0" title="0">builders := make([]*PollCreate, rv.Len())
        for i := 0; i &lt; rv.Len(); i++ </span><span class="cov0" title="0">{
                builders[i] = c.Create()
                setFunc(builders[i], i)
        }</span>
        <span class="cov0" title="0">return &amp;PollCreateBulk{config: c.config, builders: builders}</span>
}

// Update returns an update builder for Poll.
func (c *PollClient) Update() *PollUpdate <span class="cov0" title="0">{
        mutation := newPollMutation(c.config, OpUpdate)
        return &amp;PollUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// UpdateOne returns an update builder for the given entity.
func (c *PollClient) UpdateOne(_m *Poll) *PollUpdateOne <span class="cov0" title="0">{
        mutation := newPollMutation(c.config, OpUpdateOne, withPoll(_m))
        return &amp;PollUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// UpdateOneID returns an update builder for the given id.
func (c *PollClient) UpdateOneID(id int) *PollUpdateOne <span class="cov0" title="0">{
        mutation := newPollMutation(c.config, OpUpdateOne, withPollID(id))
        return &amp;PollUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// Delete returns a delete builder for Poll.
func (c *PollClient) Delete() *PollDelete <span class="cov0" title="0">{
        mutation := newPollMutation(c.config, OpDelete)
        return &amp;PollDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// DeleteOne returns a builder for deleting the given entity.
func (c *PollClient) DeleteOne(_m *Poll) *PollDeleteOne <span class="cov0" title="0">{
        return c.DeleteOneID(_m.ID)
}</span>

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PollClient) DeleteOneID(id int) *PollDeleteOne <span class="cov0" title="0">{
        builder := c.Delete().Where(poll.ID(id))
        builder.mutation.id = &amp;id
        builder.mutation.op = OpDeleteOne
        return &amp;PollDeleteOne{builder}
}</span>

// Query returns a query builder for Poll.
func (c *PollClient) Query() *PollQuery <span class="cov0" title="0">{
        return &amp;PollQuery{
                config: c.config,
                ctx:    &amp;QueryContext{Type: TypePoll},
                inters: c.Interceptors(),
        }
}</span>

// Get returns a Poll entity by its id.
func (c *PollClient) Get(ctx context.Context, id int) (*Poll, error) <span class="cov0" title="0">{
        return c.Query().Where(poll.ID(id)).Only(ctx)
}</span>

// GetX is like Get, but panics if an error occurs.
func (c *PollClient) GetX(ctx context.Context, id int) *Poll <span class="cov0" title="0">{
        obj, err := c.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return obj</span>
}

// QueryOwner queries the owner edge of a Poll.
func (c *PollClient) QueryOwner(_m *Poll) *UserQuery <span class="cov0" title="0">{
        query := (&amp;UserClient{config: c.config}).Query()
        query.path = func(context.Context) (fromV *sql.Selector, _ error) </span><span class="cov0" title="0">{
                id := _m.ID
                step := sqlgraph.NewStep(
                        sqlgraph.From(poll.Table, poll.FieldID, id),
                        sqlgraph.To(user.Table, user.FieldID),
                        sqlgraph.Edge(sqlgraph.M2O, true, poll.OwnerTable, poll.OwnerColumn),
                )
                fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
                return fromV, nil
        }</span>
        <span class="cov0" title="0">return query</span>
}

// QueryOptions queries the options edge of a Poll.
func (c *PollClient) QueryOptions(_m *Poll) *PollOptionQuery <span class="cov0" title="0">{
        query := (&amp;PollOptionClient{config: c.config}).Query()
        query.path = func(context.Context) (fromV *sql.Selector, _ error) </span><span class="cov0" title="0">{
                id := _m.ID
                step := sqlgraph.NewStep(
                        sqlgraph.From(poll.Table, poll.FieldID, id),
                        sqlgraph.To(polloption.Table, polloption.FieldID),
                        sqlgraph.Edge(sqlgraph.O2M, false, poll.OptionsTable, poll.OptionsColumn),
                )
                fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
                return fromV, nil
        }</span>
        <span class="cov0" title="0">return query</span>
}

// QueryVotes queries the votes edge of a Poll.
func (c *PollClient) QueryVotes(_m *Poll) *VoteQuery <span class="cov0" title="0">{
        query := (&amp;VoteClient{config: c.config}).Query()
        query.path = func(context.Context) (fromV *sql.Selector, _ error) </span><span class="cov0" title="0">{
                id := _m.ID
                step := sqlgraph.NewStep(
                        sqlgraph.From(poll.Table, poll.FieldID, id),
                        sqlgraph.To(vote.Table, vote.FieldID),
                        sqlgraph.Edge(sqlgraph.O2M, false, poll.VotesTable, poll.VotesColumn),
                )
                fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
                return fromV, nil
        }</span>
        <span class="cov0" title="0">return query</span>
}

// Hooks returns the client hooks.
func (c *PollClient) Hooks() []Hook <span class="cov0" title="0">{
        return c.hooks.Poll
}</span>

// Interceptors returns the client interceptors.
func (c *PollClient) Interceptors() []Interceptor <span class="cov0" title="0">{
        return c.inters.Poll
}</span>

func (c *PollClient) mutate(ctx context.Context, m *PollMutation) (Value, error) <span class="cov0" title="0">{
        switch m.Op() </span>{
        case OpCreate:<span class="cov0" title="0">
                return (&amp;PollCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)</span>
        case OpUpdate:<span class="cov0" title="0">
                return (&amp;PollUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)</span>
        case OpUpdateOne:<span class="cov0" title="0">
                return (&amp;PollUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)</span>
        case OpDelete, OpDeleteOne:<span class="cov0" title="0">
                return (&amp;PollDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("ent: unknown Poll mutation op: %q", m.Op())</span>
        }
}

// PollOptionClient is a client for the PollOption schema.
type PollOptionClient struct {
        config
}

// NewPollOptionClient returns a client for the PollOption from the given config.
func NewPollOptionClient(c config) *PollOptionClient <span class="cov0" title="0">{
        return &amp;PollOptionClient{config: c}
}</span>

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `polloption.Hooks(f(g(h())))`.
func (c *PollOptionClient) Use(hooks ...Hook) <span class="cov0" title="0">{
        c.hooks.PollOption = append(c.hooks.PollOption, hooks...)
}</span>

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `polloption.Intercept(f(g(h())))`.
func (c *PollOptionClient) Intercept(interceptors ...Interceptor) <span class="cov0" title="0">{
        c.inters.PollOption = append(c.inters.PollOption, interceptors...)
}</span>

// Create returns a builder for creating a PollOption entity.
func (c *PollOptionClient) Create() *PollOptionCreate <span class="cov0" title="0">{
        mutation := newPollOptionMutation(c.config, OpCreate)
        return &amp;PollOptionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// CreateBulk returns a builder for creating a bulk of PollOption entities.
func (c *PollOptionClient) CreateBulk(builders ...*PollOptionCreate) *PollOptionCreateBulk <span class="cov0" title="0">{
        return &amp;PollOptionCreateBulk{config: c.config, builders: builders}
}</span>

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PollOptionClient) MapCreateBulk(slice any, setFunc func(*PollOptionCreate, int)) *PollOptionCreateBulk <span class="cov0" title="0">{
        rv := reflect.ValueOf(slice)
        if rv.Kind() != reflect.Slice </span><span class="cov0" title="0">{
                return &amp;PollOptionCreateBulk{err: fmt.Errorf("calling to PollOptionClient.MapCreateBulk with wrong type %T, need slice", slice)}
        }</span>
        <span class="cov0" title="0">builders := make([]*PollOptionCreate, rv.Len())
        for i := 0; i &lt; rv.Len(); i++ </span><span class="cov0" title="0">{
                builders[i] = c.Create()
                setFunc(builders[i], i)
        }</span>
        <span class="cov0" title="0">return &amp;PollOptionCreateBulk{config: c.config, builders: builders}</span>
}

// Update returns an update builder for PollOption.
func (c *PollOptionClient) Update() *PollOptionUpdate <span class="cov0" title="0">{
        mutation := newPollOptionMutation(c.config, OpUpdate)
        return &amp;PollOptionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// UpdateOne returns an update builder for the given entity.
func (c *PollOptionClient) UpdateOne(_m *PollOption) *PollOptionUpdateOne <span class="cov0" title="0">{
        mutation := newPollOptionMutation(c.config, OpUpdateOne, withPollOption(_m))
        return &amp;PollOptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// UpdateOneID returns an update builder for the given id.
func (c *PollOptionClient) UpdateOneID(id int) *PollOptionUpdateOne <span class="cov0" title="0">{
        mutation := newPollOptionMutation(c.config, OpUpdateOne, withPollOptionID(id))
        return &amp;PollOptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// Delete returns a delete builder for PollOption.
func (c *PollOptionClient) Delete() *PollOptionDelete <span class="cov0" title="0">{
        mutation := newPollOptionMutation(c.config, OpDelete)
        return &amp;PollOptionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// DeleteOne returns a builder for deleting the given entity.
func (c *PollOptionClient) DeleteOne(_m *PollOption) *PollOptionDeleteOne <span class="cov0" title="0">{
        return c.DeleteOneID(_m.ID)
}</span>

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PollOptionClient) DeleteOneID(id int) *PollOptionDeleteOne <span class="cov0" title="0">{
        builder := c.Delete().Where(polloption.ID(id))
        builder.mutation.id = &amp;id
        builder.mutation.op = OpDeleteOne
        return &amp;PollOptionDeleteOne{builder}
}</span>

// Query returns a query builder for PollOption.
func (c *PollOptionClient) Query() *PollOptionQuery <span class="cov0" title="0">{
        return &amp;PollOptionQuery{
                config: c.config,
                ctx:    &amp;QueryContext{Type: TypePollOption},
                inters: c.Interceptors(),
        }
}</span>

// Get returns a PollOption entity by its id.
func (c *PollOptionClient) Get(ctx context.Context, id int) (*PollOption, error) <span class="cov0" title="0">{
        return c.Query().Where(polloption.ID(id)).Only(ctx)
}</span>

// GetX is like Get, but panics if an error occurs.
func (c *PollOptionClient) GetX(ctx context.Context, id int) *PollOption <span class="cov0" title="0">{
        obj, err := c.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return obj</span>
}

// QueryPoll queries the poll edge of a PollOption.
func (c *PollOptionClient) QueryPoll(_m *PollOption) *PollQuery <span class="cov0" title="0">{
        query := (&amp;PollClient{config: c.config}).Query()
        query.path = func(context.Context) (fromV *sql.Selector, _ error) </span><span class="cov0" title="0">{
                id := _m.ID
                step := sqlgraph.NewStep(
                        sqlgraph.From(polloption.Table, polloption.FieldID, id),
                        sqlgraph.To(poll.Table, poll.FieldID),
                        sqlgraph.Edge(sqlgraph.M2O, true, polloption.PollTable, polloption.PollColumn),
                )
                fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
                return fromV, nil
        }</span>
        <span class="cov0" title="0">return query</span>
}

// QueryVotes queries the votes edge of a PollOption.
func (c *PollOptionClient) QueryVotes(_m *PollOption) *VoteQuery <span class="cov0" title="0">{
        query := (&amp;VoteClient{config: c.config}).Query()
        query.path = func(context.Context) (fromV *sql.Selector, _ error) </span><span class="cov0" title="0">{
                id := _m.ID
                step := sqlgraph.NewStep(
                        sqlgraph.From(polloption.Table, polloption.FieldID, id),
                        sqlgraph.To(vote.Table, vote.FieldID),
                        sqlgraph.Edge(sqlgraph.O2M, false, polloption.VotesTable, polloption.VotesColumn),
                )
                fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
                return fromV, nil
        }</span>
        <span class="cov0" title="0">return query</span>
}

// Hooks returns the client hooks.
func (c *PollOptionClient) Hooks() []Hook <span class="cov0" title="0">{
        return c.hooks.PollOption
}</span>

// Interceptors returns the client interceptors.
func (c *PollOptionClient) Interceptors() []Interceptor <span class="cov0" title="0">{
        return c.inters.PollOption
}</span>

func (c *PollOptionClient) mutate(ctx context.Context, m *PollOptionMutation) (Value, error) <span class="cov0" title="0">{
        switch m.Op() </span>{
        case OpCreate:<span class="cov0" title="0">
                return (&amp;PollOptionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)</span>
        case OpUpdate:<span class="cov0" title="0">
                return (&amp;PollOptionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)</span>
        case OpUpdateOne:<span class="cov0" title="0">
                return (&amp;PollOptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)</span>
        case OpDelete, OpDeleteOne:<span class="cov0" title="0">
                return (&amp;PollOptionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("ent: unknown PollOption mutation op: %q", m.Op())</span>
        }
}

// UserClient is a client for the User schema.
type UserClient struct {
        config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient <span class="cov0" title="0">{
        return &amp;UserClient{config: c}
}</span>

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) <span class="cov0" title="0">{
        c.hooks.User = append(c.hooks.User, hooks...)
}</span>

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) <span class="cov0" title="0">{
        c.inters.User = append(c.inters.User, interceptors...)
}</span>

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate <span class="cov0" title="0">{
        mutation := newUserMutation(c.config, OpCreate)
        return &amp;UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk <span class="cov0" title="0">{
        return &amp;UserCreateBulk{config: c.config, builders: builders}
}</span>

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk <span class="cov0" title="0">{
        rv := reflect.ValueOf(slice)
        if rv.Kind() != reflect.Slice </span><span class="cov0" title="0">{
                return &amp;UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
        }</span>
        <span class="cov0" title="0">builders := make([]*UserCreate, rv.Len())
        for i := 0; i &lt; rv.Len(); i++ </span><span class="cov0" title="0">{
                builders[i] = c.Create()
                setFunc(builders[i], i)
        }</span>
        <span class="cov0" title="0">return &amp;UserCreateBulk{config: c.config, builders: builders}</span>
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate <span class="cov0" title="0">{
        mutation := newUserMutation(c.config, OpUpdate)
        return &amp;UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(_m *User) *UserUpdateOne <span class="cov0" title="0">{
        mutation := newUserMutation(c.config, OpUpdateOne, withUser(_m))
        return &amp;UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id int) *UserUpdateOne <span class="cov0" title="0">{
        mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
        return &amp;UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete <span class="cov0" title="0">{
        mutation := newUserMutation(c.config, OpDelete)
        return &amp;UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(_m *User) *UserDeleteOne <span class="cov0" title="0">{
        return c.DeleteOneID(_m.ID)
}</span>

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id int) *UserDeleteOne <span class="cov0" title="0">{
        builder := c.Delete().Where(user.ID(id))
        builder.mutation.id = &amp;id
        builder.mutation.op = OpDeleteOne
        return &amp;UserDeleteOne{builder}
}</span>

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery <span class="cov0" title="0">{
        return &amp;UserQuery{
                config: c.config,
                ctx:    &amp;QueryContext{Type: TypeUser},
                inters: c.Interceptors(),
        }
}</span>

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id int) (*User, error) <span class="cov0" title="0">{
        return c.Query().Where(user.ID(id)).Only(ctx)
}</span>

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id int) *User <span class="cov0" title="0">{
        obj, err := c.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return obj</span>
}

// QueryPolls queries the polls edge of a User.
func (c *UserClient) QueryPolls(_m *User) *PollQuery <span class="cov0" title="0">{
        query := (&amp;PollClient{config: c.config}).Query()
        query.path = func(context.Context) (fromV *sql.Selector, _ error) </span><span class="cov0" title="0">{
                id := _m.ID
                step := sqlgraph.NewStep(
                        sqlgraph.From(user.Table, user.FieldID, id),
                        sqlgraph.To(poll.Table, poll.FieldID),
                        sqlgraph.Edge(sqlgraph.O2M, false, user.PollsTable, user.PollsColumn),
                )
                fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
                return fromV, nil
        }</span>
        <span class="cov0" title="0">return query</span>
}

// QueryVotes queries the votes edge of a User.
func (c *UserClient) QueryVotes(_m *User) *VoteQuery <span class="cov0" title="0">{
        query := (&amp;VoteClient{config: c.config}).Query()
        query.path = func(context.Context) (fromV *sql.Selector, _ error) </span><span class="cov0" title="0">{
                id := _m.ID
                step := sqlgraph.NewStep(
                        sqlgraph.From(user.Table, user.FieldID, id),
                        sqlgraph.To(vote.Table, vote.FieldID),
                        sqlgraph.Edge(sqlgraph.O2M, false, user.VotesTable, user.VotesColumn),
                )
                fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
                return fromV, nil
        }</span>
        <span class="cov0" title="0">return query</span>
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook <span class="cov0" title="0">{
        return c.hooks.User
}</span>

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor <span class="cov0" title="0">{
        return c.inters.User
}</span>

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) <span class="cov0" title="0">{
        switch m.Op() </span>{
        case OpCreate:<span class="cov0" title="0">
                return (&amp;UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)</span>
        case OpUpdate:<span class="cov0" title="0">
                return (&amp;UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)</span>
        case OpUpdateOne:<span class="cov0" title="0">
                return (&amp;UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)</span>
        case OpDelete, OpDeleteOne:<span class="cov0" title="0">
                return (&amp;UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())</span>
        }
}

// VoteClient is a client for the Vote schema.
type VoteClient struct {
        config
}

// NewVoteClient returns a client for the Vote from the given config.
func NewVoteClient(c config) *VoteClient <span class="cov0" title="0">{
        return &amp;VoteClient{config: c}
}</span>

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `vote.Hooks(f(g(h())))`.
func (c *VoteClient) Use(hooks ...Hook) <span class="cov0" title="0">{
        c.hooks.Vote = append(c.hooks.Vote, hooks...)
}</span>

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `vote.Intercept(f(g(h())))`.
func (c *VoteClient) Intercept(interceptors ...Interceptor) <span class="cov0" title="0">{
        c.inters.Vote = append(c.inters.Vote, interceptors...)
}</span>

// Create returns a builder for creating a Vote entity.
func (c *VoteClient) Create() *VoteCreate <span class="cov0" title="0">{
        mutation := newVoteMutation(c.config, OpCreate)
        return &amp;VoteCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// CreateBulk returns a builder for creating a bulk of Vote entities.
func (c *VoteClient) CreateBulk(builders ...*VoteCreate) *VoteCreateBulk <span class="cov0" title="0">{
        return &amp;VoteCreateBulk{config: c.config, builders: builders}
}</span>

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VoteClient) MapCreateBulk(slice any, setFunc func(*VoteCreate, int)) *VoteCreateBulk <span class="cov0" title="0">{
        rv := reflect.ValueOf(slice)
        if rv.Kind() != reflect.Slice </span><span class="cov0" title="0">{
                return &amp;VoteCreateBulk{err: fmt.Errorf("calling to VoteClient.MapCreateBulk with wrong type %T, need slice", slice)}
        }</span>
        <span class="cov0" title="0">builders := make([]*VoteCreate, rv.Len())
        for i := 0; i &lt; rv.Len(); i++ </span><span class="cov0" title="0">{
                builders[i] = c.Create()
                setFunc(builders[i], i)
        }</span>
        <span class="cov0" title="0">return &amp;VoteCreateBulk{config: c.config, builders: builders}</span>
}

// Update returns an update builder for Vote.
func (c *VoteClient) Update() *VoteUpdate <span class="cov0" title="0">{
        mutation := newVoteMutation(c.config, OpUpdate)
        return &amp;VoteUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// UpdateOne returns an update builder for the given entity.
func (c *VoteClient) UpdateOne(_m *Vote) *VoteUpdateOne <span class="cov0" title="0">{
        mutation := newVoteMutation(c.config, OpUpdateOne, withVote(_m))
        return &amp;VoteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// UpdateOneID returns an update builder for the given id.
func (c *VoteClient) UpdateOneID(id int) *VoteUpdateOne <span class="cov0" title="0">{
        mutation := newVoteMutation(c.config, OpUpdateOne, withVoteID(id))
        return &amp;VoteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// Delete returns a delete builder for Vote.
func (c *VoteClient) Delete() *VoteDelete <span class="cov0" title="0">{
        mutation := newVoteMutation(c.config, OpDelete)
        return &amp;VoteDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// DeleteOne returns a builder for deleting the given entity.
func (c *VoteClient) DeleteOne(_m *Vote) *VoteDeleteOne <span class="cov0" title="0">{
        return c.DeleteOneID(_m.ID)
}</span>

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VoteClient) DeleteOneID(id int) *VoteDeleteOne <span class="cov0" title="0">{
        builder := c.Delete().Where(vote.ID(id))
        builder.mutation.id = &amp;id
        builder.mutation.op = OpDeleteOne
        return &amp;VoteDeleteOne{builder}
}</span>

// Query returns a query builder for Vote.
func (c *VoteClient) Query() *VoteQuery <span class="cov0" title="0">{
        return &amp;VoteQuery{
                config: c.config,
                ctx:    &amp;QueryContext{Type: TypeVote},
                inters: c.Interceptors(),
        }
}</span>

// Get returns a Vote entity by its id.
func (c *VoteClient) Get(ctx context.Context, id int) (*Vote, error) <span class="cov0" title="0">{
        return c.Query().Where(vote.ID(id)).Only(ctx)
}</span>

// GetX is like Get, but panics if an error occurs.
func (c *VoteClient) GetX(ctx context.Context, id int) *Vote <span class="cov0" title="0">{
        obj, err := c.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return obj</span>
}

// QueryPoll queries the poll edge of a Vote.
func (c *VoteClient) QueryPoll(_m *Vote) *PollQuery <span class="cov0" title="0">{
        query := (&amp;PollClient{config: c.config}).Query()
        query.path = func(context.Context) (fromV *sql.Selector, _ error) </span><span class="cov0" title="0">{
                id := _m.ID
                step := sqlgraph.NewStep(
                        sqlgraph.From(vote.Table, vote.FieldID, id),
                        sqlgraph.To(poll.Table, poll.FieldID),
                        sqlgraph.Edge(sqlgraph.M2O, true, vote.PollTable, vote.PollColumn),
                )
                fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
                return fromV, nil
        }</span>
        <span class="cov0" title="0">return query</span>
}

// QueryOption queries the option edge of a Vote.
func (c *VoteClient) QueryOption(_m *Vote) *PollOptionQuery <span class="cov0" title="0">{
        query := (&amp;PollOptionClient{config: c.config}).Query()
        query.path = func(context.Context) (fromV *sql.Selector, _ error) </span><span class="cov0" title="0">{
                id := _m.ID
                step := sqlgraph.NewStep(
                        sqlgraph.From(vote.Table, vote.FieldID, id),
                        sqlgraph.To(polloption.Table, polloption.FieldID),
                        sqlgraph.Edge(sqlgraph.M2O, true, vote.OptionTable, vote.OptionColumn),
                )
                fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
                return fromV, nil
        }</span>
        <span class="cov0" title="0">return query</span>
}

// QueryUser queries the user edge of a Vote.
func (c *VoteClient) QueryUser(_m *Vote) *UserQuery <span class="cov0" title="0">{
        query := (&amp;UserClient{config: c.config}).Query()
        query.path = func(context.Context) (fromV *sql.Selector, _ error) </span><span class="cov0" title="0">{
                id := _m.ID
                step := sqlgraph.NewStep(
                        sqlgraph.From(vote.Table, vote.FieldID, id),
                        sqlgraph.To(user.Table, user.FieldID),
                        sqlgraph.Edge(sqlgraph.M2O, true, vote.UserTable, vote.UserColumn),
                )
                fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
                return fromV, nil
        }</span>
        <span class="cov0" title="0">return query</span>
}

// Hooks returns the client hooks.
func (c *VoteClient) Hooks() []Hook <span class="cov0" title="0">{
        return c.hooks.Vote
}</span>

// Interceptors returns the client interceptors.
func (c *VoteClient) Interceptors() []Interceptor <span class="cov0" title="0">{
        return c.inters.Vote
}</span>

func (c *VoteClient) mutate(ctx context.Context, m *VoteMutation) (Value, error) <span class="cov0" title="0">{
        switch m.Op() </span>{
        case OpCreate:<span class="cov0" title="0">
                return (&amp;VoteCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)</span>
        case OpUpdate:<span class="cov0" title="0">
                return (&amp;VoteUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)</span>
        case OpUpdateOne:<span class="cov0" title="0">
                return (&amp;VoteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)</span>
        case OpDelete, OpDeleteOne:<span class="cov0" title="0">
                return (&amp;VoteDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("ent: unknown Vote mutation op: %q", m.Op())</span>
        }
}

// hooks and interceptors per client, for fast access.
type (
        hooks struct {
                Poll, PollOption, User, Vote []ent.Hook
        }
        inters struct {
                Poll, PollOption, User, Vote []ent.Interceptor
        }
)
</pre>
		
		<pre class="file" id="file4" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "context"
        "errors"
        "fmt"
        "reflect"
        "sync"

        "entgo.io/ent"
        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
        "github.com/ivankorhner/polling-app/internal/ent/poll"
        "github.com/ivankorhner/polling-app/internal/ent/polloption"
        "github.com/ivankorhner/polling-app/internal/ent/user"
        "github.com/ivankorhner/polling-app/internal/ent/vote"
)

// ent aliases to avoid import conflicts in user's code.
type (
        Op            = ent.Op
        Hook          = ent.Hook
        Value         = ent.Value
        Query         = ent.Query
        QueryContext  = ent.QueryContext
        Querier       = ent.Querier
        QuerierFunc   = ent.QuerierFunc
        Interceptor   = ent.Interceptor
        InterceptFunc = ent.InterceptFunc
        Traverser     = ent.Traverser
        TraverseFunc  = ent.TraverseFunc
        Policy        = ent.Policy
        Mutator       = ent.Mutator
        Mutation      = ent.Mutation
        MutateFunc    = ent.MutateFunc
)

type clientCtxKey struct{}

// FromContext returns a Client stored inside a context, or nil if there isn't one.
func FromContext(ctx context.Context) *Client <span class="cov0" title="0">{
        c, _ := ctx.Value(clientCtxKey{}).(*Client)
        return c
}</span>

// NewContext returns a new context with the given Client attached.
func NewContext(parent context.Context, c *Client) context.Context <span class="cov0" title="0">{
        return context.WithValue(parent, clientCtxKey{}, c)
}</span>

type txCtxKey struct{}

// TxFromContext returns a Tx stored inside a context, or nil if there isn't one.
func TxFromContext(ctx context.Context) *Tx <span class="cov0" title="0">{
        tx, _ := ctx.Value(txCtxKey{}).(*Tx)
        return tx
}</span>

// NewTxContext returns a new context with the given Tx attached.
func NewTxContext(parent context.Context, tx *Tx) context.Context <span class="cov0" title="0">{
        return context.WithValue(parent, txCtxKey{}, tx)
}</span>

// OrderFunc applies an ordering on the sql selector.
// Deprecated: Use Asc/Desc functions or the package builders instead.
type OrderFunc func(*sql.Selector)

var (
        initCheck   sync.Once
        columnCheck sql.ColumnCheck
)

// checkColumn checks if the column exists in the given table.
func checkColumn(t, c string) error <span class="cov0" title="0">{
        initCheck.Do(func() </span><span class="cov0" title="0">{
                columnCheck = sql.NewColumnCheck(map[string]func(string) bool{
                        poll.Table:       poll.ValidColumn,
                        polloption.Table: polloption.ValidColumn,
                        user.Table:       user.ValidColumn,
                        vote.Table:       vote.ValidColumn,
                })
        }</span>)
        <span class="cov0" title="0">return columnCheck(t, c)</span>
}

// Asc applies the given fields in ASC order.
func Asc(fields ...string) func(*sql.Selector) <span class="cov0" title="0">{
        return func(s *sql.Selector) </span><span class="cov0" title="0">{
                for _, f := range fields </span><span class="cov0" title="0">{
                        if err := checkColumn(s.TableName(), f); err != nil </span><span class="cov0" title="0">{
                                s.AddError(&amp;ValidationError{Name: f, err: fmt.Errorf("ent: %w", err)})
                        }</span>
                        <span class="cov0" title="0">s.OrderBy(sql.Asc(s.C(f)))</span>
                }
        }
}

// Desc applies the given fields in DESC order.
func Desc(fields ...string) func(*sql.Selector) <span class="cov0" title="0">{
        return func(s *sql.Selector) </span><span class="cov0" title="0">{
                for _, f := range fields </span><span class="cov0" title="0">{
                        if err := checkColumn(s.TableName(), f); err != nil </span><span class="cov0" title="0">{
                                s.AddError(&amp;ValidationError{Name: f, err: fmt.Errorf("ent: %w", err)})
                        }</span>
                        <span class="cov0" title="0">s.OrderBy(sql.Desc(s.C(f)))</span>
                }
        }
}

// AggregateFunc applies an aggregation step on the group-by traversal/selector.
type AggregateFunc func(*sql.Selector) string

// As is a pseudo aggregation function for renaming another other functions with custom names. For example:
//
//        GroupBy(field1, field2).
//        Aggregate(ent.As(ent.Sum(field1), "sum_field1"), (ent.As(ent.Sum(field2), "sum_field2")).
//        Scan(ctx, &amp;v)
func As(fn AggregateFunc, end string) AggregateFunc <span class="cov0" title="0">{
        return func(s *sql.Selector) string </span><span class="cov0" title="0">{
                return sql.As(fn(s), end)
        }</span>
}

// Count applies the "count" aggregation function on each group.
func Count() AggregateFunc <span class="cov0" title="0">{
        return func(s *sql.Selector) string </span><span class="cov0" title="0">{
                return sql.Count("*")
        }</span>
}

// Max applies the "max" aggregation function on the given field of each group.
func Max(field string) AggregateFunc <span class="cov0" title="0">{
        return func(s *sql.Selector) string </span><span class="cov0" title="0">{
                if err := checkColumn(s.TableName(), field); err != nil </span><span class="cov0" title="0">{
                        s.AddError(&amp;ValidationError{Name: field, err: fmt.Errorf("ent: %w", err)})
                        return ""
                }</span>
                <span class="cov0" title="0">return sql.Max(s.C(field))</span>
        }
}

// Mean applies the "mean" aggregation function on the given field of each group.
func Mean(field string) AggregateFunc <span class="cov0" title="0">{
        return func(s *sql.Selector) string </span><span class="cov0" title="0">{
                if err := checkColumn(s.TableName(), field); err != nil </span><span class="cov0" title="0">{
                        s.AddError(&amp;ValidationError{Name: field, err: fmt.Errorf("ent: %w", err)})
                        return ""
                }</span>
                <span class="cov0" title="0">return sql.Avg(s.C(field))</span>
        }
}

// Min applies the "min" aggregation function on the given field of each group.
func Min(field string) AggregateFunc <span class="cov0" title="0">{
        return func(s *sql.Selector) string </span><span class="cov0" title="0">{
                if err := checkColumn(s.TableName(), field); err != nil </span><span class="cov0" title="0">{
                        s.AddError(&amp;ValidationError{Name: field, err: fmt.Errorf("ent: %w", err)})
                        return ""
                }</span>
                <span class="cov0" title="0">return sql.Min(s.C(field))</span>
        }
}

// Sum applies the "sum" aggregation function on the given field of each group.
func Sum(field string) AggregateFunc <span class="cov0" title="0">{
        return func(s *sql.Selector) string </span><span class="cov0" title="0">{
                if err := checkColumn(s.TableName(), field); err != nil </span><span class="cov0" title="0">{
                        s.AddError(&amp;ValidationError{Name: field, err: fmt.Errorf("ent: %w", err)})
                        return ""
                }</span>
                <span class="cov0" title="0">return sql.Sum(s.C(field))</span>
        }
}

// ValidationError returns when validating a field or edge fails.
type ValidationError struct {
        Name string // Field or edge name.
        err  error
}

// Error implements the error interface.
func (e *ValidationError) Error() string <span class="cov0" title="0">{
        return e.err.Error()
}</span>

// Unwrap implements the errors.Wrapper interface.
func (e *ValidationError) Unwrap() error <span class="cov0" title="0">{
        return e.err
}</span>

// IsValidationError returns a boolean indicating whether the error is a validation error.
func IsValidationError(err error) bool <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">var e *ValidationError
        return errors.As(err, &amp;e)</span>
}

// NotFoundError returns when trying to fetch a specific entity and it was not found in the database.
type NotFoundError struct {
        label string
}

// Error implements the error interface.
func (e *NotFoundError) Error() string <span class="cov0" title="0">{
        return "ent: " + e.label + " not found"
}</span>

// IsNotFound returns a boolean indicating whether the error is a not found error.
func IsNotFound(err error) bool <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">var e *NotFoundError
        return errors.As(err, &amp;e)</span>
}

// MaskNotFound masks not found error.
func MaskNotFound(err error) error <span class="cov0" title="0">{
        if IsNotFound(err) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return err</span>
}

// NotSingularError returns when trying to fetch a singular entity and more then one was found in the database.
type NotSingularError struct {
        label string
}

// Error implements the error interface.
func (e *NotSingularError) Error() string <span class="cov0" title="0">{
        return "ent: " + e.label + " not singular"
}</span>

// IsNotSingular returns a boolean indicating whether the error is a not singular error.
func IsNotSingular(err error) bool <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">var e *NotSingularError
        return errors.As(err, &amp;e)</span>
}

// NotLoadedError returns when trying to get a node that was not loaded by the query.
type NotLoadedError struct {
        edge string
}

// Error implements the error interface.
func (e *NotLoadedError) Error() string <span class="cov0" title="0">{
        return "ent: " + e.edge + " edge was not loaded"
}</span>

// IsNotLoaded returns a boolean indicating whether the error is a not loaded error.
func IsNotLoaded(err error) bool <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">var e *NotLoadedError
        return errors.As(err, &amp;e)</span>
}

// ConstraintError returns when trying to create/update one or more entities and
// one or more of their constraints failed. For example, violation of edge or
// field uniqueness.
type ConstraintError struct {
        msg  string
        wrap error
}

// Error implements the error interface.
func (e ConstraintError) Error() string <span class="cov0" title="0">{
        return "ent: constraint failed: " + e.msg
}</span>

// Unwrap implements the errors.Wrapper interface.
func (e *ConstraintError) Unwrap() error <span class="cov0" title="0">{
        return e.wrap
}</span>

// IsConstraintError returns a boolean indicating whether the error is a constraint failure.
func IsConstraintError(err error) bool <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">var e *ConstraintError
        return errors.As(err, &amp;e)</span>
}

// selector embedded by the different Select/GroupBy builders.
type selector struct {
        label string
        flds  *[]string
        fns   []AggregateFunc
        scan  func(context.Context, any) error
}

// ScanX is like Scan, but panics if an error occurs.
func (s *selector) ScanX(ctx context.Context, v any) <span class="cov0" title="0">{
        if err := s.scan(ctx, v); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// Strings returns list of strings from a selector. It is only allowed when selecting one field.
func (s *selector) Strings(ctx context.Context) ([]string, error) <span class="cov0" title="0">{
        if len(*s.flds) &gt; 1 </span><span class="cov0" title="0">{
                return nil, errors.New("ent: Strings is not achievable when selecting more than 1 field")
        }</span>
        <span class="cov0" title="0">var v []string
        if err := s.scan(ctx, &amp;v); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return v, nil</span>
}

// StringsX is like Strings, but panics if an error occurs.
func (s *selector) StringsX(ctx context.Context) []string <span class="cov0" title="0">{
        v, err := s.Strings(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return v</span>
}

// String returns a single string from a selector. It is only allowed when selecting one field.
func (s *selector) String(ctx context.Context) (_ string, err error) <span class="cov0" title="0">{
        var v []string
        if v, err = s.Strings(ctx); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">switch len(v) </span>{
        case 1:<span class="cov0" title="0">
                return v[0], nil</span>
        case 0:<span class="cov0" title="0">
                err = &amp;NotFoundError{s.label}</span>
        default:<span class="cov0" title="0">
                err = fmt.Errorf("ent: Strings returned %d results when one was expected", len(v))</span>
        }
        <span class="cov0" title="0">return</span>
}

// StringX is like String, but panics if an error occurs.
func (s *selector) StringX(ctx context.Context) string <span class="cov0" title="0">{
        v, err := s.String(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return v</span>
}

// Ints returns list of ints from a selector. It is only allowed when selecting one field.
func (s *selector) Ints(ctx context.Context) ([]int, error) <span class="cov0" title="0">{
        if len(*s.flds) &gt; 1 </span><span class="cov0" title="0">{
                return nil, errors.New("ent: Ints is not achievable when selecting more than 1 field")
        }</span>
        <span class="cov0" title="0">var v []int
        if err := s.scan(ctx, &amp;v); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return v, nil</span>
}

// IntsX is like Ints, but panics if an error occurs.
func (s *selector) IntsX(ctx context.Context) []int <span class="cov0" title="0">{
        v, err := s.Ints(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return v</span>
}

// Int returns a single int from a selector. It is only allowed when selecting one field.
func (s *selector) Int(ctx context.Context) (_ int, err error) <span class="cov0" title="0">{
        var v []int
        if v, err = s.Ints(ctx); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">switch len(v) </span>{
        case 1:<span class="cov0" title="0">
                return v[0], nil</span>
        case 0:<span class="cov0" title="0">
                err = &amp;NotFoundError{s.label}</span>
        default:<span class="cov0" title="0">
                err = fmt.Errorf("ent: Ints returned %d results when one was expected", len(v))</span>
        }
        <span class="cov0" title="0">return</span>
}

// IntX is like Int, but panics if an error occurs.
func (s *selector) IntX(ctx context.Context) int <span class="cov0" title="0">{
        v, err := s.Int(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return v</span>
}

// Float64s returns list of float64s from a selector. It is only allowed when selecting one field.
func (s *selector) Float64s(ctx context.Context) ([]float64, error) <span class="cov0" title="0">{
        if len(*s.flds) &gt; 1 </span><span class="cov0" title="0">{
                return nil, errors.New("ent: Float64s is not achievable when selecting more than 1 field")
        }</span>
        <span class="cov0" title="0">var v []float64
        if err := s.scan(ctx, &amp;v); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return v, nil</span>
}

// Float64sX is like Float64s, but panics if an error occurs.
func (s *selector) Float64sX(ctx context.Context) []float64 <span class="cov0" title="0">{
        v, err := s.Float64s(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return v</span>
}

// Float64 returns a single float64 from a selector. It is only allowed when selecting one field.
func (s *selector) Float64(ctx context.Context) (_ float64, err error) <span class="cov0" title="0">{
        var v []float64
        if v, err = s.Float64s(ctx); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">switch len(v) </span>{
        case 1:<span class="cov0" title="0">
                return v[0], nil</span>
        case 0:<span class="cov0" title="0">
                err = &amp;NotFoundError{s.label}</span>
        default:<span class="cov0" title="0">
                err = fmt.Errorf("ent: Float64s returned %d results when one was expected", len(v))</span>
        }
        <span class="cov0" title="0">return</span>
}

// Float64X is like Float64, but panics if an error occurs.
func (s *selector) Float64X(ctx context.Context) float64 <span class="cov0" title="0">{
        v, err := s.Float64(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return v</span>
}

// Bools returns list of bools from a selector. It is only allowed when selecting one field.
func (s *selector) Bools(ctx context.Context) ([]bool, error) <span class="cov0" title="0">{
        if len(*s.flds) &gt; 1 </span><span class="cov0" title="0">{
                return nil, errors.New("ent: Bools is not achievable when selecting more than 1 field")
        }</span>
        <span class="cov0" title="0">var v []bool
        if err := s.scan(ctx, &amp;v); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return v, nil</span>
}

// BoolsX is like Bools, but panics if an error occurs.
func (s *selector) BoolsX(ctx context.Context) []bool <span class="cov0" title="0">{
        v, err := s.Bools(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return v</span>
}

// Bool returns a single bool from a selector. It is only allowed when selecting one field.
func (s *selector) Bool(ctx context.Context) (_ bool, err error) <span class="cov0" title="0">{
        var v []bool
        if v, err = s.Bools(ctx); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">switch len(v) </span>{
        case 1:<span class="cov0" title="0">
                return v[0], nil</span>
        case 0:<span class="cov0" title="0">
                err = &amp;NotFoundError{s.label}</span>
        default:<span class="cov0" title="0">
                err = fmt.Errorf("ent: Bools returned %d results when one was expected", len(v))</span>
        }
        <span class="cov0" title="0">return</span>
}

// BoolX is like Bool, but panics if an error occurs.
func (s *selector) BoolX(ctx context.Context) bool <span class="cov0" title="0">{
        v, err := s.Bool(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return v</span>
}

// withHooks invokes the builder operation with the given hooks, if any.
func withHooks[V Value, M any, PM interface {
        *M
        Mutation
}](ctx context.Context, exec func(context.Context) (V, error), mutation PM, hooks []Hook) (value V, err error) <span class="cov0" title="0">{
        if len(hooks) == 0 </span><span class="cov0" title="0">{
                return exec(ctx)
        }</span>
        <span class="cov0" title="0">var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) </span><span class="cov0" title="0">{
                mutationT, ok := any(m).(PM)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected mutation type %T", m)
                }</span>
                // Set the mutation to the builder.
                <span class="cov0" title="0">*mutation = *mutationT
                return exec(ctx)</span>
        })
        <span class="cov0" title="0">for i := len(hooks) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                if hooks[i] == nil </span><span class="cov0" title="0">{
                        return value, fmt.Errorf("ent: uninitialized hook (forgotten import ent/runtime?)")
                }</span>
                <span class="cov0" title="0">mut = hooks[i](mut)</span>
        }
        <span class="cov0" title="0">v, err := mut.Mutate(ctx, mutation)
        if err != nil </span><span class="cov0" title="0">{
                return value, err
        }</span>
        <span class="cov0" title="0">nv, ok := v.(V)
        if !ok </span><span class="cov0" title="0">{
                return value, fmt.Errorf("unexpected node type %T returned from %T", v, mutation)
        }</span>
        <span class="cov0" title="0">return nv, nil</span>
}

// setContextOp returns a new context with the given QueryContext attached (including its op) in case it does not exist.
func setContextOp(ctx context.Context, qc *QueryContext, op string) context.Context <span class="cov0" title="0">{
        if ent.QueryFromContext(ctx) == nil </span><span class="cov0" title="0">{
                qc.Op = op
                ctx = ent.NewQueryContext(ctx, qc)
        }</span>
        <span class="cov0" title="0">return ctx</span>
}

func querierAll[V Value, Q interface {
        sqlAll(context.Context, ...queryHook) (V, error)
}]() Querier <span class="cov0" title="0">{
        return QuerierFunc(func(ctx context.Context, q Query) (Value, error) </span><span class="cov0" title="0">{
                query, ok := q.(Q)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected query type %T", q)
                }</span>
                <span class="cov0" title="0">return query.sqlAll(ctx)</span>
        })
}

func querierCount[Q interface {
        sqlCount(context.Context) (int, error)
}]() Querier <span class="cov0" title="0">{
        return QuerierFunc(func(ctx context.Context, q Query) (Value, error) </span><span class="cov0" title="0">{
                query, ok := q.(Q)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected query type %T", q)
                }</span>
                <span class="cov0" title="0">return query.sqlCount(ctx)</span>
        })
}

func withInterceptors[V Value](ctx context.Context, q Query, qr Querier, inters []Interceptor) (v V, err error) <span class="cov0" title="0">{
        for i := len(inters) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                qr = inters[i].Intercept(qr)
        }</span>
        <span class="cov0" title="0">rv, err := qr.Query(ctx, q)
        if err != nil </span><span class="cov0" title="0">{
                return v, err
        }</span>
        <span class="cov0" title="0">vt, ok := rv.(V)
        if !ok </span><span class="cov0" title="0">{
                return v, fmt.Errorf("unexpected type %T returned from %T. expected type: %T", vt, q, v)
        }</span>
        <span class="cov0" title="0">return vt, nil</span>
}

func scanWithInterceptors[Q1 ent.Query, Q2 interface {
        sqlScan(context.Context, Q1, any) error
}](ctx context.Context, rootQuery Q1, selectOrGroup Q2, inters []Interceptor, v any) error <span class="cov0" title="0">{
        rv := reflect.ValueOf(v)
        var qr Querier = QuerierFunc(func(ctx context.Context, q Query) (Value, error) </span><span class="cov0" title="0">{
                query, ok := q.(Q1)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected query type %T", q)
                }</span>
                <span class="cov0" title="0">if err := selectOrGroup.sqlScan(ctx, query, v); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if k := rv.Kind(); k == reflect.Pointer &amp;&amp; rv.Elem().CanInterface() </span><span class="cov0" title="0">{
                        return rv.Elem().Interface(), nil
                }</span>
                <span class="cov0" title="0">return v, nil</span>
        })
        <span class="cov0" title="0">for i := len(inters) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                qr = inters[i].Intercept(qr)
        }</span>
        <span class="cov0" title="0">vv, err := qr.Query(ctx, rootQuery)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">switch rv2 := reflect.ValueOf(vv); </span>{
        case rv.IsNil(), rv2.IsNil(), rv.Kind() != reflect.Pointer:<span class="cov0" title="0"></span>
        case rv.Type() == rv2.Type():<span class="cov0" title="0">
                rv.Elem().Set(rv2.Elem())</span>
        case rv.Elem().Type() == rv2.Type():<span class="cov0" title="0">
                rv.Elem().Set(rv2)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// queryHook describes an internal hook for the different sqlAll methods.
type queryHook func(context.Context, *sqlgraph.QuerySpec)
</pre>
		
		<pre class="file" id="file5" style="display: none">// Code generated by ent, DO NOT EDIT.

package enttest

import (
        "context"

        "github.com/ivankorhner/polling-app/internal/ent"
        // required by schema hooks.
        _ "github.com/ivankorhner/polling-app/internal/ent/runtime"

        "entgo.io/ent/dialect/sql/schema"
        "github.com/ivankorhner/polling-app/internal/ent/migrate"
)

type (
        // TestingT is the interface that is shared between
        // testing.T and testing.B and used by enttest.
        TestingT interface {
                FailNow()
                Error(...any)
        }

        // Option configures client creation.
        Option func(*options)

        options struct {
                opts        []ent.Option
                migrateOpts []schema.MigrateOption
        }
)

// WithOptions forwards options to client creation.
func WithOptions(opts ...ent.Option) Option <span class="cov0" title="0">{
        return func(o *options) </span><span class="cov0" title="0">{
                o.opts = append(o.opts, opts...)
        }</span>
}

// WithMigrateOptions forwards options to auto migration.
func WithMigrateOptions(opts ...schema.MigrateOption) Option <span class="cov0" title="0">{
        return func(o *options) </span><span class="cov0" title="0">{
                o.migrateOpts = append(o.migrateOpts, opts...)
        }</span>
}

func newOptions(opts []Option) *options <span class="cov0" title="0">{
        o := &amp;options{}
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(o)
        }</span>
        <span class="cov0" title="0">return o</span>
}

// Open calls ent.Open and auto-run migration.
func Open(t TestingT, driverName, dataSourceName string, opts ...Option) *ent.Client <span class="cov0" title="0">{
        o := newOptions(opts)
        c, err := ent.Open(driverName, dataSourceName, o.opts...)
        if err != nil </span><span class="cov0" title="0">{
                t.Error(err)
                t.FailNow()
        }</span>
        <span class="cov0" title="0">migrateSchema(t, c, o)
        return c</span>
}

// NewClient calls ent.NewClient and auto-run migration.
func NewClient(t TestingT, opts ...Option) *ent.Client <span class="cov0" title="0">{
        o := newOptions(opts)
        c := ent.NewClient(o.opts...)
        migrateSchema(t, c, o)
        return c
}</span>
func migrateSchema(t TestingT, c *ent.Client, o *options) <span class="cov0" title="0">{
        tables, err := schema.CopyTables(migrate.Tables)
        if err != nil </span><span class="cov0" title="0">{
                t.Error(err)
                t.FailNow()
        }</span>
        <span class="cov0" title="0">if err := migrate.Create(context.Background(), c.Schema, tables, o.migrateOpts...); err != nil </span><span class="cov0" title="0">{
                t.Error(err)
                t.FailNow()
        }</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Code generated by ent, DO NOT EDIT.

package hook

import (
        "context"
        "fmt"

        "github.com/ivankorhner/polling-app/internal/ent"
)

// The PollFunc type is an adapter to allow the use of ordinary
// function as Poll mutator.
type PollFunc func(context.Context, *ent.PollMutation) (ent.Value, error)

// Mutate calls f(ctx, m).
func (f PollFunc) Mutate(ctx context.Context, m ent.Mutation) (ent.Value, error) <span class="cov0" title="0">{
        if mv, ok := m.(*ent.PollMutation); ok </span><span class="cov0" title="0">{
                return f(ctx, mv)
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected mutation type %T. expect *ent.PollMutation", m)</span>
}

// The PollOptionFunc type is an adapter to allow the use of ordinary
// function as PollOption mutator.
type PollOptionFunc func(context.Context, *ent.PollOptionMutation) (ent.Value, error)

// Mutate calls f(ctx, m).
func (f PollOptionFunc) Mutate(ctx context.Context, m ent.Mutation) (ent.Value, error) <span class="cov0" title="0">{
        if mv, ok := m.(*ent.PollOptionMutation); ok </span><span class="cov0" title="0">{
                return f(ctx, mv)
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected mutation type %T. expect *ent.PollOptionMutation", m)</span>
}

// The UserFunc type is an adapter to allow the use of ordinary
// function as User mutator.
type UserFunc func(context.Context, *ent.UserMutation) (ent.Value, error)

// Mutate calls f(ctx, m).
func (f UserFunc) Mutate(ctx context.Context, m ent.Mutation) (ent.Value, error) <span class="cov0" title="0">{
        if mv, ok := m.(*ent.UserMutation); ok </span><span class="cov0" title="0">{
                return f(ctx, mv)
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected mutation type %T. expect *ent.UserMutation", m)</span>
}

// The VoteFunc type is an adapter to allow the use of ordinary
// function as Vote mutator.
type VoteFunc func(context.Context, *ent.VoteMutation) (ent.Value, error)

// Mutate calls f(ctx, m).
func (f VoteFunc) Mutate(ctx context.Context, m ent.Mutation) (ent.Value, error) <span class="cov0" title="0">{
        if mv, ok := m.(*ent.VoteMutation); ok </span><span class="cov0" title="0">{
                return f(ctx, mv)
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected mutation type %T. expect *ent.VoteMutation", m)</span>
}

// Condition is a hook condition function.
type Condition func(context.Context, ent.Mutation) bool

// And groups conditions with the AND operator.
func And(first, second Condition, rest ...Condition) Condition <span class="cov0" title="0">{
        return func(ctx context.Context, m ent.Mutation) bool </span><span class="cov0" title="0">{
                if !first(ctx, m) || !second(ctx, m) </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">for _, cond := range rest </span><span class="cov0" title="0">{
                        if !cond(ctx, m) </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
                <span class="cov0" title="0">return true</span>
        }
}

// Or groups conditions with the OR operator.
func Or(first, second Condition, rest ...Condition) Condition <span class="cov0" title="0">{
        return func(ctx context.Context, m ent.Mutation) bool </span><span class="cov0" title="0">{
                if first(ctx, m) || second(ctx, m) </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">for _, cond := range rest </span><span class="cov0" title="0">{
                        if cond(ctx, m) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
                <span class="cov0" title="0">return false</span>
        }
}

// Not negates a given condition.
func Not(cond Condition) Condition <span class="cov0" title="0">{
        return func(ctx context.Context, m ent.Mutation) bool </span><span class="cov0" title="0">{
                return !cond(ctx, m)
        }</span>
}

// HasOp is a condition testing mutation operation.
func HasOp(op ent.Op) Condition <span class="cov0" title="0">{
        return func(_ context.Context, m ent.Mutation) bool </span><span class="cov0" title="0">{
                return m.Op().Is(op)
        }</span>
}

// HasAddedFields is a condition validating `.AddedField` on fields.
func HasAddedFields(field string, fields ...string) Condition <span class="cov0" title="0">{
        return func(_ context.Context, m ent.Mutation) bool </span><span class="cov0" title="0">{
                if _, exists := m.AddedField(field); !exists </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">for _, field := range fields </span><span class="cov0" title="0">{
                        if _, exists := m.AddedField(field); !exists </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
                <span class="cov0" title="0">return true</span>
        }
}

// HasClearedFields is a condition validating `.FieldCleared` on fields.
func HasClearedFields(field string, fields ...string) Condition <span class="cov0" title="0">{
        return func(_ context.Context, m ent.Mutation) bool </span><span class="cov0" title="0">{
                if exists := m.FieldCleared(field); !exists </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">for _, field := range fields </span><span class="cov0" title="0">{
                        if exists := m.FieldCleared(field); !exists </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
                <span class="cov0" title="0">return true</span>
        }
}

// HasFields is a condition validating `.Field` on fields.
func HasFields(field string, fields ...string) Condition <span class="cov0" title="0">{
        return func(_ context.Context, m ent.Mutation) bool </span><span class="cov0" title="0">{
                if _, exists := m.Field(field); !exists </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">for _, field := range fields </span><span class="cov0" title="0">{
                        if _, exists := m.Field(field); !exists </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
                <span class="cov0" title="0">return true</span>
        }
}

// If executes the given hook under condition.
//
//        hook.If(ComputeAverage, And(HasFields(...), HasAddedFields(...)))
func If(hk ent.Hook, cond Condition) ent.Hook <span class="cov0" title="0">{
        return func(next ent.Mutator) ent.Mutator </span><span class="cov0" title="0">{
                return ent.MutateFunc(func(ctx context.Context, m ent.Mutation) (ent.Value, error) </span><span class="cov0" title="0">{
                        if cond(ctx, m) </span><span class="cov0" title="0">{
                                return hk(next).Mutate(ctx, m)
                        }</span>
                        <span class="cov0" title="0">return next.Mutate(ctx, m)</span>
                })
        }
}

// On executes the given hook only for the given operation.
//
//        hook.On(Log, ent.Delete|ent.Create)
func On(hk ent.Hook, op ent.Op) ent.Hook <span class="cov0" title="0">{
        return If(hk, HasOp(op))
}</span>

// Unless skips the given hook only for the given operation.
//
//        hook.Unless(Log, ent.Update|ent.UpdateOne)
func Unless(hk ent.Hook, op ent.Op) ent.Hook <span class="cov0" title="0">{
        return If(hk, Not(HasOp(op)))
}</span>

// FixedError is a hook returning a fixed error.
func FixedError(err error) ent.Hook <span class="cov0" title="0">{
        return func(ent.Mutator) ent.Mutator </span><span class="cov0" title="0">{
                return ent.MutateFunc(func(context.Context, ent.Mutation) (ent.Value, error) </span><span class="cov0" title="0">{
                        return nil, err
                }</span>)
        }
}

// Reject returns a hook that rejects all operations that match op.
//
//        func (T) Hooks() []ent.Hook {
//                return []ent.Hook{
//                        Reject(ent.Delete|ent.Update),
//                }
//        }
func Reject(op ent.Op) ent.Hook <span class="cov0" title="0">{
        hk := FixedError(fmt.Errorf("%s operation is not allowed", op))
        return On(hk, op)
}</span>

// Chain acts as a list of hooks and is effectively immutable.
// Once created, it will always hold the same set of hooks in the same order.
type Chain struct {
        hooks []ent.Hook
}

// NewChain creates a new chain of hooks.
func NewChain(hooks ...ent.Hook) Chain <span class="cov0" title="0">{
        return Chain{append([]ent.Hook(nil), hooks...)}
}</span>

// Hook chains the list of hooks and returns the final hook.
func (c Chain) Hook() ent.Hook <span class="cov0" title="0">{
        return func(mutator ent.Mutator) ent.Mutator </span><span class="cov0" title="0">{
                for i := len(c.hooks) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                        mutator = c.hooks[i](mutator)
                }</span>
                <span class="cov0" title="0">return mutator</span>
        }
}

// Append extends a chain, adding the specified hook
// as the last ones in the mutation flow.
func (c Chain) Append(hooks ...ent.Hook) Chain <span class="cov0" title="0">{
        newHooks := make([]ent.Hook, 0, len(c.hooks)+len(hooks))
        newHooks = append(newHooks, c.hooks...)
        newHooks = append(newHooks, hooks...)
        return Chain{newHooks}
}</span>

// Extend extends a chain, adding the specified chain
// as the last ones in the mutation flow.
func (c Chain) Extend(chain Chain) Chain <span class="cov0" title="0">{
        return c.Append(chain.hooks...)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">// Code generated by ent, DO NOT EDIT.

package migrate

import (
        "context"
        "fmt"
        "io"

        "entgo.io/ent/dialect"
        "entgo.io/ent/dialect/sql/schema"
)

var (
        // WithGlobalUniqueID sets the universal ids options to the migration.
        // If this option is enabled, ent migration will allocate a 1&lt;&lt;32 range
        // for the ids of each entity (table).
        // Note that this option cannot be applied on tables that already exist.
        WithGlobalUniqueID = schema.WithGlobalUniqueID
        // WithDropColumn sets the drop column option to the migration.
        // If this option is enabled, ent migration will drop old columns
        // that were used for both fields and edges. This defaults to false.
        WithDropColumn = schema.WithDropColumn
        // WithDropIndex sets the drop index option to the migration.
        // If this option is enabled, ent migration will drop old indexes
        // that were defined in the schema. This defaults to false.
        // Note that unique constraints are defined using `UNIQUE INDEX`,
        // and therefore, it's recommended to enable this option to get more
        // flexibility in the schema changes.
        WithDropIndex = schema.WithDropIndex
        // WithForeignKeys enables creating foreign-key in schema DDL. This defaults to true.
        WithForeignKeys = schema.WithForeignKeys
)

// Schema is the API for creating, migrating and dropping a schema.
type Schema struct {
        drv dialect.Driver
}

// NewSchema creates a new schema client.
func NewSchema(drv dialect.Driver) *Schema <span class="cov0" title="0">{ return &amp;Schema{drv: drv} }</span>

// Create creates all schema resources.
func (s *Schema) Create(ctx context.Context, opts ...schema.MigrateOption) error <span class="cov0" title="0">{
        return Create(ctx, s, Tables, opts...)
}</span>

// Create creates all table resources using the given schema driver.
func Create(ctx context.Context, s *Schema, tables []*schema.Table, opts ...schema.MigrateOption) error <span class="cov0" title="0">{
        migrate, err := schema.NewMigrate(s.drv, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ent/migrate: %w", err)
        }</span>
        <span class="cov0" title="0">return migrate.Create(ctx, tables...)</span>
}

// WriteTo writes the schema changes to w instead of running them against the database.
//
//        if err := client.Schema.WriteTo(context.Background(), os.Stdout); err != nil {
//                log.Fatal(err)
//        }
func (s *Schema) WriteTo(ctx context.Context, w io.Writer, opts ...schema.MigrateOption) error <span class="cov0" title="0">{
        return Create(ctx, &amp;Schema{drv: &amp;schema.WriteDriver{Writer: w, Driver: s.drv}}, Tables, opts...)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">// Code generated by ent, DO NOT EDIT.

package migrate

import (
        "entgo.io/ent/dialect/sql/schema"
        "entgo.io/ent/schema/field"
)

var (
        // PollsColumns holds the columns for the "polls" table.
        PollsColumns = []*schema.Column{
                {Name: "id", Type: field.TypeInt, Increment: true},
                {Name: "title", Type: field.TypeString},
                {Name: "created_at", Type: field.TypeTime},
                {Name: "owner_id", Type: field.TypeInt},
        }
        // PollsTable holds the schema information for the "polls" table.
        PollsTable = &amp;schema.Table{
                Name:       "polls",
                Columns:    PollsColumns,
                PrimaryKey: []*schema.Column{PollsColumns[0]},
                ForeignKeys: []*schema.ForeignKey{
                        {
                                Symbol:     "polls_users_polls",
                                Columns:    []*schema.Column{PollsColumns[3]},
                                RefColumns: []*schema.Column{UsersColumns[0]},
                                OnDelete:   schema.NoAction,
                        },
                },
        }
        // PollOptionsColumns holds the columns for the "poll_options" table.
        PollOptionsColumns = []*schema.Column{
                {Name: "id", Type: field.TypeInt, Increment: true},
                {Name: "text", Type: field.TypeString},
                {Name: "created_at", Type: field.TypeTime},
                {Name: "poll_id", Type: field.TypeInt},
        }
        // PollOptionsTable holds the schema information for the "poll_options" table.
        PollOptionsTable = &amp;schema.Table{
                Name:       "poll_options",
                Columns:    PollOptionsColumns,
                PrimaryKey: []*schema.Column{PollOptionsColumns[0]},
                ForeignKeys: []*schema.ForeignKey{
                        {
                                Symbol:     "poll_options_polls_options",
                                Columns:    []*schema.Column{PollOptionsColumns[3]},
                                RefColumns: []*schema.Column{PollsColumns[0]},
                                OnDelete:   schema.Cascade,
                        },
                },
        }
        // UsersColumns holds the columns for the "users" table.
        UsersColumns = []*schema.Column{
                {Name: "id", Type: field.TypeInt, Increment: true},
                {Name: "username", Type: field.TypeString, Unique: true},
                {Name: "email", Type: field.TypeString, Unique: true},
                {Name: "created_at", Type: field.TypeTime},
        }
        // UsersTable holds the schema information for the "users" table.
        UsersTable = &amp;schema.Table{
                Name:       "users",
                Columns:    UsersColumns,
                PrimaryKey: []*schema.Column{UsersColumns[0]},
        }
        // VotesColumns holds the columns for the "votes" table.
        VotesColumns = []*schema.Column{
                {Name: "id", Type: field.TypeInt, Increment: true},
                {Name: "created_at", Type: field.TypeTime},
                {Name: "poll_id", Type: field.TypeInt},
                {Name: "option_id", Type: field.TypeInt},
                {Name: "user_id", Type: field.TypeInt},
        }
        // VotesTable holds the schema information for the "votes" table.
        VotesTable = &amp;schema.Table{
                Name:       "votes",
                Columns:    VotesColumns,
                PrimaryKey: []*schema.Column{VotesColumns[0]},
                ForeignKeys: []*schema.ForeignKey{
                        {
                                Symbol:     "votes_polls_votes",
                                Columns:    []*schema.Column{VotesColumns[2]},
                                RefColumns: []*schema.Column{PollsColumns[0]},
                                OnDelete:   schema.Cascade,
                        },
                        {
                                Symbol:     "votes_poll_options_votes",
                                Columns:    []*schema.Column{VotesColumns[3]},
                                RefColumns: []*schema.Column{PollOptionsColumns[0]},
                                OnDelete:   schema.NoAction,
                        },
                        {
                                Symbol:     "votes_users_votes",
                                Columns:    []*schema.Column{VotesColumns[4]},
                                RefColumns: []*schema.Column{UsersColumns[0]},
                                OnDelete:   schema.NoAction,
                        },
                },
                Indexes: []*schema.Index{
                        {
                                Name:    "vote_user_id_poll_id",
                                Unique:  true,
                                Columns: []*schema.Column{VotesColumns[4], VotesColumns[2]},
                        },
                },
        }
        // Tables holds all the tables in the schema.
        Tables = []*schema.Table{
                PollsTable,
                PollOptionsTable,
                UsersTable,
                VotesTable,
        }
)

func init() <span class="cov0" title="0">{
        PollsTable.ForeignKeys[0].RefTable = UsersTable
        PollOptionsTable.ForeignKeys[0].RefTable = PollsTable
        VotesTable.ForeignKeys[0].RefTable = PollsTable
        VotesTable.ForeignKeys[1].RefTable = PollOptionsTable
        VotesTable.ForeignKeys[2].RefTable = UsersTable
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "context"
        "errors"
        "fmt"
        "sync"
        "time"

        "entgo.io/ent"
        "entgo.io/ent/dialect/sql"
        "github.com/ivankorhner/polling-app/internal/ent/poll"
        "github.com/ivankorhner/polling-app/internal/ent/polloption"
        "github.com/ivankorhner/polling-app/internal/ent/predicate"
        "github.com/ivankorhner/polling-app/internal/ent/user"
        "github.com/ivankorhner/polling-app/internal/ent/vote"
)

const (
        // Operation types.
        OpCreate    = ent.OpCreate
        OpDelete    = ent.OpDelete
        OpDeleteOne = ent.OpDeleteOne
        OpUpdate    = ent.OpUpdate
        OpUpdateOne = ent.OpUpdateOne

        // Node types.
        TypePoll       = "Poll"
        TypePollOption = "PollOption"
        TypeUser       = "User"
        TypeVote       = "Vote"
)

// PollMutation represents an operation that mutates the Poll nodes in the graph.
type PollMutation struct {
        config
        op             Op
        typ            string
        id             *int
        title          *string
        created_at     *time.Time
        clearedFields  map[string]struct{}
        owner          *int
        clearedowner   bool
        options        map[int]struct{}
        removedoptions map[int]struct{}
        clearedoptions bool
        votes          map[int]struct{}
        removedvotes   map[int]struct{}
        clearedvotes   bool
        done           bool
        oldValue       func(context.Context) (*Poll, error)
        predicates     []predicate.Poll
}

var _ ent.Mutation = (*PollMutation)(nil)

// pollOption allows management of the mutation configuration using functional options.
type pollOption func(*PollMutation)

// newPollMutation creates new mutation for the Poll entity.
func newPollMutation(c config, op Op, opts ...pollOption) *PollMutation <span class="cov0" title="0">{
        m := &amp;PollMutation{
                config:        c,
                op:            op,
                typ:           TypePoll,
                clearedFields: make(map[string]struct{}),
        }
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(m)
        }</span>
        <span class="cov0" title="0">return m</span>
}

// withPollID sets the ID field of the mutation.
func withPollID(id int) pollOption <span class="cov0" title="0">{
        return func(m *PollMutation) </span><span class="cov0" title="0">{
                var (
                        err   error
                        once  sync.Once
                        value *Poll
                )
                m.oldValue = func(ctx context.Context) (*Poll, error) </span><span class="cov0" title="0">{
                        once.Do(func() </span><span class="cov0" title="0">{
                                if m.done </span><span class="cov0" title="0">{
                                        err = errors.New("querying old values post mutation is not allowed")
                                }</span> else<span class="cov0" title="0"> {
                                        value, err = m.Client().Poll.Get(ctx, id)
                                }</span>
                        })
                        <span class="cov0" title="0">return value, err</span>
                }
                <span class="cov0" title="0">m.id = &amp;id</span>
        }
}

// withPoll sets the old Poll of the mutation.
func withPoll(node *Poll) pollOption <span class="cov0" title="0">{
        return func(m *PollMutation) </span><span class="cov0" title="0">{
                m.oldValue = func(context.Context) (*Poll, error) </span><span class="cov0" title="0">{
                        return node, nil
                }</span>
                <span class="cov0" title="0">m.id = &amp;node.ID</span>
        }
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PollMutation) Client() *Client <span class="cov0" title="0">{
        client := &amp;Client{config: m.config}
        client.init()
        return client
}</span>

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PollMutation) Tx() (*Tx, error) <span class="cov0" title="0">{
        if _, ok := m.driver.(*txDriver); !ok </span><span class="cov0" title="0">{
                return nil, errors.New("ent: mutation is not running in a transaction")
        }</span>
        <span class="cov0" title="0">tx := &amp;Tx{config: m.config}
        tx.init()
        return tx, nil</span>
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Poll entities.
func (m *PollMutation) SetID(id int) <span class="cov0" title="0">{
        m.id = &amp;id
}</span>

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PollMutation) ID() (id int, exists bool) <span class="cov0" title="0">{
        if m.id == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *m.id, true</span>
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PollMutation) IDs(ctx context.Context) ([]int, error) <span class="cov0" title="0">{
        switch </span>{
        case m.op.Is(OpUpdateOne | OpDeleteOne):<span class="cov0" title="0">
                id, exists := m.ID()
                if exists </span><span class="cov0" title="0">{
                        return []int{id}, nil
                }</span>
                <span class="cov0" title="0">fallthrough</span>
        case m.op.Is(OpUpdate | OpDelete):<span class="cov0" title="0">
                return m.Client().Poll.Query().Where(m.predicates...).IDs(ctx)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)</span>
        }
}

// SetOwnerID sets the "owner_id" field.
func (m *PollMutation) SetOwnerID(i int) <span class="cov0" title="0">{
        m.owner = &amp;i
}</span>

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *PollMutation) OwnerID() (r int, exists bool) <span class="cov0" title="0">{
        v := m.owner
        if v == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *v, true</span>
}

// OldOwnerID returns the old "owner_id" field's value of the Poll entity.
// If the Poll object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PollMutation) OldOwnerID(ctx context.Context) (v int, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldOwnerID requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.OwnerID, nil</span>
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *PollMutation) ResetOwnerID() <span class="cov0" title="0">{
        m.owner = nil
}</span>

// SetTitle sets the "title" field.
func (m *PollMutation) SetTitle(s string) <span class="cov0" title="0">{
        m.title = &amp;s
}</span>

// Title returns the value of the "title" field in the mutation.
func (m *PollMutation) Title() (r string, exists bool) <span class="cov0" title="0">{
        v := m.title
        if v == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *v, true</span>
}

// OldTitle returns the old "title" field's value of the Poll entity.
// If the Poll object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PollMutation) OldTitle(ctx context.Context) (v string, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldTitle is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldTitle requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldTitle: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.Title, nil</span>
}

// ResetTitle resets all changes to the "title" field.
func (m *PollMutation) ResetTitle() <span class="cov0" title="0">{
        m.title = nil
}</span>

// SetCreatedAt sets the "created_at" field.
func (m *PollMutation) SetCreatedAt(t time.Time) <span class="cov0" title="0">{
        m.created_at = &amp;t
}</span>

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PollMutation) CreatedAt() (r time.Time, exists bool) <span class="cov0" title="0">{
        v := m.created_at
        if v == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *v, true</span>
}

// OldCreatedAt returns the old "created_at" field's value of the Poll entity.
// If the Poll object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PollMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldCreatedAt requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.CreatedAt, nil</span>
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PollMutation) ResetCreatedAt() <span class="cov0" title="0">{
        m.created_at = nil
}</span>

// ClearOwner clears the "owner" edge to the User entity.
func (m *PollMutation) ClearOwner() <span class="cov0" title="0">{
        m.clearedowner = true
        m.clearedFields[poll.FieldOwnerID] = struct{}{}
}</span>

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *PollMutation) OwnerCleared() bool <span class="cov0" title="0">{
        return m.clearedowner
}</span>

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) &lt;= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *PollMutation) OwnerIDs() (ids []int) <span class="cov0" title="0">{
        if id := m.owner; id != nil </span><span class="cov0" title="0">{
                ids = append(ids, *id)
        }</span>
        <span class="cov0" title="0">return</span>
}

// ResetOwner resets all changes to the "owner" edge.
func (m *PollMutation) ResetOwner() <span class="cov0" title="0">{
        m.owner = nil
        m.clearedowner = false
}</span>

// AddOptionIDs adds the "options" edge to the PollOption entity by ids.
func (m *PollMutation) AddOptionIDs(ids ...int) <span class="cov0" title="0">{
        if m.options == nil </span><span class="cov0" title="0">{
                m.options = make(map[int]struct{})
        }</span>
        <span class="cov0" title="0">for i := range ids </span><span class="cov0" title="0">{
                m.options[ids[i]] = struct{}{}
        }</span>
}

// ClearOptions clears the "options" edge to the PollOption entity.
func (m *PollMutation) ClearOptions() <span class="cov0" title="0">{
        m.clearedoptions = true
}</span>

// OptionsCleared reports if the "options" edge to the PollOption entity was cleared.
func (m *PollMutation) OptionsCleared() bool <span class="cov0" title="0">{
        return m.clearedoptions
}</span>

// RemoveOptionIDs removes the "options" edge to the PollOption entity by IDs.
func (m *PollMutation) RemoveOptionIDs(ids ...int) <span class="cov0" title="0">{
        if m.removedoptions == nil </span><span class="cov0" title="0">{
                m.removedoptions = make(map[int]struct{})
        }</span>
        <span class="cov0" title="0">for i := range ids </span><span class="cov0" title="0">{
                delete(m.options, ids[i])
                m.removedoptions[ids[i]] = struct{}{}
        }</span>
}

// RemovedOptions returns the removed IDs of the "options" edge to the PollOption entity.
func (m *PollMutation) RemovedOptionsIDs() (ids []int) <span class="cov0" title="0">{
        for id := range m.removedoptions </span><span class="cov0" title="0">{
                ids = append(ids, id)
        }</span>
        <span class="cov0" title="0">return</span>
}

// OptionsIDs returns the "options" edge IDs in the mutation.
func (m *PollMutation) OptionsIDs() (ids []int) <span class="cov0" title="0">{
        for id := range m.options </span><span class="cov0" title="0">{
                ids = append(ids, id)
        }</span>
        <span class="cov0" title="0">return</span>
}

// ResetOptions resets all changes to the "options" edge.
func (m *PollMutation) ResetOptions() <span class="cov0" title="0">{
        m.options = nil
        m.clearedoptions = false
        m.removedoptions = nil
}</span>

// AddVoteIDs adds the "votes" edge to the Vote entity by ids.
func (m *PollMutation) AddVoteIDs(ids ...int) <span class="cov0" title="0">{
        if m.votes == nil </span><span class="cov0" title="0">{
                m.votes = make(map[int]struct{})
        }</span>
        <span class="cov0" title="0">for i := range ids </span><span class="cov0" title="0">{
                m.votes[ids[i]] = struct{}{}
        }</span>
}

// ClearVotes clears the "votes" edge to the Vote entity.
func (m *PollMutation) ClearVotes() <span class="cov0" title="0">{
        m.clearedvotes = true
}</span>

// VotesCleared reports if the "votes" edge to the Vote entity was cleared.
func (m *PollMutation) VotesCleared() bool <span class="cov0" title="0">{
        return m.clearedvotes
}</span>

// RemoveVoteIDs removes the "votes" edge to the Vote entity by IDs.
func (m *PollMutation) RemoveVoteIDs(ids ...int) <span class="cov0" title="0">{
        if m.removedvotes == nil </span><span class="cov0" title="0">{
                m.removedvotes = make(map[int]struct{})
        }</span>
        <span class="cov0" title="0">for i := range ids </span><span class="cov0" title="0">{
                delete(m.votes, ids[i])
                m.removedvotes[ids[i]] = struct{}{}
        }</span>
}

// RemovedVotes returns the removed IDs of the "votes" edge to the Vote entity.
func (m *PollMutation) RemovedVotesIDs() (ids []int) <span class="cov0" title="0">{
        for id := range m.removedvotes </span><span class="cov0" title="0">{
                ids = append(ids, id)
        }</span>
        <span class="cov0" title="0">return</span>
}

// VotesIDs returns the "votes" edge IDs in the mutation.
func (m *PollMutation) VotesIDs() (ids []int) <span class="cov0" title="0">{
        for id := range m.votes </span><span class="cov0" title="0">{
                ids = append(ids, id)
        }</span>
        <span class="cov0" title="0">return</span>
}

// ResetVotes resets all changes to the "votes" edge.
func (m *PollMutation) ResetVotes() <span class="cov0" title="0">{
        m.votes = nil
        m.clearedvotes = false
        m.removedvotes = nil
}</span>

// Where appends a list predicates to the PollMutation builder.
func (m *PollMutation) Where(ps ...predicate.Poll) <span class="cov0" title="0">{
        m.predicates = append(m.predicates, ps...)
}</span>

// WhereP appends storage-level predicates to the PollMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PollMutation) WhereP(ps ...func(*sql.Selector)) <span class="cov0" title="0">{
        p := make([]predicate.Poll, len(ps))
        for i := range ps </span><span class="cov0" title="0">{
                p[i] = ps[i]
        }</span>
        <span class="cov0" title="0">m.Where(p...)</span>
}

// Op returns the operation name.
func (m *PollMutation) Op() Op <span class="cov0" title="0">{
        return m.op
}</span>

// SetOp allows setting the mutation operation.
func (m *PollMutation) SetOp(op Op) <span class="cov0" title="0">{
        m.op = op
}</span>

// Type returns the node type of this mutation (Poll).
func (m *PollMutation) Type() string <span class="cov0" title="0">{
        return m.typ
}</span>

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PollMutation) Fields() []string <span class="cov0" title="0">{
        fields := make([]string, 0, 3)
        if m.owner != nil </span><span class="cov0" title="0">{
                fields = append(fields, poll.FieldOwnerID)
        }</span>
        <span class="cov0" title="0">if m.title != nil </span><span class="cov0" title="0">{
                fields = append(fields, poll.FieldTitle)
        }</span>
        <span class="cov0" title="0">if m.created_at != nil </span><span class="cov0" title="0">{
                fields = append(fields, poll.FieldCreatedAt)
        }</span>
        <span class="cov0" title="0">return fields</span>
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PollMutation) Field(name string) (ent.Value, bool) <span class="cov0" title="0">{
        switch name </span>{
        case poll.FieldOwnerID:<span class="cov0" title="0">
                return m.OwnerID()</span>
        case poll.FieldTitle:<span class="cov0" title="0">
                return m.Title()</span>
        case poll.FieldCreatedAt:<span class="cov0" title="0">
                return m.CreatedAt()</span>
        }
        <span class="cov0" title="0">return nil, false</span>
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PollMutation) OldField(ctx context.Context, name string) (ent.Value, error) <span class="cov0" title="0">{
        switch name </span>{
        case poll.FieldOwnerID:<span class="cov0" title="0">
                return m.OldOwnerID(ctx)</span>
        case poll.FieldTitle:<span class="cov0" title="0">
                return m.OldTitle(ctx)</span>
        case poll.FieldCreatedAt:<span class="cov0" title="0">
                return m.OldCreatedAt(ctx)</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("unknown Poll field %s", name)</span>
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PollMutation) SetField(name string, value ent.Value) error <span class="cov0" title="0">{
        switch name </span>{
        case poll.FieldOwnerID:<span class="cov0" title="0">
                v, ok := value.(int)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetOwnerID(v)
                return nil</span>
        case poll.FieldTitle:<span class="cov0" title="0">
                v, ok := value.(string)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetTitle(v)
                return nil</span>
        case poll.FieldCreatedAt:<span class="cov0" title="0">
                v, ok := value.(time.Time)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetCreatedAt(v)
                return nil</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown Poll field %s", name)</span>
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PollMutation) AddedFields() []string <span class="cov0" title="0">{
        var fields []string
        return fields
}</span>

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PollMutation) AddedField(name string) (ent.Value, bool) <span class="cov0" title="0">{
        switch name </span>{
        }
        <span class="cov0" title="0">return nil, false</span>
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PollMutation) AddField(name string, value ent.Value) error <span class="cov0" title="0">{
        switch name </span>{
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown Poll numeric field %s", name)</span>
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PollMutation) ClearedFields() []string <span class="cov0" title="0">{
        return nil
}</span>

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PollMutation) FieldCleared(name string) bool <span class="cov0" title="0">{
        _, ok := m.clearedFields[name]
        return ok
}</span>

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PollMutation) ClearField(name string) error <span class="cov0" title="0">{
        return fmt.Errorf("unknown Poll nullable field %s", name)
}</span>

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PollMutation) ResetField(name string) error <span class="cov0" title="0">{
        switch name </span>{
        case poll.FieldOwnerID:<span class="cov0" title="0">
                m.ResetOwnerID()
                return nil</span>
        case poll.FieldTitle:<span class="cov0" title="0">
                m.ResetTitle()
                return nil</span>
        case poll.FieldCreatedAt:<span class="cov0" title="0">
                m.ResetCreatedAt()
                return nil</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown Poll field %s", name)</span>
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PollMutation) AddedEdges() []string <span class="cov0" title="0">{
        edges := make([]string, 0, 3)
        if m.owner != nil </span><span class="cov0" title="0">{
                edges = append(edges, poll.EdgeOwner)
        }</span>
        <span class="cov0" title="0">if m.options != nil </span><span class="cov0" title="0">{
                edges = append(edges, poll.EdgeOptions)
        }</span>
        <span class="cov0" title="0">if m.votes != nil </span><span class="cov0" title="0">{
                edges = append(edges, poll.EdgeVotes)
        }</span>
        <span class="cov0" title="0">return edges</span>
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PollMutation) AddedIDs(name string) []ent.Value <span class="cov0" title="0">{
        switch name </span>{
        case poll.EdgeOwner:<span class="cov0" title="0">
                if id := m.owner; id != nil </span><span class="cov0" title="0">{
                        return []ent.Value{*id}
                }</span>
        case poll.EdgeOptions:<span class="cov0" title="0">
                ids := make([]ent.Value, 0, len(m.options))
                for id := range m.options </span><span class="cov0" title="0">{
                        ids = append(ids, id)
                }</span>
                <span class="cov0" title="0">return ids</span>
        case poll.EdgeVotes:<span class="cov0" title="0">
                ids := make([]ent.Value, 0, len(m.votes))
                for id := range m.votes </span><span class="cov0" title="0">{
                        ids = append(ids, id)
                }</span>
                <span class="cov0" title="0">return ids</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PollMutation) RemovedEdges() []string <span class="cov0" title="0">{
        edges := make([]string, 0, 3)
        if m.removedoptions != nil </span><span class="cov0" title="0">{
                edges = append(edges, poll.EdgeOptions)
        }</span>
        <span class="cov0" title="0">if m.removedvotes != nil </span><span class="cov0" title="0">{
                edges = append(edges, poll.EdgeVotes)
        }</span>
        <span class="cov0" title="0">return edges</span>
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PollMutation) RemovedIDs(name string) []ent.Value <span class="cov0" title="0">{
        switch name </span>{
        case poll.EdgeOptions:<span class="cov0" title="0">
                ids := make([]ent.Value, 0, len(m.removedoptions))
                for id := range m.removedoptions </span><span class="cov0" title="0">{
                        ids = append(ids, id)
                }</span>
                <span class="cov0" title="0">return ids</span>
        case poll.EdgeVotes:<span class="cov0" title="0">
                ids := make([]ent.Value, 0, len(m.removedvotes))
                for id := range m.removedvotes </span><span class="cov0" title="0">{
                        ids = append(ids, id)
                }</span>
                <span class="cov0" title="0">return ids</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PollMutation) ClearedEdges() []string <span class="cov0" title="0">{
        edges := make([]string, 0, 3)
        if m.clearedowner </span><span class="cov0" title="0">{
                edges = append(edges, poll.EdgeOwner)
        }</span>
        <span class="cov0" title="0">if m.clearedoptions </span><span class="cov0" title="0">{
                edges = append(edges, poll.EdgeOptions)
        }</span>
        <span class="cov0" title="0">if m.clearedvotes </span><span class="cov0" title="0">{
                edges = append(edges, poll.EdgeVotes)
        }</span>
        <span class="cov0" title="0">return edges</span>
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PollMutation) EdgeCleared(name string) bool <span class="cov0" title="0">{
        switch name </span>{
        case poll.EdgeOwner:<span class="cov0" title="0">
                return m.clearedowner</span>
        case poll.EdgeOptions:<span class="cov0" title="0">
                return m.clearedoptions</span>
        case poll.EdgeVotes:<span class="cov0" title="0">
                return m.clearedvotes</span>
        }
        <span class="cov0" title="0">return false</span>
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PollMutation) ClearEdge(name string) error <span class="cov0" title="0">{
        switch name </span>{
        case poll.EdgeOwner:<span class="cov0" title="0">
                m.ClearOwner()
                return nil</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown Poll unique edge %s", name)</span>
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PollMutation) ResetEdge(name string) error <span class="cov0" title="0">{
        switch name </span>{
        case poll.EdgeOwner:<span class="cov0" title="0">
                m.ResetOwner()
                return nil</span>
        case poll.EdgeOptions:<span class="cov0" title="0">
                m.ResetOptions()
                return nil</span>
        case poll.EdgeVotes:<span class="cov0" title="0">
                m.ResetVotes()
                return nil</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown Poll edge %s", name)</span>
}

// PollOptionMutation represents an operation that mutates the PollOption nodes in the graph.
type PollOptionMutation struct {
        config
        op            Op
        typ           string
        id            *int
        text          *string
        created_at    *time.Time
        clearedFields map[string]struct{}
        poll          *int
        clearedpoll   bool
        votes         map[int]struct{}
        removedvotes  map[int]struct{}
        clearedvotes  bool
        done          bool
        oldValue      func(context.Context) (*PollOption, error)
        predicates    []predicate.PollOption
}

var _ ent.Mutation = (*PollOptionMutation)(nil)

// polloptionOption allows management of the mutation configuration using functional options.
type polloptionOption func(*PollOptionMutation)

// newPollOptionMutation creates new mutation for the PollOption entity.
func newPollOptionMutation(c config, op Op, opts ...polloptionOption) *PollOptionMutation <span class="cov0" title="0">{
        m := &amp;PollOptionMutation{
                config:        c,
                op:            op,
                typ:           TypePollOption,
                clearedFields: make(map[string]struct{}),
        }
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(m)
        }</span>
        <span class="cov0" title="0">return m</span>
}

// withPollOptionID sets the ID field of the mutation.
func withPollOptionID(id int) polloptionOption <span class="cov0" title="0">{
        return func(m *PollOptionMutation) </span><span class="cov0" title="0">{
                var (
                        err   error
                        once  sync.Once
                        value *PollOption
                )
                m.oldValue = func(ctx context.Context) (*PollOption, error) </span><span class="cov0" title="0">{
                        once.Do(func() </span><span class="cov0" title="0">{
                                if m.done </span><span class="cov0" title="0">{
                                        err = errors.New("querying old values post mutation is not allowed")
                                }</span> else<span class="cov0" title="0"> {
                                        value, err = m.Client().PollOption.Get(ctx, id)
                                }</span>
                        })
                        <span class="cov0" title="0">return value, err</span>
                }
                <span class="cov0" title="0">m.id = &amp;id</span>
        }
}

// withPollOption sets the old PollOption of the mutation.
func withPollOption(node *PollOption) polloptionOption <span class="cov0" title="0">{
        return func(m *PollOptionMutation) </span><span class="cov0" title="0">{
                m.oldValue = func(context.Context) (*PollOption, error) </span><span class="cov0" title="0">{
                        return node, nil
                }</span>
                <span class="cov0" title="0">m.id = &amp;node.ID</span>
        }
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PollOptionMutation) Client() *Client <span class="cov0" title="0">{
        client := &amp;Client{config: m.config}
        client.init()
        return client
}</span>

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PollOptionMutation) Tx() (*Tx, error) <span class="cov0" title="0">{
        if _, ok := m.driver.(*txDriver); !ok </span><span class="cov0" title="0">{
                return nil, errors.New("ent: mutation is not running in a transaction")
        }</span>
        <span class="cov0" title="0">tx := &amp;Tx{config: m.config}
        tx.init()
        return tx, nil</span>
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PollOption entities.
func (m *PollOptionMutation) SetID(id int) <span class="cov0" title="0">{
        m.id = &amp;id
}</span>

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PollOptionMutation) ID() (id int, exists bool) <span class="cov0" title="0">{
        if m.id == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *m.id, true</span>
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PollOptionMutation) IDs(ctx context.Context) ([]int, error) <span class="cov0" title="0">{
        switch </span>{
        case m.op.Is(OpUpdateOne | OpDeleteOne):<span class="cov0" title="0">
                id, exists := m.ID()
                if exists </span><span class="cov0" title="0">{
                        return []int{id}, nil
                }</span>
                <span class="cov0" title="0">fallthrough</span>
        case m.op.Is(OpUpdate | OpDelete):<span class="cov0" title="0">
                return m.Client().PollOption.Query().Where(m.predicates...).IDs(ctx)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)</span>
        }
}

// SetPollID sets the "poll_id" field.
func (m *PollOptionMutation) SetPollID(i int) <span class="cov0" title="0">{
        m.poll = &amp;i
}</span>

// PollID returns the value of the "poll_id" field in the mutation.
func (m *PollOptionMutation) PollID() (r int, exists bool) <span class="cov0" title="0">{
        v := m.poll
        if v == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *v, true</span>
}

// OldPollID returns the old "poll_id" field's value of the PollOption entity.
// If the PollOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PollOptionMutation) OldPollID(ctx context.Context) (v int, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldPollID is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldPollID requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldPollID: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.PollID, nil</span>
}

// ResetPollID resets all changes to the "poll_id" field.
func (m *PollOptionMutation) ResetPollID() <span class="cov0" title="0">{
        m.poll = nil
}</span>

// SetText sets the "text" field.
func (m *PollOptionMutation) SetText(s string) <span class="cov0" title="0">{
        m.text = &amp;s
}</span>

// Text returns the value of the "text" field in the mutation.
func (m *PollOptionMutation) Text() (r string, exists bool) <span class="cov0" title="0">{
        v := m.text
        if v == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *v, true</span>
}

// OldText returns the old "text" field's value of the PollOption entity.
// If the PollOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PollOptionMutation) OldText(ctx context.Context) (v string, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldText is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldText requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldText: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.Text, nil</span>
}

// ResetText resets all changes to the "text" field.
func (m *PollOptionMutation) ResetText() <span class="cov0" title="0">{
        m.text = nil
}</span>

// SetCreatedAt sets the "created_at" field.
func (m *PollOptionMutation) SetCreatedAt(t time.Time) <span class="cov0" title="0">{
        m.created_at = &amp;t
}</span>

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PollOptionMutation) CreatedAt() (r time.Time, exists bool) <span class="cov0" title="0">{
        v := m.created_at
        if v == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *v, true</span>
}

// OldCreatedAt returns the old "created_at" field's value of the PollOption entity.
// If the PollOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PollOptionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldCreatedAt requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.CreatedAt, nil</span>
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PollOptionMutation) ResetCreatedAt() <span class="cov0" title="0">{
        m.created_at = nil
}</span>

// ClearPoll clears the "poll" edge to the Poll entity.
func (m *PollOptionMutation) ClearPoll() <span class="cov0" title="0">{
        m.clearedpoll = true
        m.clearedFields[polloption.FieldPollID] = struct{}{}
}</span>

// PollCleared reports if the "poll" edge to the Poll entity was cleared.
func (m *PollOptionMutation) PollCleared() bool <span class="cov0" title="0">{
        return m.clearedpoll
}</span>

// PollIDs returns the "poll" edge IDs in the mutation.
// Note that IDs always returns len(IDs) &lt;= 1 for unique edges, and you should use
// PollID instead. It exists only for internal usage by the builders.
func (m *PollOptionMutation) PollIDs() (ids []int) <span class="cov0" title="0">{
        if id := m.poll; id != nil </span><span class="cov0" title="0">{
                ids = append(ids, *id)
        }</span>
        <span class="cov0" title="0">return</span>
}

// ResetPoll resets all changes to the "poll" edge.
func (m *PollOptionMutation) ResetPoll() <span class="cov0" title="0">{
        m.poll = nil
        m.clearedpoll = false
}</span>

// AddVoteIDs adds the "votes" edge to the Vote entity by ids.
func (m *PollOptionMutation) AddVoteIDs(ids ...int) <span class="cov0" title="0">{
        if m.votes == nil </span><span class="cov0" title="0">{
                m.votes = make(map[int]struct{})
        }</span>
        <span class="cov0" title="0">for i := range ids </span><span class="cov0" title="0">{
                m.votes[ids[i]] = struct{}{}
        }</span>
}

// ClearVotes clears the "votes" edge to the Vote entity.
func (m *PollOptionMutation) ClearVotes() <span class="cov0" title="0">{
        m.clearedvotes = true
}</span>

// VotesCleared reports if the "votes" edge to the Vote entity was cleared.
func (m *PollOptionMutation) VotesCleared() bool <span class="cov0" title="0">{
        return m.clearedvotes
}</span>

// RemoveVoteIDs removes the "votes" edge to the Vote entity by IDs.
func (m *PollOptionMutation) RemoveVoteIDs(ids ...int) <span class="cov0" title="0">{
        if m.removedvotes == nil </span><span class="cov0" title="0">{
                m.removedvotes = make(map[int]struct{})
        }</span>
        <span class="cov0" title="0">for i := range ids </span><span class="cov0" title="0">{
                delete(m.votes, ids[i])
                m.removedvotes[ids[i]] = struct{}{}
        }</span>
}

// RemovedVotes returns the removed IDs of the "votes" edge to the Vote entity.
func (m *PollOptionMutation) RemovedVotesIDs() (ids []int) <span class="cov0" title="0">{
        for id := range m.removedvotes </span><span class="cov0" title="0">{
                ids = append(ids, id)
        }</span>
        <span class="cov0" title="0">return</span>
}

// VotesIDs returns the "votes" edge IDs in the mutation.
func (m *PollOptionMutation) VotesIDs() (ids []int) <span class="cov0" title="0">{
        for id := range m.votes </span><span class="cov0" title="0">{
                ids = append(ids, id)
        }</span>
        <span class="cov0" title="0">return</span>
}

// ResetVotes resets all changes to the "votes" edge.
func (m *PollOptionMutation) ResetVotes() <span class="cov0" title="0">{
        m.votes = nil
        m.clearedvotes = false
        m.removedvotes = nil
}</span>

// Where appends a list predicates to the PollOptionMutation builder.
func (m *PollOptionMutation) Where(ps ...predicate.PollOption) <span class="cov0" title="0">{
        m.predicates = append(m.predicates, ps...)
}</span>

// WhereP appends storage-level predicates to the PollOptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PollOptionMutation) WhereP(ps ...func(*sql.Selector)) <span class="cov0" title="0">{
        p := make([]predicate.PollOption, len(ps))
        for i := range ps </span><span class="cov0" title="0">{
                p[i] = ps[i]
        }</span>
        <span class="cov0" title="0">m.Where(p...)</span>
}

// Op returns the operation name.
func (m *PollOptionMutation) Op() Op <span class="cov0" title="0">{
        return m.op
}</span>

// SetOp allows setting the mutation operation.
func (m *PollOptionMutation) SetOp(op Op) <span class="cov0" title="0">{
        m.op = op
}</span>

// Type returns the node type of this mutation (PollOption).
func (m *PollOptionMutation) Type() string <span class="cov0" title="0">{
        return m.typ
}</span>

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PollOptionMutation) Fields() []string <span class="cov0" title="0">{
        fields := make([]string, 0, 3)
        if m.poll != nil </span><span class="cov0" title="0">{
                fields = append(fields, polloption.FieldPollID)
        }</span>
        <span class="cov0" title="0">if m.text != nil </span><span class="cov0" title="0">{
                fields = append(fields, polloption.FieldText)
        }</span>
        <span class="cov0" title="0">if m.created_at != nil </span><span class="cov0" title="0">{
                fields = append(fields, polloption.FieldCreatedAt)
        }</span>
        <span class="cov0" title="0">return fields</span>
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PollOptionMutation) Field(name string) (ent.Value, bool) <span class="cov0" title="0">{
        switch name </span>{
        case polloption.FieldPollID:<span class="cov0" title="0">
                return m.PollID()</span>
        case polloption.FieldText:<span class="cov0" title="0">
                return m.Text()</span>
        case polloption.FieldCreatedAt:<span class="cov0" title="0">
                return m.CreatedAt()</span>
        }
        <span class="cov0" title="0">return nil, false</span>
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PollOptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) <span class="cov0" title="0">{
        switch name </span>{
        case polloption.FieldPollID:<span class="cov0" title="0">
                return m.OldPollID(ctx)</span>
        case polloption.FieldText:<span class="cov0" title="0">
                return m.OldText(ctx)</span>
        case polloption.FieldCreatedAt:<span class="cov0" title="0">
                return m.OldCreatedAt(ctx)</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("unknown PollOption field %s", name)</span>
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PollOptionMutation) SetField(name string, value ent.Value) error <span class="cov0" title="0">{
        switch name </span>{
        case polloption.FieldPollID:<span class="cov0" title="0">
                v, ok := value.(int)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetPollID(v)
                return nil</span>
        case polloption.FieldText:<span class="cov0" title="0">
                v, ok := value.(string)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetText(v)
                return nil</span>
        case polloption.FieldCreatedAt:<span class="cov0" title="0">
                v, ok := value.(time.Time)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetCreatedAt(v)
                return nil</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown PollOption field %s", name)</span>
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PollOptionMutation) AddedFields() []string <span class="cov0" title="0">{
        var fields []string
        return fields
}</span>

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PollOptionMutation) AddedField(name string) (ent.Value, bool) <span class="cov0" title="0">{
        switch name </span>{
        }
        <span class="cov0" title="0">return nil, false</span>
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PollOptionMutation) AddField(name string, value ent.Value) error <span class="cov0" title="0">{
        switch name </span>{
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown PollOption numeric field %s", name)</span>
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PollOptionMutation) ClearedFields() []string <span class="cov0" title="0">{
        return nil
}</span>

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PollOptionMutation) FieldCleared(name string) bool <span class="cov0" title="0">{
        _, ok := m.clearedFields[name]
        return ok
}</span>

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PollOptionMutation) ClearField(name string) error <span class="cov0" title="0">{
        return fmt.Errorf("unknown PollOption nullable field %s", name)
}</span>

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PollOptionMutation) ResetField(name string) error <span class="cov0" title="0">{
        switch name </span>{
        case polloption.FieldPollID:<span class="cov0" title="0">
                m.ResetPollID()
                return nil</span>
        case polloption.FieldText:<span class="cov0" title="0">
                m.ResetText()
                return nil</span>
        case polloption.FieldCreatedAt:<span class="cov0" title="0">
                m.ResetCreatedAt()
                return nil</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown PollOption field %s", name)</span>
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PollOptionMutation) AddedEdges() []string <span class="cov0" title="0">{
        edges := make([]string, 0, 2)
        if m.poll != nil </span><span class="cov0" title="0">{
                edges = append(edges, polloption.EdgePoll)
        }</span>
        <span class="cov0" title="0">if m.votes != nil </span><span class="cov0" title="0">{
                edges = append(edges, polloption.EdgeVotes)
        }</span>
        <span class="cov0" title="0">return edges</span>
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PollOptionMutation) AddedIDs(name string) []ent.Value <span class="cov0" title="0">{
        switch name </span>{
        case polloption.EdgePoll:<span class="cov0" title="0">
                if id := m.poll; id != nil </span><span class="cov0" title="0">{
                        return []ent.Value{*id}
                }</span>
        case polloption.EdgeVotes:<span class="cov0" title="0">
                ids := make([]ent.Value, 0, len(m.votes))
                for id := range m.votes </span><span class="cov0" title="0">{
                        ids = append(ids, id)
                }</span>
                <span class="cov0" title="0">return ids</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PollOptionMutation) RemovedEdges() []string <span class="cov0" title="0">{
        edges := make([]string, 0, 2)
        if m.removedvotes != nil </span><span class="cov0" title="0">{
                edges = append(edges, polloption.EdgeVotes)
        }</span>
        <span class="cov0" title="0">return edges</span>
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PollOptionMutation) RemovedIDs(name string) []ent.Value <span class="cov0" title="0">{
        switch name </span>{
        case polloption.EdgeVotes:<span class="cov0" title="0">
                ids := make([]ent.Value, 0, len(m.removedvotes))
                for id := range m.removedvotes </span><span class="cov0" title="0">{
                        ids = append(ids, id)
                }</span>
                <span class="cov0" title="0">return ids</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PollOptionMutation) ClearedEdges() []string <span class="cov0" title="0">{
        edges := make([]string, 0, 2)
        if m.clearedpoll </span><span class="cov0" title="0">{
                edges = append(edges, polloption.EdgePoll)
        }</span>
        <span class="cov0" title="0">if m.clearedvotes </span><span class="cov0" title="0">{
                edges = append(edges, polloption.EdgeVotes)
        }</span>
        <span class="cov0" title="0">return edges</span>
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PollOptionMutation) EdgeCleared(name string) bool <span class="cov0" title="0">{
        switch name </span>{
        case polloption.EdgePoll:<span class="cov0" title="0">
                return m.clearedpoll</span>
        case polloption.EdgeVotes:<span class="cov0" title="0">
                return m.clearedvotes</span>
        }
        <span class="cov0" title="0">return false</span>
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PollOptionMutation) ClearEdge(name string) error <span class="cov0" title="0">{
        switch name </span>{
        case polloption.EdgePoll:<span class="cov0" title="0">
                m.ClearPoll()
                return nil</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown PollOption unique edge %s", name)</span>
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PollOptionMutation) ResetEdge(name string) error <span class="cov0" title="0">{
        switch name </span>{
        case polloption.EdgePoll:<span class="cov0" title="0">
                m.ResetPoll()
                return nil</span>
        case polloption.EdgeVotes:<span class="cov0" title="0">
                m.ResetVotes()
                return nil</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown PollOption edge %s", name)</span>
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
        config
        op            Op
        typ           string
        id            *int
        username      *string
        email         *string
        created_at    *time.Time
        clearedFields map[string]struct{}
        polls         map[int]struct{}
        removedpolls  map[int]struct{}
        clearedpolls  bool
        votes         map[int]struct{}
        removedvotes  map[int]struct{}
        clearedvotes  bool
        done          bool
        oldValue      func(context.Context) (*User, error)
        predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation <span class="cov0" title="0">{
        m := &amp;UserMutation{
                config:        c,
                op:            op,
                typ:           TypeUser,
                clearedFields: make(map[string]struct{}),
        }
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(m)
        }</span>
        <span class="cov0" title="0">return m</span>
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption <span class="cov0" title="0">{
        return func(m *UserMutation) </span><span class="cov0" title="0">{
                var (
                        err   error
                        once  sync.Once
                        value *User
                )
                m.oldValue = func(ctx context.Context) (*User, error) </span><span class="cov0" title="0">{
                        once.Do(func() </span><span class="cov0" title="0">{
                                if m.done </span><span class="cov0" title="0">{
                                        err = errors.New("querying old values post mutation is not allowed")
                                }</span> else<span class="cov0" title="0"> {
                                        value, err = m.Client().User.Get(ctx, id)
                                }</span>
                        })
                        <span class="cov0" title="0">return value, err</span>
                }
                <span class="cov0" title="0">m.id = &amp;id</span>
        }
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption <span class="cov0" title="0">{
        return func(m *UserMutation) </span><span class="cov0" title="0">{
                m.oldValue = func(context.Context) (*User, error) </span><span class="cov0" title="0">{
                        return node, nil
                }</span>
                <span class="cov0" title="0">m.id = &amp;node.ID</span>
        }
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client <span class="cov0" title="0">{
        client := &amp;Client{config: m.config}
        client.init()
        return client
}</span>

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) <span class="cov0" title="0">{
        if _, ok := m.driver.(*txDriver); !ok </span><span class="cov0" title="0">{
                return nil, errors.New("ent: mutation is not running in a transaction")
        }</span>
        <span class="cov0" title="0">tx := &amp;Tx{config: m.config}
        tx.init()
        return tx, nil</span>
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id int) <span class="cov0" title="0">{
        m.id = &amp;id
}</span>

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) <span class="cov0" title="0">{
        if m.id == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *m.id, true</span>
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) <span class="cov0" title="0">{
        switch </span>{
        case m.op.Is(OpUpdateOne | OpDeleteOne):<span class="cov0" title="0">
                id, exists := m.ID()
                if exists </span><span class="cov0" title="0">{
                        return []int{id}, nil
                }</span>
                <span class="cov0" title="0">fallthrough</span>
        case m.op.Is(OpUpdate | OpDelete):<span class="cov0" title="0">
                return m.Client().User.Query().Where(m.predicates...).IDs(ctx)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)</span>
        }
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) <span class="cov0" title="0">{
        m.username = &amp;s
}</span>

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) <span class="cov0" title="0">{
        v := m.username
        if v == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *v, true</span>
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldUsername is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldUsername requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldUsername: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.Username, nil</span>
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() <span class="cov0" title="0">{
        m.username = nil
}</span>

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) <span class="cov0" title="0">{
        m.email = &amp;s
}</span>

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) <span class="cov0" title="0">{
        v := m.email
        if v == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *v, true</span>
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldEmail is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldEmail requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldEmail: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.Email, nil</span>
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() <span class="cov0" title="0">{
        m.email = nil
}</span>

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) <span class="cov0" title="0">{
        m.created_at = &amp;t
}</span>

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) <span class="cov0" title="0">{
        v := m.created_at
        if v == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *v, true</span>
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldCreatedAt requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.CreatedAt, nil</span>
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() <span class="cov0" title="0">{
        m.created_at = nil
}</span>

// AddPollIDs adds the "polls" edge to the Poll entity by ids.
func (m *UserMutation) AddPollIDs(ids ...int) <span class="cov0" title="0">{
        if m.polls == nil </span><span class="cov0" title="0">{
                m.polls = make(map[int]struct{})
        }</span>
        <span class="cov0" title="0">for i := range ids </span><span class="cov0" title="0">{
                m.polls[ids[i]] = struct{}{}
        }</span>
}

// ClearPolls clears the "polls" edge to the Poll entity.
func (m *UserMutation) ClearPolls() <span class="cov0" title="0">{
        m.clearedpolls = true
}</span>

// PollsCleared reports if the "polls" edge to the Poll entity was cleared.
func (m *UserMutation) PollsCleared() bool <span class="cov0" title="0">{
        return m.clearedpolls
}</span>

// RemovePollIDs removes the "polls" edge to the Poll entity by IDs.
func (m *UserMutation) RemovePollIDs(ids ...int) <span class="cov0" title="0">{
        if m.removedpolls == nil </span><span class="cov0" title="0">{
                m.removedpolls = make(map[int]struct{})
        }</span>
        <span class="cov0" title="0">for i := range ids </span><span class="cov0" title="0">{
                delete(m.polls, ids[i])
                m.removedpolls[ids[i]] = struct{}{}
        }</span>
}

// RemovedPolls returns the removed IDs of the "polls" edge to the Poll entity.
func (m *UserMutation) RemovedPollsIDs() (ids []int) <span class="cov0" title="0">{
        for id := range m.removedpolls </span><span class="cov0" title="0">{
                ids = append(ids, id)
        }</span>
        <span class="cov0" title="0">return</span>
}

// PollsIDs returns the "polls" edge IDs in the mutation.
func (m *UserMutation) PollsIDs() (ids []int) <span class="cov0" title="0">{
        for id := range m.polls </span><span class="cov0" title="0">{
                ids = append(ids, id)
        }</span>
        <span class="cov0" title="0">return</span>
}

// ResetPolls resets all changes to the "polls" edge.
func (m *UserMutation) ResetPolls() <span class="cov0" title="0">{
        m.polls = nil
        m.clearedpolls = false
        m.removedpolls = nil
}</span>

// AddVoteIDs adds the "votes" edge to the Vote entity by ids.
func (m *UserMutation) AddVoteIDs(ids ...int) <span class="cov0" title="0">{
        if m.votes == nil </span><span class="cov0" title="0">{
                m.votes = make(map[int]struct{})
        }</span>
        <span class="cov0" title="0">for i := range ids </span><span class="cov0" title="0">{
                m.votes[ids[i]] = struct{}{}
        }</span>
}

// ClearVotes clears the "votes" edge to the Vote entity.
func (m *UserMutation) ClearVotes() <span class="cov0" title="0">{
        m.clearedvotes = true
}</span>

// VotesCleared reports if the "votes" edge to the Vote entity was cleared.
func (m *UserMutation) VotesCleared() bool <span class="cov0" title="0">{
        return m.clearedvotes
}</span>

// RemoveVoteIDs removes the "votes" edge to the Vote entity by IDs.
func (m *UserMutation) RemoveVoteIDs(ids ...int) <span class="cov0" title="0">{
        if m.removedvotes == nil </span><span class="cov0" title="0">{
                m.removedvotes = make(map[int]struct{})
        }</span>
        <span class="cov0" title="0">for i := range ids </span><span class="cov0" title="0">{
                delete(m.votes, ids[i])
                m.removedvotes[ids[i]] = struct{}{}
        }</span>
}

// RemovedVotes returns the removed IDs of the "votes" edge to the Vote entity.
func (m *UserMutation) RemovedVotesIDs() (ids []int) <span class="cov0" title="0">{
        for id := range m.removedvotes </span><span class="cov0" title="0">{
                ids = append(ids, id)
        }</span>
        <span class="cov0" title="0">return</span>
}

// VotesIDs returns the "votes" edge IDs in the mutation.
func (m *UserMutation) VotesIDs() (ids []int) <span class="cov0" title="0">{
        for id := range m.votes </span><span class="cov0" title="0">{
                ids = append(ids, id)
        }</span>
        <span class="cov0" title="0">return</span>
}

// ResetVotes resets all changes to the "votes" edge.
func (m *UserMutation) ResetVotes() <span class="cov0" title="0">{
        m.votes = nil
        m.clearedvotes = false
        m.removedvotes = nil
}</span>

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) <span class="cov0" title="0">{
        m.predicates = append(m.predicates, ps...)
}</span>

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) <span class="cov0" title="0">{
        p := make([]predicate.User, len(ps))
        for i := range ps </span><span class="cov0" title="0">{
                p[i] = ps[i]
        }</span>
        <span class="cov0" title="0">m.Where(p...)</span>
}

// Op returns the operation name.
func (m *UserMutation) Op() Op <span class="cov0" title="0">{
        return m.op
}</span>

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) <span class="cov0" title="0">{
        m.op = op
}</span>

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string <span class="cov0" title="0">{
        return m.typ
}</span>

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string <span class="cov0" title="0">{
        fields := make([]string, 0, 3)
        if m.username != nil </span><span class="cov0" title="0">{
                fields = append(fields, user.FieldUsername)
        }</span>
        <span class="cov0" title="0">if m.email != nil </span><span class="cov0" title="0">{
                fields = append(fields, user.FieldEmail)
        }</span>
        <span class="cov0" title="0">if m.created_at != nil </span><span class="cov0" title="0">{
                fields = append(fields, user.FieldCreatedAt)
        }</span>
        <span class="cov0" title="0">return fields</span>
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) <span class="cov0" title="0">{
        switch name </span>{
        case user.FieldUsername:<span class="cov0" title="0">
                return m.Username()</span>
        case user.FieldEmail:<span class="cov0" title="0">
                return m.Email()</span>
        case user.FieldCreatedAt:<span class="cov0" title="0">
                return m.CreatedAt()</span>
        }
        <span class="cov0" title="0">return nil, false</span>
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) <span class="cov0" title="0">{
        switch name </span>{
        case user.FieldUsername:<span class="cov0" title="0">
                return m.OldUsername(ctx)</span>
        case user.FieldEmail:<span class="cov0" title="0">
                return m.OldEmail(ctx)</span>
        case user.FieldCreatedAt:<span class="cov0" title="0">
                return m.OldCreatedAt(ctx)</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("unknown User field %s", name)</span>
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error <span class="cov0" title="0">{
        switch name </span>{
        case user.FieldUsername:<span class="cov0" title="0">
                v, ok := value.(string)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetUsername(v)
                return nil</span>
        case user.FieldEmail:<span class="cov0" title="0">
                v, ok := value.(string)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetEmail(v)
                return nil</span>
        case user.FieldCreatedAt:<span class="cov0" title="0">
                v, ok := value.(time.Time)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetCreatedAt(v)
                return nil</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown User field %s", name)</span>
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string <span class="cov0" title="0">{
        return nil
}</span>

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) <span class="cov0" title="0">{
        return nil, false
}</span>

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error <span class="cov0" title="0">{
        switch name </span>{
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown User numeric field %s", name)</span>
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string <span class="cov0" title="0">{
        return nil
}</span>

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool <span class="cov0" title="0">{
        _, ok := m.clearedFields[name]
        return ok
}</span>

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error <span class="cov0" title="0">{
        return fmt.Errorf("unknown User nullable field %s", name)
}</span>

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error <span class="cov0" title="0">{
        switch name </span>{
        case user.FieldUsername:<span class="cov0" title="0">
                m.ResetUsername()
                return nil</span>
        case user.FieldEmail:<span class="cov0" title="0">
                m.ResetEmail()
                return nil</span>
        case user.FieldCreatedAt:<span class="cov0" title="0">
                m.ResetCreatedAt()
                return nil</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown User field %s", name)</span>
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string <span class="cov0" title="0">{
        edges := make([]string, 0, 2)
        if m.polls != nil </span><span class="cov0" title="0">{
                edges = append(edges, user.EdgePolls)
        }</span>
        <span class="cov0" title="0">if m.votes != nil </span><span class="cov0" title="0">{
                edges = append(edges, user.EdgeVotes)
        }</span>
        <span class="cov0" title="0">return edges</span>
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value <span class="cov0" title="0">{
        switch name </span>{
        case user.EdgePolls:<span class="cov0" title="0">
                ids := make([]ent.Value, 0, len(m.polls))
                for id := range m.polls </span><span class="cov0" title="0">{
                        ids = append(ids, id)
                }</span>
                <span class="cov0" title="0">return ids</span>
        case user.EdgeVotes:<span class="cov0" title="0">
                ids := make([]ent.Value, 0, len(m.votes))
                for id := range m.votes </span><span class="cov0" title="0">{
                        ids = append(ids, id)
                }</span>
                <span class="cov0" title="0">return ids</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string <span class="cov0" title="0">{
        edges := make([]string, 0, 2)
        if m.removedpolls != nil </span><span class="cov0" title="0">{
                edges = append(edges, user.EdgePolls)
        }</span>
        <span class="cov0" title="0">if m.removedvotes != nil </span><span class="cov0" title="0">{
                edges = append(edges, user.EdgeVotes)
        }</span>
        <span class="cov0" title="0">return edges</span>
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value <span class="cov0" title="0">{
        switch name </span>{
        case user.EdgePolls:<span class="cov0" title="0">
                ids := make([]ent.Value, 0, len(m.removedpolls))
                for id := range m.removedpolls </span><span class="cov0" title="0">{
                        ids = append(ids, id)
                }</span>
                <span class="cov0" title="0">return ids</span>
        case user.EdgeVotes:<span class="cov0" title="0">
                ids := make([]ent.Value, 0, len(m.removedvotes))
                for id := range m.removedvotes </span><span class="cov0" title="0">{
                        ids = append(ids, id)
                }</span>
                <span class="cov0" title="0">return ids</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string <span class="cov0" title="0">{
        edges := make([]string, 0, 2)
        if m.clearedpolls </span><span class="cov0" title="0">{
                edges = append(edges, user.EdgePolls)
        }</span>
        <span class="cov0" title="0">if m.clearedvotes </span><span class="cov0" title="0">{
                edges = append(edges, user.EdgeVotes)
        }</span>
        <span class="cov0" title="0">return edges</span>
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool <span class="cov0" title="0">{
        switch name </span>{
        case user.EdgePolls:<span class="cov0" title="0">
                return m.clearedpolls</span>
        case user.EdgeVotes:<span class="cov0" title="0">
                return m.clearedvotes</span>
        }
        <span class="cov0" title="0">return false</span>
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error <span class="cov0" title="0">{
        switch name </span>{
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown User unique edge %s", name)</span>
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error <span class="cov0" title="0">{
        switch name </span>{
        case user.EdgePolls:<span class="cov0" title="0">
                m.ResetPolls()
                return nil</span>
        case user.EdgeVotes:<span class="cov0" title="0">
                m.ResetVotes()
                return nil</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown User edge %s", name)</span>
}

// VoteMutation represents an operation that mutates the Vote nodes in the graph.
type VoteMutation struct {
        config
        op            Op
        typ           string
        id            *int
        created_at    *time.Time
        clearedFields map[string]struct{}
        poll          *int
        clearedpoll   bool
        option        *int
        clearedoption bool
        user          *int
        cleareduser   bool
        done          bool
        oldValue      func(context.Context) (*Vote, error)
        predicates    []predicate.Vote
}

var _ ent.Mutation = (*VoteMutation)(nil)

// voteOption allows management of the mutation configuration using functional options.
type voteOption func(*VoteMutation)

// newVoteMutation creates new mutation for the Vote entity.
func newVoteMutation(c config, op Op, opts ...voteOption) *VoteMutation <span class="cov0" title="0">{
        m := &amp;VoteMutation{
                config:        c,
                op:            op,
                typ:           TypeVote,
                clearedFields: make(map[string]struct{}),
        }
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(m)
        }</span>
        <span class="cov0" title="0">return m</span>
}

// withVoteID sets the ID field of the mutation.
func withVoteID(id int) voteOption <span class="cov0" title="0">{
        return func(m *VoteMutation) </span><span class="cov0" title="0">{
                var (
                        err   error
                        once  sync.Once
                        value *Vote
                )
                m.oldValue = func(ctx context.Context) (*Vote, error) </span><span class="cov0" title="0">{
                        once.Do(func() </span><span class="cov0" title="0">{
                                if m.done </span><span class="cov0" title="0">{
                                        err = errors.New("querying old values post mutation is not allowed")
                                }</span> else<span class="cov0" title="0"> {
                                        value, err = m.Client().Vote.Get(ctx, id)
                                }</span>
                        })
                        <span class="cov0" title="0">return value, err</span>
                }
                <span class="cov0" title="0">m.id = &amp;id</span>
        }
}

// withVote sets the old Vote of the mutation.
func withVote(node *Vote) voteOption <span class="cov0" title="0">{
        return func(m *VoteMutation) </span><span class="cov0" title="0">{
                m.oldValue = func(context.Context) (*Vote, error) </span><span class="cov0" title="0">{
                        return node, nil
                }</span>
                <span class="cov0" title="0">m.id = &amp;node.ID</span>
        }
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VoteMutation) Client() *Client <span class="cov0" title="0">{
        client := &amp;Client{config: m.config}
        client.init()
        return client
}</span>

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VoteMutation) Tx() (*Tx, error) <span class="cov0" title="0">{
        if _, ok := m.driver.(*txDriver); !ok </span><span class="cov0" title="0">{
                return nil, errors.New("ent: mutation is not running in a transaction")
        }</span>
        <span class="cov0" title="0">tx := &amp;Tx{config: m.config}
        tx.init()
        return tx, nil</span>
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Vote entities.
func (m *VoteMutation) SetID(id int) <span class="cov0" title="0">{
        m.id = &amp;id
}</span>

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VoteMutation) ID() (id int, exists bool) <span class="cov0" title="0">{
        if m.id == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *m.id, true</span>
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VoteMutation) IDs(ctx context.Context) ([]int, error) <span class="cov0" title="0">{
        switch </span>{
        case m.op.Is(OpUpdateOne | OpDeleteOne):<span class="cov0" title="0">
                id, exists := m.ID()
                if exists </span><span class="cov0" title="0">{
                        return []int{id}, nil
                }</span>
                <span class="cov0" title="0">fallthrough</span>
        case m.op.Is(OpUpdate | OpDelete):<span class="cov0" title="0">
                return m.Client().Vote.Query().Where(m.predicates...).IDs(ctx)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)</span>
        }
}

// SetPollID sets the "poll_id" field.
func (m *VoteMutation) SetPollID(i int) <span class="cov0" title="0">{
        m.poll = &amp;i
}</span>

// PollID returns the value of the "poll_id" field in the mutation.
func (m *VoteMutation) PollID() (r int, exists bool) <span class="cov0" title="0">{
        v := m.poll
        if v == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *v, true</span>
}

// OldPollID returns the old "poll_id" field's value of the Vote entity.
// If the Vote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoteMutation) OldPollID(ctx context.Context) (v int, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldPollID is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldPollID requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldPollID: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.PollID, nil</span>
}

// ResetPollID resets all changes to the "poll_id" field.
func (m *VoteMutation) ResetPollID() <span class="cov0" title="0">{
        m.poll = nil
}</span>

// SetOptionID sets the "option_id" field.
func (m *VoteMutation) SetOptionID(i int) <span class="cov0" title="0">{
        m.option = &amp;i
}</span>

// OptionID returns the value of the "option_id" field in the mutation.
func (m *VoteMutation) OptionID() (r int, exists bool) <span class="cov0" title="0">{
        v := m.option
        if v == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *v, true</span>
}

// OldOptionID returns the old "option_id" field's value of the Vote entity.
// If the Vote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoteMutation) OldOptionID(ctx context.Context) (v int, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldOptionID is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldOptionID requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldOptionID: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.OptionID, nil</span>
}

// ResetOptionID resets all changes to the "option_id" field.
func (m *VoteMutation) ResetOptionID() <span class="cov0" title="0">{
        m.option = nil
}</span>

// SetUserID sets the "user_id" field.
func (m *VoteMutation) SetUserID(i int) <span class="cov0" title="0">{
        m.user = &amp;i
}</span>

// UserID returns the value of the "user_id" field in the mutation.
func (m *VoteMutation) UserID() (r int, exists bool) <span class="cov0" title="0">{
        v := m.user
        if v == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *v, true</span>
}

// OldUserID returns the old "user_id" field's value of the Vote entity.
// If the Vote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoteMutation) OldUserID(ctx context.Context) (v int, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldUserID is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldUserID requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldUserID: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.UserID, nil</span>
}

// ResetUserID resets all changes to the "user_id" field.
func (m *VoteMutation) ResetUserID() <span class="cov0" title="0">{
        m.user = nil
}</span>

// SetCreatedAt sets the "created_at" field.
func (m *VoteMutation) SetCreatedAt(t time.Time) <span class="cov0" title="0">{
        m.created_at = &amp;t
}</span>

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VoteMutation) CreatedAt() (r time.Time, exists bool) <span class="cov0" title="0">{
        v := m.created_at
        if v == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *v, true</span>
}

// OldCreatedAt returns the old "created_at" field's value of the Vote entity.
// If the Vote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoteMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldCreatedAt requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.CreatedAt, nil</span>
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VoteMutation) ResetCreatedAt() <span class="cov0" title="0">{
        m.created_at = nil
}</span>

// ClearPoll clears the "poll" edge to the Poll entity.
func (m *VoteMutation) ClearPoll() <span class="cov0" title="0">{
        m.clearedpoll = true
        m.clearedFields[vote.FieldPollID] = struct{}{}
}</span>

// PollCleared reports if the "poll" edge to the Poll entity was cleared.
func (m *VoteMutation) PollCleared() bool <span class="cov0" title="0">{
        return m.clearedpoll
}</span>

// PollIDs returns the "poll" edge IDs in the mutation.
// Note that IDs always returns len(IDs) &lt;= 1 for unique edges, and you should use
// PollID instead. It exists only for internal usage by the builders.
func (m *VoteMutation) PollIDs() (ids []int) <span class="cov0" title="0">{
        if id := m.poll; id != nil </span><span class="cov0" title="0">{
                ids = append(ids, *id)
        }</span>
        <span class="cov0" title="0">return</span>
}

// ResetPoll resets all changes to the "poll" edge.
func (m *VoteMutation) ResetPoll() <span class="cov0" title="0">{
        m.poll = nil
        m.clearedpoll = false
}</span>

// ClearOption clears the "option" edge to the PollOption entity.
func (m *VoteMutation) ClearOption() <span class="cov0" title="0">{
        m.clearedoption = true
        m.clearedFields[vote.FieldOptionID] = struct{}{}
}</span>

// OptionCleared reports if the "option" edge to the PollOption entity was cleared.
func (m *VoteMutation) OptionCleared() bool <span class="cov0" title="0">{
        return m.clearedoption
}</span>

// OptionIDs returns the "option" edge IDs in the mutation.
// Note that IDs always returns len(IDs) &lt;= 1 for unique edges, and you should use
// OptionID instead. It exists only for internal usage by the builders.
func (m *VoteMutation) OptionIDs() (ids []int) <span class="cov0" title="0">{
        if id := m.option; id != nil </span><span class="cov0" title="0">{
                ids = append(ids, *id)
        }</span>
        <span class="cov0" title="0">return</span>
}

// ResetOption resets all changes to the "option" edge.
func (m *VoteMutation) ResetOption() <span class="cov0" title="0">{
        m.option = nil
        m.clearedoption = false
}</span>

// ClearUser clears the "user" edge to the User entity.
func (m *VoteMutation) ClearUser() <span class="cov0" title="0">{
        m.cleareduser = true
        m.clearedFields[vote.FieldUserID] = struct{}{}
}</span>

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *VoteMutation) UserCleared() bool <span class="cov0" title="0">{
        return m.cleareduser
}</span>

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) &lt;= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *VoteMutation) UserIDs() (ids []int) <span class="cov0" title="0">{
        if id := m.user; id != nil </span><span class="cov0" title="0">{
                ids = append(ids, *id)
        }</span>
        <span class="cov0" title="0">return</span>
}

// ResetUser resets all changes to the "user" edge.
func (m *VoteMutation) ResetUser() <span class="cov0" title="0">{
        m.user = nil
        m.cleareduser = false
}</span>

// Where appends a list predicates to the VoteMutation builder.
func (m *VoteMutation) Where(ps ...predicate.Vote) <span class="cov0" title="0">{
        m.predicates = append(m.predicates, ps...)
}</span>

// WhereP appends storage-level predicates to the VoteMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VoteMutation) WhereP(ps ...func(*sql.Selector)) <span class="cov0" title="0">{
        p := make([]predicate.Vote, len(ps))
        for i := range ps </span><span class="cov0" title="0">{
                p[i] = ps[i]
        }</span>
        <span class="cov0" title="0">m.Where(p...)</span>
}

// Op returns the operation name.
func (m *VoteMutation) Op() Op <span class="cov0" title="0">{
        return m.op
}</span>

// SetOp allows setting the mutation operation.
func (m *VoteMutation) SetOp(op Op) <span class="cov0" title="0">{
        m.op = op
}</span>

// Type returns the node type of this mutation (Vote).
func (m *VoteMutation) Type() string <span class="cov0" title="0">{
        return m.typ
}</span>

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VoteMutation) Fields() []string <span class="cov0" title="0">{
        fields := make([]string, 0, 4)
        if m.poll != nil </span><span class="cov0" title="0">{
                fields = append(fields, vote.FieldPollID)
        }</span>
        <span class="cov0" title="0">if m.option != nil </span><span class="cov0" title="0">{
                fields = append(fields, vote.FieldOptionID)
        }</span>
        <span class="cov0" title="0">if m.user != nil </span><span class="cov0" title="0">{
                fields = append(fields, vote.FieldUserID)
        }</span>
        <span class="cov0" title="0">if m.created_at != nil </span><span class="cov0" title="0">{
                fields = append(fields, vote.FieldCreatedAt)
        }</span>
        <span class="cov0" title="0">return fields</span>
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VoteMutation) Field(name string) (ent.Value, bool) <span class="cov0" title="0">{
        switch name </span>{
        case vote.FieldPollID:<span class="cov0" title="0">
                return m.PollID()</span>
        case vote.FieldOptionID:<span class="cov0" title="0">
                return m.OptionID()</span>
        case vote.FieldUserID:<span class="cov0" title="0">
                return m.UserID()</span>
        case vote.FieldCreatedAt:<span class="cov0" title="0">
                return m.CreatedAt()</span>
        }
        <span class="cov0" title="0">return nil, false</span>
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VoteMutation) OldField(ctx context.Context, name string) (ent.Value, error) <span class="cov0" title="0">{
        switch name </span>{
        case vote.FieldPollID:<span class="cov0" title="0">
                return m.OldPollID(ctx)</span>
        case vote.FieldOptionID:<span class="cov0" title="0">
                return m.OldOptionID(ctx)</span>
        case vote.FieldUserID:<span class="cov0" title="0">
                return m.OldUserID(ctx)</span>
        case vote.FieldCreatedAt:<span class="cov0" title="0">
                return m.OldCreatedAt(ctx)</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("unknown Vote field %s", name)</span>
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VoteMutation) SetField(name string, value ent.Value) error <span class="cov0" title="0">{
        switch name </span>{
        case vote.FieldPollID:<span class="cov0" title="0">
                v, ok := value.(int)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetPollID(v)
                return nil</span>
        case vote.FieldOptionID:<span class="cov0" title="0">
                v, ok := value.(int)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetOptionID(v)
                return nil</span>
        case vote.FieldUserID:<span class="cov0" title="0">
                v, ok := value.(int)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetUserID(v)
                return nil</span>
        case vote.FieldCreatedAt:<span class="cov0" title="0">
                v, ok := value.(time.Time)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetCreatedAt(v)
                return nil</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown Vote field %s", name)</span>
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VoteMutation) AddedFields() []string <span class="cov0" title="0">{
        var fields []string
        return fields
}</span>

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VoteMutation) AddedField(name string) (ent.Value, bool) <span class="cov0" title="0">{
        switch name </span>{
        }
        <span class="cov0" title="0">return nil, false</span>
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VoteMutation) AddField(name string, value ent.Value) error <span class="cov0" title="0">{
        switch name </span>{
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown Vote numeric field %s", name)</span>
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VoteMutation) ClearedFields() []string <span class="cov0" title="0">{
        return nil
}</span>

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VoteMutation) FieldCleared(name string) bool <span class="cov0" title="0">{
        _, ok := m.clearedFields[name]
        return ok
}</span>

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VoteMutation) ClearField(name string) error <span class="cov0" title="0">{
        return fmt.Errorf("unknown Vote nullable field %s", name)
}</span>

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VoteMutation) ResetField(name string) error <span class="cov0" title="0">{
        switch name </span>{
        case vote.FieldPollID:<span class="cov0" title="0">
                m.ResetPollID()
                return nil</span>
        case vote.FieldOptionID:<span class="cov0" title="0">
                m.ResetOptionID()
                return nil</span>
        case vote.FieldUserID:<span class="cov0" title="0">
                m.ResetUserID()
                return nil</span>
        case vote.FieldCreatedAt:<span class="cov0" title="0">
                m.ResetCreatedAt()
                return nil</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown Vote field %s", name)</span>
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VoteMutation) AddedEdges() []string <span class="cov0" title="0">{
        edges := make([]string, 0, 3)
        if m.poll != nil </span><span class="cov0" title="0">{
                edges = append(edges, vote.EdgePoll)
        }</span>
        <span class="cov0" title="0">if m.option != nil </span><span class="cov0" title="0">{
                edges = append(edges, vote.EdgeOption)
        }</span>
        <span class="cov0" title="0">if m.user != nil </span><span class="cov0" title="0">{
                edges = append(edges, vote.EdgeUser)
        }</span>
        <span class="cov0" title="0">return edges</span>
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VoteMutation) AddedIDs(name string) []ent.Value <span class="cov0" title="0">{
        switch name </span>{
        case vote.EdgePoll:<span class="cov0" title="0">
                if id := m.poll; id != nil </span><span class="cov0" title="0">{
                        return []ent.Value{*id}
                }</span>
        case vote.EdgeOption:<span class="cov0" title="0">
                if id := m.option; id != nil </span><span class="cov0" title="0">{
                        return []ent.Value{*id}
                }</span>
        case vote.EdgeUser:<span class="cov0" title="0">
                if id := m.user; id != nil </span><span class="cov0" title="0">{
                        return []ent.Value{*id}
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VoteMutation) RemovedEdges() []string <span class="cov0" title="0">{
        edges := make([]string, 0, 3)
        return edges
}</span>

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VoteMutation) RemovedIDs(name string) []ent.Value <span class="cov0" title="0">{
        return nil
}</span>

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VoteMutation) ClearedEdges() []string <span class="cov0" title="0">{
        edges := make([]string, 0, 3)
        if m.clearedpoll </span><span class="cov0" title="0">{
                edges = append(edges, vote.EdgePoll)
        }</span>
        <span class="cov0" title="0">if m.clearedoption </span><span class="cov0" title="0">{
                edges = append(edges, vote.EdgeOption)
        }</span>
        <span class="cov0" title="0">if m.cleareduser </span><span class="cov0" title="0">{
                edges = append(edges, vote.EdgeUser)
        }</span>
        <span class="cov0" title="0">return edges</span>
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VoteMutation) EdgeCleared(name string) bool <span class="cov0" title="0">{
        switch name </span>{
        case vote.EdgePoll:<span class="cov0" title="0">
                return m.clearedpoll</span>
        case vote.EdgeOption:<span class="cov0" title="0">
                return m.clearedoption</span>
        case vote.EdgeUser:<span class="cov0" title="0">
                return m.cleareduser</span>
        }
        <span class="cov0" title="0">return false</span>
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VoteMutation) ClearEdge(name string) error <span class="cov0" title="0">{
        switch name </span>{
        case vote.EdgePoll:<span class="cov0" title="0">
                m.ClearPoll()
                return nil</span>
        case vote.EdgeOption:<span class="cov0" title="0">
                m.ClearOption()
                return nil</span>
        case vote.EdgeUser:<span class="cov0" title="0">
                m.ClearUser()
                return nil</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown Vote unique edge %s", name)</span>
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VoteMutation) ResetEdge(name string) error <span class="cov0" title="0">{
        switch name </span>{
        case vote.EdgePoll:<span class="cov0" title="0">
                m.ResetPoll()
                return nil</span>
        case vote.EdgeOption:<span class="cov0" title="0">
                m.ResetOption()
                return nil</span>
        case vote.EdgeUser:<span class="cov0" title="0">
                m.ResetUser()
                return nil</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown Vote edge %s", name)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "fmt"
        "strings"
        "time"

        "entgo.io/ent"
        "entgo.io/ent/dialect/sql"
        "github.com/ivankorhner/polling-app/internal/ent/poll"
        "github.com/ivankorhner/polling-app/internal/ent/user"
)

// Poll is the model entity for the Poll schema.
type Poll struct {
        config `json:"-"`
        // ID of the ent.
        ID int `json:"id,omitempty"`
        // OwnerID holds the value of the "owner_id" field.
        OwnerID int `json:"owner_id,omitempty"`
        // Title holds the value of the "title" field.
        Title string `json:"title,omitempty"`
        // CreatedAt holds the value of the "created_at" field.
        CreatedAt time.Time `json:"created_at,omitempty"`
        // Edges holds the relations/edges for other nodes in the graph.
        // The values are being populated by the PollQuery when eager-loading is set.
        Edges        PollEdges `json:"edges"`
        selectValues sql.SelectValues
}

// PollEdges holds the relations/edges for other nodes in the graph.
type PollEdges struct {
        // Owner holds the value of the owner edge.
        Owner *User `json:"owner,omitempty"`
        // Options holds the value of the options edge.
        Options []*PollOption `json:"options,omitempty"`
        // Votes holds the value of the votes edge.
        Votes []*Vote `json:"votes,omitempty"`
        // loadedTypes holds the information for reporting if a
        // type was loaded (or requested) in eager-loading or not.
        loadedTypes [3]bool
}

// OwnerOrErr returns the Owner value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e PollEdges) OwnerOrErr() (*User, error) <span class="cov0" title="0">{
        if e.Owner != nil </span><span class="cov0" title="0">{
                return e.Owner, nil
        }</span> else<span class="cov0" title="0"> if e.loadedTypes[0] </span><span class="cov0" title="0">{
                return nil, &amp;NotFoundError{label: user.Label}
        }</span>
        <span class="cov0" title="0">return nil, &amp;NotLoadedError{edge: "owner"}</span>
}

// OptionsOrErr returns the Options value or an error if the edge
// was not loaded in eager-loading.
func (e PollEdges) OptionsOrErr() ([]*PollOption, error) <span class="cov0" title="0">{
        if e.loadedTypes[1] </span><span class="cov0" title="0">{
                return e.Options, nil
        }</span>
        <span class="cov0" title="0">return nil, &amp;NotLoadedError{edge: "options"}</span>
}

// VotesOrErr returns the Votes value or an error if the edge
// was not loaded in eager-loading.
func (e PollEdges) VotesOrErr() ([]*Vote, error) <span class="cov0" title="0">{
        if e.loadedTypes[2] </span><span class="cov0" title="0">{
                return e.Votes, nil
        }</span>
        <span class="cov0" title="0">return nil, &amp;NotLoadedError{edge: "votes"}</span>
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Poll) scanValues(columns []string) ([]any, error) <span class="cov0" title="0">{
        values := make([]any, len(columns))
        for i := range columns </span><span class="cov0" title="0">{
                switch columns[i] </span>{
                case poll.FieldID, poll.FieldOwnerID:<span class="cov0" title="0">
                        values[i] = new(sql.NullInt64)</span>
                case poll.FieldTitle:<span class="cov0" title="0">
                        values[i] = new(sql.NullString)</span>
                case poll.FieldCreatedAt:<span class="cov0" title="0">
                        values[i] = new(sql.NullTime)</span>
                default:<span class="cov0" title="0">
                        values[i] = new(sql.UnknownType)</span>
                }
        }
        <span class="cov0" title="0">return values, nil</span>
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Poll fields.
func (_m *Poll) assignValues(columns []string, values []any) error <span class="cov0" title="0">{
        if m, n := len(values), len(columns); m &lt; n </span><span class="cov0" title="0">{
                return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
        }</span>
        <span class="cov0" title="0">for i := range columns </span><span class="cov0" title="0">{
                switch columns[i] </span>{
                case poll.FieldID:<span class="cov0" title="0">
                        value, ok := values[i].(*sql.NullInt64)
                        if !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field id", value)
                        }</span>
                        <span class="cov0" title="0">_m.ID = int(value.Int64)</span>
                case poll.FieldOwnerID:<span class="cov0" title="0">
                        if value, ok := values[i].(*sql.NullInt64); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field owner_id", values[i])
                        }</span> else<span class="cov0" title="0"> if value.Valid </span><span class="cov0" title="0">{
                                _m.OwnerID = int(value.Int64)
                        }</span>
                case poll.FieldTitle:<span class="cov0" title="0">
                        if value, ok := values[i].(*sql.NullString); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field title", values[i])
                        }</span> else<span class="cov0" title="0"> if value.Valid </span><span class="cov0" title="0">{
                                _m.Title = value.String
                        }</span>
                case poll.FieldCreatedAt:<span class="cov0" title="0">
                        if value, ok := values[i].(*sql.NullTime); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field created_at", values[i])
                        }</span> else<span class="cov0" title="0"> if value.Valid </span><span class="cov0" title="0">{
                                _m.CreatedAt = value.Time
                        }</span>
                default:<span class="cov0" title="0">
                        _m.selectValues.Set(columns[i], values[i])</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// Value returns the ent.Value that was dynamically selected and assigned to the Poll.
// This includes values selected through modifiers, order, etc.
func (_m *Poll) Value(name string) (ent.Value, error) <span class="cov0" title="0">{
        return _m.selectValues.Get(name)
}</span>

// QueryOwner queries the "owner" edge of the Poll entity.
func (_m *Poll) QueryOwner() *UserQuery <span class="cov0" title="0">{
        return NewPollClient(_m.config).QueryOwner(_m)
}</span>

// QueryOptions queries the "options" edge of the Poll entity.
func (_m *Poll) QueryOptions() *PollOptionQuery <span class="cov0" title="0">{
        return NewPollClient(_m.config).QueryOptions(_m)
}</span>

// QueryVotes queries the "votes" edge of the Poll entity.
func (_m *Poll) QueryVotes() *VoteQuery <span class="cov0" title="0">{
        return NewPollClient(_m.config).QueryVotes(_m)
}</span>

// Update returns a builder for updating this Poll.
// Note that you need to call Poll.Unwrap() before calling this method if this Poll
// was returned from a transaction, and the transaction was committed or rolled back.
func (_m *Poll) Update() *PollUpdateOne <span class="cov0" title="0">{
        return NewPollClient(_m.config).UpdateOne(_m)
}</span>

// Unwrap unwraps the Poll entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (_m *Poll) Unwrap() *Poll <span class="cov0" title="0">{
        _tx, ok := _m.config.driver.(*txDriver)
        if !ok </span><span class="cov0" title="0">{
                panic("ent: Poll is not a transactional entity")</span>
        }
        <span class="cov0" title="0">_m.config.driver = _tx.drv
        return _m</span>
}

// String implements the fmt.Stringer.
func (_m *Poll) String() string <span class="cov0" title="0">{
        var builder strings.Builder
        builder.WriteString("Poll(")
        builder.WriteString(fmt.Sprintf("id=%v, ", _m.ID))
        builder.WriteString("owner_id=")
        builder.WriteString(fmt.Sprintf("%v", _m.OwnerID))
        builder.WriteString(", ")
        builder.WriteString("title=")
        builder.WriteString(_m.Title)
        builder.WriteString(", ")
        builder.WriteString("created_at=")
        builder.WriteString(_m.CreatedAt.Format(time.ANSIC))
        builder.WriteByte(')')
        return builder.String()
}</span>

// Polls is a parsable slice of Poll.
type Polls []*Poll
</pre>
		
		<pre class="file" id="file11" style="display: none">// Code generated by ent, DO NOT EDIT.

package poll

import (
        "time"

        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
)

const (
        // Label holds the string label denoting the poll type in the database.
        Label = "poll"
        // FieldID holds the string denoting the id field in the database.
        FieldID = "id"
        // FieldOwnerID holds the string denoting the owner_id field in the database.
        FieldOwnerID = "owner_id"
        // FieldTitle holds the string denoting the title field in the database.
        FieldTitle = "title"
        // FieldCreatedAt holds the string denoting the created_at field in the database.
        FieldCreatedAt = "created_at"
        // EdgeOwner holds the string denoting the owner edge name in mutations.
        EdgeOwner = "owner"
        // EdgeOptions holds the string denoting the options edge name in mutations.
        EdgeOptions = "options"
        // EdgeVotes holds the string denoting the votes edge name in mutations.
        EdgeVotes = "votes"
        // Table holds the table name of the poll in the database.
        Table = "polls"
        // OwnerTable is the table that holds the owner relation/edge.
        OwnerTable = "polls"
        // OwnerInverseTable is the table name for the User entity.
        // It exists in this package in order to avoid circular dependency with the "user" package.
        OwnerInverseTable = "users"
        // OwnerColumn is the table column denoting the owner relation/edge.
        OwnerColumn = "owner_id"
        // OptionsTable is the table that holds the options relation/edge.
        OptionsTable = "poll_options"
        // OptionsInverseTable is the table name for the PollOption entity.
        // It exists in this package in order to avoid circular dependency with the "polloption" package.
        OptionsInverseTable = "poll_options"
        // OptionsColumn is the table column denoting the options relation/edge.
        OptionsColumn = "poll_id"
        // VotesTable is the table that holds the votes relation/edge.
        VotesTable = "votes"
        // VotesInverseTable is the table name for the Vote entity.
        // It exists in this package in order to avoid circular dependency with the "vote" package.
        VotesInverseTable = "votes"
        // VotesColumn is the table column denoting the votes relation/edge.
        VotesColumn = "poll_id"
)

// Columns holds all SQL columns for poll fields.
var Columns = []string{
        FieldID,
        FieldOwnerID,
        FieldTitle,
        FieldCreatedAt,
}

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool <span class="cov0" title="0">{
        for i := range Columns </span><span class="cov0" title="0">{
                if column == Columns[i] </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

var (
        // TitleValidator is a validator for the "title" field. It is called by the builders before save.
        TitleValidator func(string) error
        // DefaultCreatedAt holds the default value on creation for the "created_at" field.
        DefaultCreatedAt func() time.Time
)

// OrderOption defines the ordering options for the Poll queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldID, opts...).ToFunc()
}</span>

// ByOwnerID orders the results by the owner_id field.
func ByOwnerID(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldOwnerID, opts...).ToFunc()
}</span>

// ByTitle orders the results by the title field.
func ByTitle(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldTitle, opts...).ToFunc()
}</span>

// ByCreatedAt orders the results by the created_at field.
func ByCreatedAt(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldCreatedAt, opts...).ToFunc()
}</span>

// ByOwnerField orders the results by owner field.
func ByOwnerField(field string, opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return func(s *sql.Selector) </span><span class="cov0" title="0">{
                sqlgraph.OrderByNeighborTerms(s, newOwnerStep(), sql.OrderByField(field, opts...))
        }</span>
}

// ByOptionsCount orders the results by options count.
func ByOptionsCount(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return func(s *sql.Selector) </span><span class="cov0" title="0">{
                sqlgraph.OrderByNeighborsCount(s, newOptionsStep(), opts...)
        }</span>
}

// ByOptions orders the results by options terms.
func ByOptions(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption <span class="cov0" title="0">{
        return func(s *sql.Selector) </span><span class="cov0" title="0">{
                sqlgraph.OrderByNeighborTerms(s, newOptionsStep(), append([]sql.OrderTerm{term}, terms...)...)
        }</span>
}

// ByVotesCount orders the results by votes count.
func ByVotesCount(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return func(s *sql.Selector) </span><span class="cov0" title="0">{
                sqlgraph.OrderByNeighborsCount(s, newVotesStep(), opts...)
        }</span>
}

// ByVotes orders the results by votes terms.
func ByVotes(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption <span class="cov0" title="0">{
        return func(s *sql.Selector) </span><span class="cov0" title="0">{
                sqlgraph.OrderByNeighborTerms(s, newVotesStep(), append([]sql.OrderTerm{term}, terms...)...)
        }</span>
}
func newOwnerStep() *sqlgraph.Step <span class="cov0" title="0">{
        return sqlgraph.NewStep(
                sqlgraph.From(Table, FieldID),
                sqlgraph.To(OwnerInverseTable, FieldID),
                sqlgraph.Edge(sqlgraph.M2O, true, OwnerTable, OwnerColumn),
        )
}</span>
func newOptionsStep() *sqlgraph.Step <span class="cov0" title="0">{
        return sqlgraph.NewStep(
                sqlgraph.From(Table, FieldID),
                sqlgraph.To(OptionsInverseTable, FieldID),
                sqlgraph.Edge(sqlgraph.O2M, false, OptionsTable, OptionsColumn),
        )
}</span>
func newVotesStep() *sqlgraph.Step <span class="cov0" title="0">{
        return sqlgraph.NewStep(
                sqlgraph.From(Table, FieldID),
                sqlgraph.To(VotesInverseTable, FieldID),
                sqlgraph.Edge(sqlgraph.O2M, false, VotesTable, VotesColumn),
        )
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">// Code generated by ent, DO NOT EDIT.

package poll

import (
        "time"

        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
        "github.com/ivankorhner/polling-app/internal/ent/predicate"
)

// ID filters vertices based on their ID field.
func ID(id int) predicate.Poll <span class="cov0" title="0">{
        return predicate.Poll(sql.FieldEQ(FieldID, id))
}</span>

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id int) predicate.Poll <span class="cov0" title="0">{
        return predicate.Poll(sql.FieldEQ(FieldID, id))
}</span>

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id int) predicate.Poll <span class="cov0" title="0">{
        return predicate.Poll(sql.FieldNEQ(FieldID, id))
}</span>

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...int) predicate.Poll <span class="cov0" title="0">{
        return predicate.Poll(sql.FieldIn(FieldID, ids...))
}</span>

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...int) predicate.Poll <span class="cov0" title="0">{
        return predicate.Poll(sql.FieldNotIn(FieldID, ids...))
}</span>

// IDGT applies the GT predicate on the ID field.
func IDGT(id int) predicate.Poll <span class="cov0" title="0">{
        return predicate.Poll(sql.FieldGT(FieldID, id))
}</span>

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id int) predicate.Poll <span class="cov0" title="0">{
        return predicate.Poll(sql.FieldGTE(FieldID, id))
}</span>

// IDLT applies the LT predicate on the ID field.
func IDLT(id int) predicate.Poll <span class="cov0" title="0">{
        return predicate.Poll(sql.FieldLT(FieldID, id))
}</span>

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id int) predicate.Poll <span class="cov0" title="0">{
        return predicate.Poll(sql.FieldLTE(FieldID, id))
}</span>

// OwnerID applies equality check predicate on the "owner_id" field. It's identical to OwnerIDEQ.
func OwnerID(v int) predicate.Poll <span class="cov0" title="0">{
        return predicate.Poll(sql.FieldEQ(FieldOwnerID, v))
}</span>

// Title applies equality check predicate on the "title" field. It's identical to TitleEQ.
func Title(v string) predicate.Poll <span class="cov0" title="0">{
        return predicate.Poll(sql.FieldEQ(FieldTitle, v))
}</span>

// CreatedAt applies equality check predicate on the "created_at" field. It's identical to CreatedAtEQ.
func CreatedAt(v time.Time) predicate.Poll <span class="cov0" title="0">{
        return predicate.Poll(sql.FieldEQ(FieldCreatedAt, v))
}</span>

// OwnerIDEQ applies the EQ predicate on the "owner_id" field.
func OwnerIDEQ(v int) predicate.Poll <span class="cov0" title="0">{
        return predicate.Poll(sql.FieldEQ(FieldOwnerID, v))
}</span>

// OwnerIDNEQ applies the NEQ predicate on the "owner_id" field.
func OwnerIDNEQ(v int) predicate.Poll <span class="cov0" title="0">{
        return predicate.Poll(sql.FieldNEQ(FieldOwnerID, v))
}</span>

// OwnerIDIn applies the In predicate on the "owner_id" field.
func OwnerIDIn(vs ...int) predicate.Poll <span class="cov0" title="0">{
        return predicate.Poll(sql.FieldIn(FieldOwnerID, vs...))
}</span>

// OwnerIDNotIn applies the NotIn predicate on the "owner_id" field.
func OwnerIDNotIn(vs ...int) predicate.Poll <span class="cov0" title="0">{
        return predicate.Poll(sql.FieldNotIn(FieldOwnerID, vs...))
}</span>

// TitleEQ applies the EQ predicate on the "title" field.
func TitleEQ(v string) predicate.Poll <span class="cov0" title="0">{
        return predicate.Poll(sql.FieldEQ(FieldTitle, v))
}</span>

// TitleNEQ applies the NEQ predicate on the "title" field.
func TitleNEQ(v string) predicate.Poll <span class="cov0" title="0">{
        return predicate.Poll(sql.FieldNEQ(FieldTitle, v))
}</span>

// TitleIn applies the In predicate on the "title" field.
func TitleIn(vs ...string) predicate.Poll <span class="cov0" title="0">{
        return predicate.Poll(sql.FieldIn(FieldTitle, vs...))
}</span>

// TitleNotIn applies the NotIn predicate on the "title" field.
func TitleNotIn(vs ...string) predicate.Poll <span class="cov0" title="0">{
        return predicate.Poll(sql.FieldNotIn(FieldTitle, vs...))
}</span>

// TitleGT applies the GT predicate on the "title" field.
func TitleGT(v string) predicate.Poll <span class="cov0" title="0">{
        return predicate.Poll(sql.FieldGT(FieldTitle, v))
}</span>

// TitleGTE applies the GTE predicate on the "title" field.
func TitleGTE(v string) predicate.Poll <span class="cov0" title="0">{
        return predicate.Poll(sql.FieldGTE(FieldTitle, v))
}</span>

// TitleLT applies the LT predicate on the "title" field.
func TitleLT(v string) predicate.Poll <span class="cov0" title="0">{
        return predicate.Poll(sql.FieldLT(FieldTitle, v))
}</span>

// TitleLTE applies the LTE predicate on the "title" field.
func TitleLTE(v string) predicate.Poll <span class="cov0" title="0">{
        return predicate.Poll(sql.FieldLTE(FieldTitle, v))
}</span>

// TitleContains applies the Contains predicate on the "title" field.
func TitleContains(v string) predicate.Poll <span class="cov0" title="0">{
        return predicate.Poll(sql.FieldContains(FieldTitle, v))
}</span>

// TitleHasPrefix applies the HasPrefix predicate on the "title" field.
func TitleHasPrefix(v string) predicate.Poll <span class="cov0" title="0">{
        return predicate.Poll(sql.FieldHasPrefix(FieldTitle, v))
}</span>

// TitleHasSuffix applies the HasSuffix predicate on the "title" field.
func TitleHasSuffix(v string) predicate.Poll <span class="cov0" title="0">{
        return predicate.Poll(sql.FieldHasSuffix(FieldTitle, v))
}</span>

// TitleEqualFold applies the EqualFold predicate on the "title" field.
func TitleEqualFold(v string) predicate.Poll <span class="cov0" title="0">{
        return predicate.Poll(sql.FieldEqualFold(FieldTitle, v))
}</span>

// TitleContainsFold applies the ContainsFold predicate on the "title" field.
func TitleContainsFold(v string) predicate.Poll <span class="cov0" title="0">{
        return predicate.Poll(sql.FieldContainsFold(FieldTitle, v))
}</span>

// CreatedAtEQ applies the EQ predicate on the "created_at" field.
func CreatedAtEQ(v time.Time) predicate.Poll <span class="cov0" title="0">{
        return predicate.Poll(sql.FieldEQ(FieldCreatedAt, v))
}</span>

// CreatedAtNEQ applies the NEQ predicate on the "created_at" field.
func CreatedAtNEQ(v time.Time) predicate.Poll <span class="cov0" title="0">{
        return predicate.Poll(sql.FieldNEQ(FieldCreatedAt, v))
}</span>

// CreatedAtIn applies the In predicate on the "created_at" field.
func CreatedAtIn(vs ...time.Time) predicate.Poll <span class="cov0" title="0">{
        return predicate.Poll(sql.FieldIn(FieldCreatedAt, vs...))
}</span>

// CreatedAtNotIn applies the NotIn predicate on the "created_at" field.
func CreatedAtNotIn(vs ...time.Time) predicate.Poll <span class="cov0" title="0">{
        return predicate.Poll(sql.FieldNotIn(FieldCreatedAt, vs...))
}</span>

// CreatedAtGT applies the GT predicate on the "created_at" field.
func CreatedAtGT(v time.Time) predicate.Poll <span class="cov0" title="0">{
        return predicate.Poll(sql.FieldGT(FieldCreatedAt, v))
}</span>

// CreatedAtGTE applies the GTE predicate on the "created_at" field.
func CreatedAtGTE(v time.Time) predicate.Poll <span class="cov0" title="0">{
        return predicate.Poll(sql.FieldGTE(FieldCreatedAt, v))
}</span>

// CreatedAtLT applies the LT predicate on the "created_at" field.
func CreatedAtLT(v time.Time) predicate.Poll <span class="cov0" title="0">{
        return predicate.Poll(sql.FieldLT(FieldCreatedAt, v))
}</span>

// CreatedAtLTE applies the LTE predicate on the "created_at" field.
func CreatedAtLTE(v time.Time) predicate.Poll <span class="cov0" title="0">{
        return predicate.Poll(sql.FieldLTE(FieldCreatedAt, v))
}</span>

// HasOwner applies the HasEdge predicate on the "owner" edge.
func HasOwner() predicate.Poll <span class="cov0" title="0">{
        return predicate.Poll(func(s *sql.Selector) </span><span class="cov0" title="0">{
                step := sqlgraph.NewStep(
                        sqlgraph.From(Table, FieldID),
                        sqlgraph.Edge(sqlgraph.M2O, true, OwnerTable, OwnerColumn),
                )
                sqlgraph.HasNeighbors(s, step)
        }</span>)
}

// HasOwnerWith applies the HasEdge predicate on the "owner" edge with a given conditions (other predicates).
func HasOwnerWith(preds ...predicate.User) predicate.Poll <span class="cov0" title="0">{
        return predicate.Poll(func(s *sql.Selector) </span><span class="cov0" title="0">{
                step := newOwnerStep()
                sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) </span><span class="cov0" title="0">{
                        for _, p := range preds </span><span class="cov0" title="0">{
                                p(s)
                        }</span>
                })
        })
}

// HasOptions applies the HasEdge predicate on the "options" edge.
func HasOptions() predicate.Poll <span class="cov0" title="0">{
        return predicate.Poll(func(s *sql.Selector) </span><span class="cov0" title="0">{
                step := sqlgraph.NewStep(
                        sqlgraph.From(Table, FieldID),
                        sqlgraph.Edge(sqlgraph.O2M, false, OptionsTable, OptionsColumn),
                )
                sqlgraph.HasNeighbors(s, step)
        }</span>)
}

// HasOptionsWith applies the HasEdge predicate on the "options" edge with a given conditions (other predicates).
func HasOptionsWith(preds ...predicate.PollOption) predicate.Poll <span class="cov0" title="0">{
        return predicate.Poll(func(s *sql.Selector) </span><span class="cov0" title="0">{
                step := newOptionsStep()
                sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) </span><span class="cov0" title="0">{
                        for _, p := range preds </span><span class="cov0" title="0">{
                                p(s)
                        }</span>
                })
        })
}

// HasVotes applies the HasEdge predicate on the "votes" edge.
func HasVotes() predicate.Poll <span class="cov0" title="0">{
        return predicate.Poll(func(s *sql.Selector) </span><span class="cov0" title="0">{
                step := sqlgraph.NewStep(
                        sqlgraph.From(Table, FieldID),
                        sqlgraph.Edge(sqlgraph.O2M, false, VotesTable, VotesColumn),
                )
                sqlgraph.HasNeighbors(s, step)
        }</span>)
}

// HasVotesWith applies the HasEdge predicate on the "votes" edge with a given conditions (other predicates).
func HasVotesWith(preds ...predicate.Vote) predicate.Poll <span class="cov0" title="0">{
        return predicate.Poll(func(s *sql.Selector) </span><span class="cov0" title="0">{
                step := newVotesStep()
                sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) </span><span class="cov0" title="0">{
                        for _, p := range preds </span><span class="cov0" title="0">{
                                p(s)
                        }</span>
                })
        })
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.Poll) predicate.Poll <span class="cov0" title="0">{
        return predicate.Poll(sql.AndPredicates(predicates...))
}</span>

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.Poll) predicate.Poll <span class="cov0" title="0">{
        return predicate.Poll(sql.OrPredicates(predicates...))
}</span>

// Not applies the not operator on the given predicate.
func Not(p predicate.Poll) predicate.Poll <span class="cov0" title="0">{
        return predicate.Poll(sql.NotPredicates(p))
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "context"
        "errors"
        "fmt"
        "time"

        "entgo.io/ent/dialect/sql/sqlgraph"
        "entgo.io/ent/schema/field"
        "github.com/ivankorhner/polling-app/internal/ent/poll"
        "github.com/ivankorhner/polling-app/internal/ent/polloption"
        "github.com/ivankorhner/polling-app/internal/ent/user"
        "github.com/ivankorhner/polling-app/internal/ent/vote"
)

// PollCreate is the builder for creating a Poll entity.
type PollCreate struct {
        config
        mutation *PollMutation
        hooks    []Hook
}

// SetOwnerID sets the "owner_id" field.
func (_c *PollCreate) SetOwnerID(v int) *PollCreate <span class="cov0" title="0">{
        _c.mutation.SetOwnerID(v)
        return _c
}</span>

// SetTitle sets the "title" field.
func (_c *PollCreate) SetTitle(v string) *PollCreate <span class="cov0" title="0">{
        _c.mutation.SetTitle(v)
        return _c
}</span>

// SetCreatedAt sets the "created_at" field.
func (_c *PollCreate) SetCreatedAt(v time.Time) *PollCreate <span class="cov0" title="0">{
        _c.mutation.SetCreatedAt(v)
        return _c
}</span>

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (_c *PollCreate) SetNillableCreatedAt(v *time.Time) *PollCreate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _c.SetCreatedAt(*v)
        }</span>
        <span class="cov0" title="0">return _c</span>
}

// SetID sets the "id" field.
func (_c *PollCreate) SetID(v int) *PollCreate <span class="cov0" title="0">{
        _c.mutation.SetID(v)
        return _c
}</span>

// SetOwner sets the "owner" edge to the User entity.
func (_c *PollCreate) SetOwner(v *User) *PollCreate <span class="cov0" title="0">{
        return _c.SetOwnerID(v.ID)
}</span>

// AddOptionIDs adds the "options" edge to the PollOption entity by IDs.
func (_c *PollCreate) AddOptionIDs(ids ...int) *PollCreate <span class="cov0" title="0">{
        _c.mutation.AddOptionIDs(ids...)
        return _c
}</span>

// AddOptions adds the "options" edges to the PollOption entity.
func (_c *PollCreate) AddOptions(v ...*PollOption) *PollCreate <span class="cov0" title="0">{
        ids := make([]int, len(v))
        for i := range v </span><span class="cov0" title="0">{
                ids[i] = v[i].ID
        }</span>
        <span class="cov0" title="0">return _c.AddOptionIDs(ids...)</span>
}

// AddVoteIDs adds the "votes" edge to the Vote entity by IDs.
func (_c *PollCreate) AddVoteIDs(ids ...int) *PollCreate <span class="cov0" title="0">{
        _c.mutation.AddVoteIDs(ids...)
        return _c
}</span>

// AddVotes adds the "votes" edges to the Vote entity.
func (_c *PollCreate) AddVotes(v ...*Vote) *PollCreate <span class="cov0" title="0">{
        ids := make([]int, len(v))
        for i := range v </span><span class="cov0" title="0">{
                ids[i] = v[i].ID
        }</span>
        <span class="cov0" title="0">return _c.AddVoteIDs(ids...)</span>
}

// Mutation returns the PollMutation object of the builder.
func (_c *PollCreate) Mutation() *PollMutation <span class="cov0" title="0">{
        return _c.mutation
}</span>

// Save creates the Poll in the database.
func (_c *PollCreate) Save(ctx context.Context) (*Poll, error) <span class="cov0" title="0">{
        _c.defaults()
        return withHooks(ctx, _c.sqlSave, _c.mutation, _c.hooks)
}</span>

// SaveX calls Save and panics if Save returns an error.
func (_c *PollCreate) SaveX(ctx context.Context) *Poll <span class="cov0" title="0">{
        v, err := _c.Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return v</span>
}

// Exec executes the query.
func (_c *PollCreate) Exec(ctx context.Context) error <span class="cov0" title="0">{
        _, err := _c.Save(ctx)
        return err
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (_c *PollCreate) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := _c.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// defaults sets the default values of the builder before save.
func (_c *PollCreate) defaults() <span class="cov0" title="0">{
        if _, ok := _c.mutation.CreatedAt(); !ok </span><span class="cov0" title="0">{
                v := poll.DefaultCreatedAt()
                _c.mutation.SetCreatedAt(v)
        }</span>
}

// check runs all checks and user-defined validators on the builder.
func (_c *PollCreate) check() error <span class="cov0" title="0">{
        if _, ok := _c.mutation.OwnerID(); !ok </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "owner_id", err: errors.New(`ent: missing required field "Poll.owner_id"`)}
        }</span>
        <span class="cov0" title="0">if _, ok := _c.mutation.Title(); !ok </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "title", err: errors.New(`ent: missing required field "Poll.title"`)}
        }</span>
        <span class="cov0" title="0">if v, ok := _c.mutation.Title(); ok </span><span class="cov0" title="0">{
                if err := poll.TitleValidator(v); err != nil </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: "title", err: fmt.Errorf(`ent: validator failed for field "Poll.title": %w`, err)}
                }</span>
        }
        <span class="cov0" title="0">if _, ok := _c.mutation.CreatedAt(); !ok </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "created_at", err: errors.New(`ent: missing required field "Poll.created_at"`)}
        }</span>
        <span class="cov0" title="0">if len(_c.mutation.OwnerIDs()) == 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "owner", err: errors.New(`ent: missing required edge "Poll.owner"`)}
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (_c *PollCreate) sqlSave(ctx context.Context) (*Poll, error) <span class="cov0" title="0">{
        if err := _c.check(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">_node, _spec := _c.createSpec()
        if err := sqlgraph.CreateNode(ctx, _c.driver, _spec); err != nil </span><span class="cov0" title="0">{
                if sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                        err = &amp;ConstraintError{msg: err.Error(), wrap: err}
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">if _spec.ID.Value != _node.ID </span><span class="cov0" title="0">{
                id := _spec.ID.Value.(int64)
                _node.ID = int(id)
        }</span>
        <span class="cov0" title="0">_c.mutation.id = &amp;_node.ID
        _c.mutation.done = true
        return _node, nil</span>
}

func (_c *PollCreate) createSpec() (*Poll, *sqlgraph.CreateSpec) <span class="cov0" title="0">{
        var (
                _node = &amp;Poll{config: _c.config}
                _spec = sqlgraph.NewCreateSpec(poll.Table, sqlgraph.NewFieldSpec(poll.FieldID, field.TypeInt))
        )
        if id, ok := _c.mutation.ID(); ok </span><span class="cov0" title="0">{
                _node.ID = id
                _spec.ID.Value = id
        }</span>
        <span class="cov0" title="0">if value, ok := _c.mutation.Title(); ok </span><span class="cov0" title="0">{
                _spec.SetField(poll.FieldTitle, field.TypeString, value)
                _node.Title = value
        }</span>
        <span class="cov0" title="0">if value, ok := _c.mutation.CreatedAt(); ok </span><span class="cov0" title="0">{
                _spec.SetField(poll.FieldCreatedAt, field.TypeTime, value)
                _node.CreatedAt = value
        }</span>
        <span class="cov0" title="0">if nodes := _c.mutation.OwnerIDs(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2O,
                        Inverse: true,
                        Table:   poll.OwnerTable,
                        Columns: []string{poll.OwnerColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeInt),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_node.OwnerID = nodes[0]
                _spec.Edges = append(_spec.Edges, edge)</span>
        }
        <span class="cov0" title="0">if nodes := _c.mutation.OptionsIDs(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   poll.OptionsTable,
                        Columns: []string{poll.OptionsColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(polloption.FieldID, field.TypeInt),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges = append(_spec.Edges, edge)</span>
        }
        <span class="cov0" title="0">if nodes := _c.mutation.VotesIDs(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   poll.VotesTable,
                        Columns: []string{poll.VotesColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(vote.FieldID, field.TypeInt),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges = append(_spec.Edges, edge)</span>
        }
        <span class="cov0" title="0">return _node, _spec</span>
}

// PollCreateBulk is the builder for creating many Poll entities in bulk.
type PollCreateBulk struct {
        config
        err      error
        builders []*PollCreate
}

// Save creates the Poll entities in the database.
func (_c *PollCreateBulk) Save(ctx context.Context) ([]*Poll, error) <span class="cov0" title="0">{
        if _c.err != nil </span><span class="cov0" title="0">{
                return nil, _c.err
        }</span>
        <span class="cov0" title="0">specs := make([]*sqlgraph.CreateSpec, len(_c.builders))
        nodes := make([]*Poll, len(_c.builders))
        mutators := make([]Mutator, len(_c.builders))
        for i := range _c.builders </span><span class="cov0" title="0">{
                func(i int, root context.Context) </span><span class="cov0" title="0">{
                        builder := _c.builders[i]
                        builder.defaults()
                        var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) </span><span class="cov0" title="0">{
                                mutation, ok := m.(*PollMutation)
                                if !ok </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("unexpected mutation type %T", m)
                                }</span>
                                <span class="cov0" title="0">if err := builder.check(); err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">builder.mutation = mutation
                                var err error
                                nodes[i], specs[i] = builder.createSpec()
                                if i &lt; len(mutators)-1 </span><span class="cov0" title="0">{
                                        _, err = mutators[i+1].Mutate(root, _c.builders[i+1].mutation)
                                }</span> else<span class="cov0" title="0"> {
                                        spec := &amp;sqlgraph.BatchCreateSpec{Nodes: specs}
                                        // Invoke the actual operation on the latest mutation in the chain.
                                        if err = sqlgraph.BatchCreate(ctx, _c.driver, spec); err != nil </span><span class="cov0" title="0">{
                                                if sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                                                        err = &amp;ConstraintError{msg: err.Error(), wrap: err}
                                                }</span>
                                        }
                                }
                                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">mutation.id = &amp;nodes[i].ID
                                if specs[i].ID.Value != nil &amp;&amp; nodes[i].ID == 0 </span><span class="cov0" title="0">{
                                        id := specs[i].ID.Value.(int64)
                                        nodes[i].ID = int(id)
                                }</span>
                                <span class="cov0" title="0">mutation.done = true
                                return nodes[i], nil</span>
                        })
                        <span class="cov0" title="0">for i := len(builder.hooks) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                                mut = builder.hooks[i](mut)
                        }</span>
                        <span class="cov0" title="0">mutators[i] = mut</span>
                }(i, ctx)
        }
        <span class="cov0" title="0">if len(mutators) &gt; 0 </span><span class="cov0" title="0">{
                if _, err := mutators[0].Mutate(ctx, _c.builders[0].mutation); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return nodes, nil</span>
}

// SaveX is like Save, but panics if an error occurs.
func (_c *PollCreateBulk) SaveX(ctx context.Context) []*Poll <span class="cov0" title="0">{
        v, err := _c.Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return v</span>
}

// Exec executes the query.
func (_c *PollCreateBulk) Exec(ctx context.Context) error <span class="cov0" title="0">{
        _, err := _c.Save(ctx)
        return err
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (_c *PollCreateBulk) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := _c.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "context"

        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
        "entgo.io/ent/schema/field"
        "github.com/ivankorhner/polling-app/internal/ent/poll"
        "github.com/ivankorhner/polling-app/internal/ent/predicate"
)

// PollDelete is the builder for deleting a Poll entity.
type PollDelete struct {
        config
        hooks    []Hook
        mutation *PollMutation
}

// Where appends a list predicates to the PollDelete builder.
func (_d *PollDelete) Where(ps ...predicate.Poll) *PollDelete <span class="cov0" title="0">{
        _d.mutation.Where(ps...)
        return _d
}</span>

// Exec executes the deletion query and returns how many vertices were deleted.
func (_d *PollDelete) Exec(ctx context.Context) (int, error) <span class="cov0" title="0">{
        return withHooks(ctx, _d.sqlExec, _d.mutation, _d.hooks)
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (_d *PollDelete) ExecX(ctx context.Context) int <span class="cov0" title="0">{
        n, err := _d.Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return n</span>
}

func (_d *PollDelete) sqlExec(ctx context.Context) (int, error) <span class="cov0" title="0">{
        _spec := sqlgraph.NewDeleteSpec(poll.Table, sqlgraph.NewFieldSpec(poll.FieldID, field.TypeInt))
        if ps := _d.mutation.predicates; len(ps) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Predicate = func(selector *sql.Selector) </span><span class="cov0" title="0">{
                        for i := range ps </span><span class="cov0" title="0">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov0" title="0">affected, err := sqlgraph.DeleteNodes(ctx, _d.driver, _spec)
        if err != nil &amp;&amp; sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                err = &amp;ConstraintError{msg: err.Error(), wrap: err}
        }</span>
        <span class="cov0" title="0">_d.mutation.done = true
        return affected, err</span>
}

// PollDeleteOne is the builder for deleting a single Poll entity.
type PollDeleteOne struct {
        _d *PollDelete
}

// Where appends a list predicates to the PollDelete builder.
func (_d *PollDeleteOne) Where(ps ...predicate.Poll) *PollDeleteOne <span class="cov0" title="0">{
        _d._d.mutation.Where(ps...)
        return _d
}</span>

// Exec executes the deletion query.
func (_d *PollDeleteOne) Exec(ctx context.Context) error <span class="cov0" title="0">{
        n, err := _d._d.Exec(ctx)
        switch </span>{
        case err != nil:<span class="cov0" title="0">
                return err</span>
        case n == 0:<span class="cov0" title="0">
                return &amp;NotFoundError{poll.Label}</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

// ExecX is like Exec, but panics if an error occurs.
func (_d *PollDeleteOne) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := _d.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "context"
        "database/sql/driver"
        "fmt"
        "math"

        "entgo.io/ent"
        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
        "entgo.io/ent/schema/field"
        "github.com/ivankorhner/polling-app/internal/ent/poll"
        "github.com/ivankorhner/polling-app/internal/ent/polloption"
        "github.com/ivankorhner/polling-app/internal/ent/predicate"
        "github.com/ivankorhner/polling-app/internal/ent/user"
        "github.com/ivankorhner/polling-app/internal/ent/vote"
)

// PollQuery is the builder for querying Poll entities.
type PollQuery struct {
        config
        ctx         *QueryContext
        order       []poll.OrderOption
        inters      []Interceptor
        predicates  []predicate.Poll
        withOwner   *UserQuery
        withOptions *PollOptionQuery
        withVotes   *VoteQuery
        // intermediate query (i.e. traversal path).
        sql  *sql.Selector
        path func(context.Context) (*sql.Selector, error)
}

// Where adds a new predicate for the PollQuery builder.
func (_q *PollQuery) Where(ps ...predicate.Poll) *PollQuery <span class="cov0" title="0">{
        _q.predicates = append(_q.predicates, ps...)
        return _q
}</span>

// Limit the number of records to be returned by this query.
func (_q *PollQuery) Limit(limit int) *PollQuery <span class="cov0" title="0">{
        _q.ctx.Limit = &amp;limit
        return _q
}</span>

// Offset to start from.
func (_q *PollQuery) Offset(offset int) *PollQuery <span class="cov0" title="0">{
        _q.ctx.Offset = &amp;offset
        return _q
}</span>

// Unique configures the query builder to filter duplicate records on query.
// By default, unique is set to true, and can be disabled using this method.
func (_q *PollQuery) Unique(unique bool) *PollQuery <span class="cov0" title="0">{
        _q.ctx.Unique = &amp;unique
        return _q
}</span>

// Order specifies how the records should be ordered.
func (_q *PollQuery) Order(o ...poll.OrderOption) *PollQuery <span class="cov0" title="0">{
        _q.order = append(_q.order, o...)
        return _q
}</span>

// QueryOwner chains the current query on the "owner" edge.
func (_q *PollQuery) QueryOwner() *UserQuery <span class="cov0" title="0">{
        query := (&amp;UserClient{config: _q.config}).Query()
        query.path = func(ctx context.Context) (fromU *sql.Selector, err error) </span><span class="cov0" title="0">{
                if err := _q.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">selector := _q.sqlQuery(ctx)
                if err := selector.Err(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">step := sqlgraph.NewStep(
                        sqlgraph.From(poll.Table, poll.FieldID, selector),
                        sqlgraph.To(user.Table, user.FieldID),
                        sqlgraph.Edge(sqlgraph.M2O, true, poll.OwnerTable, poll.OwnerColumn),
                )
                fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
                return fromU, nil</span>
        }
        <span class="cov0" title="0">return query</span>
}

// QueryOptions chains the current query on the "options" edge.
func (_q *PollQuery) QueryOptions() *PollOptionQuery <span class="cov0" title="0">{
        query := (&amp;PollOptionClient{config: _q.config}).Query()
        query.path = func(ctx context.Context) (fromU *sql.Selector, err error) </span><span class="cov0" title="0">{
                if err := _q.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">selector := _q.sqlQuery(ctx)
                if err := selector.Err(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">step := sqlgraph.NewStep(
                        sqlgraph.From(poll.Table, poll.FieldID, selector),
                        sqlgraph.To(polloption.Table, polloption.FieldID),
                        sqlgraph.Edge(sqlgraph.O2M, false, poll.OptionsTable, poll.OptionsColumn),
                )
                fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
                return fromU, nil</span>
        }
        <span class="cov0" title="0">return query</span>
}

// QueryVotes chains the current query on the "votes" edge.
func (_q *PollQuery) QueryVotes() *VoteQuery <span class="cov0" title="0">{
        query := (&amp;VoteClient{config: _q.config}).Query()
        query.path = func(ctx context.Context) (fromU *sql.Selector, err error) </span><span class="cov0" title="0">{
                if err := _q.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">selector := _q.sqlQuery(ctx)
                if err := selector.Err(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">step := sqlgraph.NewStep(
                        sqlgraph.From(poll.Table, poll.FieldID, selector),
                        sqlgraph.To(vote.Table, vote.FieldID),
                        sqlgraph.Edge(sqlgraph.O2M, false, poll.VotesTable, poll.VotesColumn),
                )
                fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
                return fromU, nil</span>
        }
        <span class="cov0" title="0">return query</span>
}

// First returns the first Poll entity from the query.
// Returns a *NotFoundError when no Poll was found.
func (_q *PollQuery) First(ctx context.Context) (*Poll, error) <span class="cov0" title="0">{
        nodes, err := _q.Limit(1).All(setContextOp(ctx, _q.ctx, ent.OpQueryFirst))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(nodes) == 0 </span><span class="cov0" title="0">{
                return nil, &amp;NotFoundError{poll.Label}
        }</span>
        <span class="cov0" title="0">return nodes[0], nil</span>
}

// FirstX is like First, but panics if an error occurs.
func (_q *PollQuery) FirstX(ctx context.Context) *Poll <span class="cov0" title="0">{
        node, err := _q.First(ctx)
        if err != nil &amp;&amp; !IsNotFound(err) </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return node</span>
}

// FirstID returns the first Poll ID from the query.
// Returns a *NotFoundError when no Poll ID was found.
func (_q *PollQuery) FirstID(ctx context.Context) (id int, err error) <span class="cov0" title="0">{
        var ids []int
        if ids, err = _q.Limit(1).IDs(setContextOp(ctx, _q.ctx, ent.OpQueryFirstID)); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if len(ids) == 0 </span><span class="cov0" title="0">{
                err = &amp;NotFoundError{poll.Label}
                return
        }</span>
        <span class="cov0" title="0">return ids[0], nil</span>
}

// FirstIDX is like FirstID, but panics if an error occurs.
func (_q *PollQuery) FirstIDX(ctx context.Context) int <span class="cov0" title="0">{
        id, err := _q.FirstID(ctx)
        if err != nil &amp;&amp; !IsNotFound(err) </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return id</span>
}

// Only returns a single Poll entity found by the query, ensuring it only returns one.
// Returns a *NotSingularError when more than one Poll entity is found.
// Returns a *NotFoundError when no Poll entities are found.
func (_q *PollQuery) Only(ctx context.Context) (*Poll, error) <span class="cov0" title="0">{
        nodes, err := _q.Limit(2).All(setContextOp(ctx, _q.ctx, ent.OpQueryOnly))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">switch len(nodes) </span>{
        case 1:<span class="cov0" title="0">
                return nodes[0], nil</span>
        case 0:<span class="cov0" title="0">
                return nil, &amp;NotFoundError{poll.Label}</span>
        default:<span class="cov0" title="0">
                return nil, &amp;NotSingularError{poll.Label}</span>
        }
}

// OnlyX is like Only, but panics if an error occurs.
func (_q *PollQuery) OnlyX(ctx context.Context) *Poll <span class="cov0" title="0">{
        node, err := _q.Only(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return node</span>
}

// OnlyID is like Only, but returns the only Poll ID in the query.
// Returns a *NotSingularError when more than one Poll ID is found.
// Returns a *NotFoundError when no entities are found.
func (_q *PollQuery) OnlyID(ctx context.Context) (id int, err error) <span class="cov0" title="0">{
        var ids []int
        if ids, err = _q.Limit(2).IDs(setContextOp(ctx, _q.ctx, ent.OpQueryOnlyID)); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">switch len(ids) </span>{
        case 1:<span class="cov0" title="0">
                id = ids[0]</span>
        case 0:<span class="cov0" title="0">
                err = &amp;NotFoundError{poll.Label}</span>
        default:<span class="cov0" title="0">
                err = &amp;NotSingularError{poll.Label}</span>
        }
        <span class="cov0" title="0">return</span>
}

// OnlyIDX is like OnlyID, but panics if an error occurs.
func (_q *PollQuery) OnlyIDX(ctx context.Context) int <span class="cov0" title="0">{
        id, err := _q.OnlyID(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return id</span>
}

// All executes the query and returns a list of Polls.
func (_q *PollQuery) All(ctx context.Context) ([]*Poll, error) <span class="cov0" title="0">{
        ctx = setContextOp(ctx, _q.ctx, ent.OpQueryAll)
        if err := _q.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">qr := querierAll[[]*Poll, *PollQuery]()
        return withInterceptors[[]*Poll](ctx, _q, qr, _q.inters)</span>
}

// AllX is like All, but panics if an error occurs.
func (_q *PollQuery) AllX(ctx context.Context) []*Poll <span class="cov0" title="0">{
        nodes, err := _q.All(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return nodes</span>
}

// IDs executes the query and returns a list of Poll IDs.
func (_q *PollQuery) IDs(ctx context.Context) (ids []int, err error) <span class="cov0" title="0">{
        if _q.ctx.Unique == nil &amp;&amp; _q.path != nil </span><span class="cov0" title="0">{
                _q.Unique(true)
        }</span>
        <span class="cov0" title="0">ctx = setContextOp(ctx, _q.ctx, ent.OpQueryIDs)
        if err = _q.Select(poll.FieldID).Scan(ctx, &amp;ids); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ids, nil</span>
}

// IDsX is like IDs, but panics if an error occurs.
func (_q *PollQuery) IDsX(ctx context.Context) []int <span class="cov0" title="0">{
        ids, err := _q.IDs(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return ids</span>
}

// Count returns the count of the given query.
func (_q *PollQuery) Count(ctx context.Context) (int, error) <span class="cov0" title="0">{
        ctx = setContextOp(ctx, _q.ctx, ent.OpQueryCount)
        if err := _q.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return withInterceptors[int](ctx, _q, querierCount[*PollQuery](), _q.inters)</span>
}

// CountX is like Count, but panics if an error occurs.
func (_q *PollQuery) CountX(ctx context.Context) int <span class="cov0" title="0">{
        count, err := _q.Count(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return count</span>
}

// Exist returns true if the query has elements in the graph.
func (_q *PollQuery) Exist(ctx context.Context) (bool, error) <span class="cov0" title="0">{
        ctx = setContextOp(ctx, _q.ctx, ent.OpQueryExist)
        switch _, err := _q.FirstID(ctx); </span>{
        case IsNotFound(err):<span class="cov0" title="0">
                return false, nil</span>
        case err != nil:<span class="cov0" title="0">
                return false, fmt.Errorf("ent: check existence: %w", err)</span>
        default:<span class="cov0" title="0">
                return true, nil</span>
        }
}

// ExistX is like Exist, but panics if an error occurs.
func (_q *PollQuery) ExistX(ctx context.Context) bool <span class="cov0" title="0">{
        exist, err := _q.Exist(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return exist</span>
}

// Clone returns a duplicate of the PollQuery builder, including all associated steps. It can be
// used to prepare common query builders and use them differently after the clone is made.
func (_q *PollQuery) Clone() *PollQuery <span class="cov0" title="0">{
        if _q == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;PollQuery{
                config:      _q.config,
                ctx:         _q.ctx.Clone(),
                order:       append([]poll.OrderOption{}, _q.order...),
                inters:      append([]Interceptor{}, _q.inters...),
                predicates:  append([]predicate.Poll{}, _q.predicates...),
                withOwner:   _q.withOwner.Clone(),
                withOptions: _q.withOptions.Clone(),
                withVotes:   _q.withVotes.Clone(),
                // clone intermediate query.
                sql:  _q.sql.Clone(),
                path: _q.path,
        }</span>
}

// WithOwner tells the query-builder to eager-load the nodes that are connected to
// the "owner" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *PollQuery) WithOwner(opts ...func(*UserQuery)) *PollQuery <span class="cov0" title="0">{
        query := (&amp;UserClient{config: _q.config}).Query()
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(query)
        }</span>
        <span class="cov0" title="0">_q.withOwner = query
        return _q</span>
}

// WithOptions tells the query-builder to eager-load the nodes that are connected to
// the "options" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *PollQuery) WithOptions(opts ...func(*PollOptionQuery)) *PollQuery <span class="cov0" title="0">{
        query := (&amp;PollOptionClient{config: _q.config}).Query()
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(query)
        }</span>
        <span class="cov0" title="0">_q.withOptions = query
        return _q</span>
}

// WithVotes tells the query-builder to eager-load the nodes that are connected to
// the "votes" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *PollQuery) WithVotes(opts ...func(*VoteQuery)) *PollQuery <span class="cov0" title="0">{
        query := (&amp;VoteClient{config: _q.config}).Query()
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(query)
        }</span>
        <span class="cov0" title="0">_q.withVotes = query
        return _q</span>
}

// GroupBy is used to group vertices by one or more fields/columns.
// It is often used with aggregate functions, like: count, max, mean, min, sum.
//
// Example:
//
//        var v []struct {
//                OwnerID int `json:"owner_id,omitempty"`
//                Count int `json:"count,omitempty"`
//        }
//
//        client.Poll.Query().
//                GroupBy(poll.FieldOwnerID).
//                Aggregate(ent.Count()).
//                Scan(ctx, &amp;v)
func (_q *PollQuery) GroupBy(field string, fields ...string) *PollGroupBy <span class="cov0" title="0">{
        _q.ctx.Fields = append([]string{field}, fields...)
        grbuild := &amp;PollGroupBy{build: _q}
        grbuild.flds = &amp;_q.ctx.Fields
        grbuild.label = poll.Label
        grbuild.scan = grbuild.Scan
        return grbuild
}</span>

// Select allows the selection one or more fields/columns for the given query,
// instead of selecting all fields in the entity.
//
// Example:
//
//        var v []struct {
//                OwnerID int `json:"owner_id,omitempty"`
//        }
//
//        client.Poll.Query().
//                Select(poll.FieldOwnerID).
//                Scan(ctx, &amp;v)
func (_q *PollQuery) Select(fields ...string) *PollSelect <span class="cov0" title="0">{
        _q.ctx.Fields = append(_q.ctx.Fields, fields...)
        sbuild := &amp;PollSelect{PollQuery: _q}
        sbuild.label = poll.Label
        sbuild.flds, sbuild.scan = &amp;_q.ctx.Fields, sbuild.Scan
        return sbuild
}</span>

// Aggregate returns a PollSelect configured with the given aggregations.
func (_q *PollQuery) Aggregate(fns ...AggregateFunc) *PollSelect <span class="cov0" title="0">{
        return _q.Select().Aggregate(fns...)
}</span>

func (_q *PollQuery) prepareQuery(ctx context.Context) error <span class="cov0" title="0">{
        for _, inter := range _q.inters </span><span class="cov0" title="0">{
                if inter == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("ent: uninitialized interceptor (forgotten import ent/runtime?)")
                }</span>
                <span class="cov0" title="0">if trv, ok := inter.(Traverser); ok </span><span class="cov0" title="0">{
                        if err := trv.Traverse(ctx, _q); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov0" title="0">for _, f := range _q.ctx.Fields </span><span class="cov0" title="0">{
                if !poll.ValidColumn(f) </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
                }</span>
        }
        <span class="cov0" title="0">if _q.path != nil </span><span class="cov0" title="0">{
                prev, err := _q.path(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">_q.sql = prev</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (_q *PollQuery) sqlAll(ctx context.Context, hooks ...queryHook) ([]*Poll, error) <span class="cov0" title="0">{
        var (
                nodes       = []*Poll{}
                _spec       = _q.querySpec()
                loadedTypes = [3]bool{
                        _q.withOwner != nil,
                        _q.withOptions != nil,
                        _q.withVotes != nil,
                }
        )
        _spec.ScanValues = func(columns []string) ([]any, error) </span><span class="cov0" title="0">{
                return (*Poll).scanValues(nil, columns)
        }</span>
        <span class="cov0" title="0">_spec.Assign = func(columns []string, values []any) error </span><span class="cov0" title="0">{
                node := &amp;Poll{config: _q.config}
                nodes = append(nodes, node)
                node.Edges.loadedTypes = loadedTypes
                return node.assignValues(columns, values)
        }</span>
        <span class="cov0" title="0">for i := range hooks </span><span class="cov0" title="0">{
                hooks[i](ctx, _spec)
        }</span>
        <span class="cov0" title="0">if err := sqlgraph.QueryNodes(ctx, _q.driver, _spec); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(nodes) == 0 </span><span class="cov0" title="0">{
                return nodes, nil
        }</span>
        <span class="cov0" title="0">if query := _q.withOwner; query != nil </span><span class="cov0" title="0">{
                if err := _q.loadOwner(ctx, query, nodes, nil,
                        func(n *Poll, e *User) </span><span class="cov0" title="0">{ n.Edges.Owner = e }</span>); err != nil <span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">if query := _q.withOptions; query != nil </span><span class="cov0" title="0">{
                if err := _q.loadOptions(ctx, query, nodes,
                        func(n *Poll) </span><span class="cov0" title="0">{ n.Edges.Options = []*PollOption{} }</span>,
                        func(n *Poll, e *PollOption) <span class="cov0" title="0">{ n.Edges.Options = append(n.Edges.Options, e) }</span>); err != nil <span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">if query := _q.withVotes; query != nil </span><span class="cov0" title="0">{
                if err := _q.loadVotes(ctx, query, nodes,
                        func(n *Poll) </span><span class="cov0" title="0">{ n.Edges.Votes = []*Vote{} }</span>,
                        func(n *Poll, e *Vote) <span class="cov0" title="0">{ n.Edges.Votes = append(n.Edges.Votes, e) }</span>); err != nil <span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return nodes, nil</span>
}

func (_q *PollQuery) loadOwner(ctx context.Context, query *UserQuery, nodes []*Poll, init func(*Poll), assign func(*Poll, *User)) error <span class="cov0" title="0">{
        ids := make([]int, 0, len(nodes))
        nodeids := make(map[int][]*Poll)
        for i := range nodes </span><span class="cov0" title="0">{
                fk := nodes[i].OwnerID
                if _, ok := nodeids[fk]; !ok </span><span class="cov0" title="0">{
                        ids = append(ids, fk)
                }</span>
                <span class="cov0" title="0">nodeids[fk] = append(nodeids[fk], nodes[i])</span>
        }
        <span class="cov0" title="0">if len(ids) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">query.Where(user.IDIn(ids...))
        neighbors, err := query.All(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, n := range neighbors </span><span class="cov0" title="0">{
                nodes, ok := nodeids[n.ID]
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf(`unexpected foreign-key "owner_id" returned %v`, n.ID)
                }</span>
                <span class="cov0" title="0">for i := range nodes </span><span class="cov0" title="0">{
                        assign(nodes[i], n)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
func (_q *PollQuery) loadOptions(ctx context.Context, query *PollOptionQuery, nodes []*Poll, init func(*Poll), assign func(*Poll, *PollOption)) error <span class="cov0" title="0">{
        fks := make([]driver.Value, 0, len(nodes))
        nodeids := make(map[int]*Poll)
        for i := range nodes </span><span class="cov0" title="0">{
                fks = append(fks, nodes[i].ID)
                nodeids[nodes[i].ID] = nodes[i]
                if init != nil </span><span class="cov0" title="0">{
                        init(nodes[i])
                }</span>
        }
        <span class="cov0" title="0">if len(query.ctx.Fields) &gt; 0 </span><span class="cov0" title="0">{
                query.ctx.AppendFieldOnce(polloption.FieldPollID)
        }</span>
        <span class="cov0" title="0">query.Where(predicate.PollOption(func(s *sql.Selector) </span><span class="cov0" title="0">{
                s.Where(sql.InValues(s.C(poll.OptionsColumn), fks...))
        }</span>))
        <span class="cov0" title="0">neighbors, err := query.All(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, n := range neighbors </span><span class="cov0" title="0">{
                fk := n.PollID
                node, ok := nodeids[fk]
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf(`unexpected referenced foreign-key "poll_id" returned %v for node %v`, fk, n.ID)
                }</span>
                <span class="cov0" title="0">assign(node, n)</span>
        }
        <span class="cov0" title="0">return nil</span>
}
func (_q *PollQuery) loadVotes(ctx context.Context, query *VoteQuery, nodes []*Poll, init func(*Poll), assign func(*Poll, *Vote)) error <span class="cov0" title="0">{
        fks := make([]driver.Value, 0, len(nodes))
        nodeids := make(map[int]*Poll)
        for i := range nodes </span><span class="cov0" title="0">{
                fks = append(fks, nodes[i].ID)
                nodeids[nodes[i].ID] = nodes[i]
                if init != nil </span><span class="cov0" title="0">{
                        init(nodes[i])
                }</span>
        }
        <span class="cov0" title="0">if len(query.ctx.Fields) &gt; 0 </span><span class="cov0" title="0">{
                query.ctx.AppendFieldOnce(vote.FieldPollID)
        }</span>
        <span class="cov0" title="0">query.Where(predicate.Vote(func(s *sql.Selector) </span><span class="cov0" title="0">{
                s.Where(sql.InValues(s.C(poll.VotesColumn), fks...))
        }</span>))
        <span class="cov0" title="0">neighbors, err := query.All(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, n := range neighbors </span><span class="cov0" title="0">{
                fk := n.PollID
                node, ok := nodeids[fk]
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf(`unexpected referenced foreign-key "poll_id" returned %v for node %v`, fk, n.ID)
                }</span>
                <span class="cov0" title="0">assign(node, n)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (_q *PollQuery) sqlCount(ctx context.Context) (int, error) <span class="cov0" title="0">{
        _spec := _q.querySpec()
        _spec.Node.Columns = _q.ctx.Fields
        if len(_q.ctx.Fields) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Unique = _q.ctx.Unique != nil &amp;&amp; *_q.ctx.Unique
        }</span>
        <span class="cov0" title="0">return sqlgraph.CountNodes(ctx, _q.driver, _spec)</span>
}

func (_q *PollQuery) querySpec() *sqlgraph.QuerySpec <span class="cov0" title="0">{
        _spec := sqlgraph.NewQuerySpec(poll.Table, poll.Columns, sqlgraph.NewFieldSpec(poll.FieldID, field.TypeInt))
        _spec.From = _q.sql
        if unique := _q.ctx.Unique; unique != nil </span><span class="cov0" title="0">{
                _spec.Unique = *unique
        }</span> else<span class="cov0" title="0"> if _q.path != nil </span><span class="cov0" title="0">{
                _spec.Unique = true
        }</span>
        <span class="cov0" title="0">if fields := _q.ctx.Fields; len(fields) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Node.Columns = make([]string, 0, len(fields))
                _spec.Node.Columns = append(_spec.Node.Columns, poll.FieldID)
                for i := range fields </span><span class="cov0" title="0">{
                        if fields[i] != poll.FieldID </span><span class="cov0" title="0">{
                                _spec.Node.Columns = append(_spec.Node.Columns, fields[i])
                        }</span>
                }
                <span class="cov0" title="0">if _q.withOwner != nil </span><span class="cov0" title="0">{
                        _spec.Node.AddColumnOnce(poll.FieldOwnerID)
                }</span>
        }
        <span class="cov0" title="0">if ps := _q.predicates; len(ps) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Predicate = func(selector *sql.Selector) </span><span class="cov0" title="0">{
                        for i := range ps </span><span class="cov0" title="0">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov0" title="0">if limit := _q.ctx.Limit; limit != nil </span><span class="cov0" title="0">{
                _spec.Limit = *limit
        }</span>
        <span class="cov0" title="0">if offset := _q.ctx.Offset; offset != nil </span><span class="cov0" title="0">{
                _spec.Offset = *offset
        }</span>
        <span class="cov0" title="0">if ps := _q.order; len(ps) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Order = func(selector *sql.Selector) </span><span class="cov0" title="0">{
                        for i := range ps </span><span class="cov0" title="0">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov0" title="0">return _spec</span>
}

func (_q *PollQuery) sqlQuery(ctx context.Context) *sql.Selector <span class="cov0" title="0">{
        builder := sql.Dialect(_q.driver.Dialect())
        t1 := builder.Table(poll.Table)
        columns := _q.ctx.Fields
        if len(columns) == 0 </span><span class="cov0" title="0">{
                columns = poll.Columns
        }</span>
        <span class="cov0" title="0">selector := builder.Select(t1.Columns(columns...)...).From(t1)
        if _q.sql != nil </span><span class="cov0" title="0">{
                selector = _q.sql
                selector.Select(selector.Columns(columns...)...)
        }</span>
        <span class="cov0" title="0">if _q.ctx.Unique != nil &amp;&amp; *_q.ctx.Unique </span><span class="cov0" title="0">{
                selector.Distinct()
        }</span>
        <span class="cov0" title="0">for _, p := range _q.predicates </span><span class="cov0" title="0">{
                p(selector)
        }</span>
        <span class="cov0" title="0">for _, p := range _q.order </span><span class="cov0" title="0">{
                p(selector)
        }</span>
        <span class="cov0" title="0">if offset := _q.ctx.Offset; offset != nil </span><span class="cov0" title="0">{
                // limit is mandatory for offset clause. We start
                // with default value, and override it below if needed.
                selector.Offset(*offset).Limit(math.MaxInt32)
        }</span>
        <span class="cov0" title="0">if limit := _q.ctx.Limit; limit != nil </span><span class="cov0" title="0">{
                selector.Limit(*limit)
        }</span>
        <span class="cov0" title="0">return selector</span>
}

// PollGroupBy is the group-by builder for Poll entities.
type PollGroupBy struct {
        selector
        build *PollQuery
}

// Aggregate adds the given aggregation functions to the group-by query.
func (_g *PollGroupBy) Aggregate(fns ...AggregateFunc) *PollGroupBy <span class="cov0" title="0">{
        _g.fns = append(_g.fns, fns...)
        return _g
}</span>

// Scan applies the selector query and scans the result into the given value.
func (_g *PollGroupBy) Scan(ctx context.Context, v any) error <span class="cov0" title="0">{
        ctx = setContextOp(ctx, _g.build.ctx, ent.OpQueryGroupBy)
        if err := _g.build.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return scanWithInterceptors[*PollQuery, *PollGroupBy](ctx, _g.build, _g, _g.build.inters, v)</span>
}

func (_g *PollGroupBy) sqlScan(ctx context.Context, root *PollQuery, v any) error <span class="cov0" title="0">{
        selector := root.sqlQuery(ctx).Select()
        aggregation := make([]string, 0, len(_g.fns))
        for _, fn := range _g.fns </span><span class="cov0" title="0">{
                aggregation = append(aggregation, fn(selector))
        }</span>
        <span class="cov0" title="0">if len(selector.SelectedColumns()) == 0 </span><span class="cov0" title="0">{
                columns := make([]string, 0, len(*_g.flds)+len(_g.fns))
                for _, f := range *_g.flds </span><span class="cov0" title="0">{
                        columns = append(columns, selector.C(f))
                }</span>
                <span class="cov0" title="0">columns = append(columns, aggregation...)
                selector.Select(columns...)</span>
        }
        <span class="cov0" title="0">selector.GroupBy(selector.Columns(*_g.flds...)...)
        if err := selector.Err(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">rows := &amp;sql.Rows{}
        query, args := selector.Query()
        if err := _g.build.driver.Query(ctx, query, args, rows); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        return sql.ScanSlice(rows, v)</span>
}

// PollSelect is the builder for selecting fields of Poll entities.
type PollSelect struct {
        *PollQuery
        selector
}

// Aggregate adds the given aggregation functions to the selector query.
func (_s *PollSelect) Aggregate(fns ...AggregateFunc) *PollSelect <span class="cov0" title="0">{
        _s.fns = append(_s.fns, fns...)
        return _s
}</span>

// Scan applies the selector query and scans the result into the given value.
func (_s *PollSelect) Scan(ctx context.Context, v any) error <span class="cov0" title="0">{
        ctx = setContextOp(ctx, _s.ctx, ent.OpQuerySelect)
        if err := _s.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return scanWithInterceptors[*PollQuery, *PollSelect](ctx, _s.PollQuery, _s, _s.inters, v)</span>
}

func (_s *PollSelect) sqlScan(ctx context.Context, root *PollQuery, v any) error <span class="cov0" title="0">{
        selector := root.sqlQuery(ctx)
        aggregation := make([]string, 0, len(_s.fns))
        for _, fn := range _s.fns </span><span class="cov0" title="0">{
                aggregation = append(aggregation, fn(selector))
        }</span>
        <span class="cov0" title="0">switch n := len(*_s.selector.flds); </span>{
        case n == 0 &amp;&amp; len(aggregation) &gt; 0:<span class="cov0" title="0">
                selector.Select(aggregation...)</span>
        case n != 0 &amp;&amp; len(aggregation) &gt; 0:<span class="cov0" title="0">
                selector.AppendSelect(aggregation...)</span>
        }
        <span class="cov0" title="0">rows := &amp;sql.Rows{}
        query, args := selector.Query()
        if err := _s.driver.Query(ctx, query, args, rows); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        return sql.ScanSlice(rows, v)</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "context"
        "errors"
        "fmt"

        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
        "entgo.io/ent/schema/field"
        "github.com/ivankorhner/polling-app/internal/ent/poll"
        "github.com/ivankorhner/polling-app/internal/ent/polloption"
        "github.com/ivankorhner/polling-app/internal/ent/predicate"
        "github.com/ivankorhner/polling-app/internal/ent/user"
        "github.com/ivankorhner/polling-app/internal/ent/vote"
)

// PollUpdate is the builder for updating Poll entities.
type PollUpdate struct {
        config
        hooks    []Hook
        mutation *PollMutation
}

// Where appends a list predicates to the PollUpdate builder.
func (_u *PollUpdate) Where(ps ...predicate.Poll) *PollUpdate <span class="cov0" title="0">{
        _u.mutation.Where(ps...)
        return _u
}</span>

// SetOwnerID sets the "owner_id" field.
func (_u *PollUpdate) SetOwnerID(v int) *PollUpdate <span class="cov0" title="0">{
        _u.mutation.SetOwnerID(v)
        return _u
}</span>

// SetNillableOwnerID sets the "owner_id" field if the given value is not nil.
func (_u *PollUpdate) SetNillableOwnerID(v *int) *PollUpdate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetOwnerID(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// SetTitle sets the "title" field.
func (_u *PollUpdate) SetTitle(v string) *PollUpdate <span class="cov0" title="0">{
        _u.mutation.SetTitle(v)
        return _u
}</span>

// SetNillableTitle sets the "title" field if the given value is not nil.
func (_u *PollUpdate) SetNillableTitle(v *string) *PollUpdate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetTitle(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// SetOwner sets the "owner" edge to the User entity.
func (_u *PollUpdate) SetOwner(v *User) *PollUpdate <span class="cov0" title="0">{
        return _u.SetOwnerID(v.ID)
}</span>

// AddOptionIDs adds the "options" edge to the PollOption entity by IDs.
func (_u *PollUpdate) AddOptionIDs(ids ...int) *PollUpdate <span class="cov0" title="0">{
        _u.mutation.AddOptionIDs(ids...)
        return _u
}</span>

// AddOptions adds the "options" edges to the PollOption entity.
func (_u *PollUpdate) AddOptions(v ...*PollOption) *PollUpdate <span class="cov0" title="0">{
        ids := make([]int, len(v))
        for i := range v </span><span class="cov0" title="0">{
                ids[i] = v[i].ID
        }</span>
        <span class="cov0" title="0">return _u.AddOptionIDs(ids...)</span>
}

// AddVoteIDs adds the "votes" edge to the Vote entity by IDs.
func (_u *PollUpdate) AddVoteIDs(ids ...int) *PollUpdate <span class="cov0" title="0">{
        _u.mutation.AddVoteIDs(ids...)
        return _u
}</span>

// AddVotes adds the "votes" edges to the Vote entity.
func (_u *PollUpdate) AddVotes(v ...*Vote) *PollUpdate <span class="cov0" title="0">{
        ids := make([]int, len(v))
        for i := range v </span><span class="cov0" title="0">{
                ids[i] = v[i].ID
        }</span>
        <span class="cov0" title="0">return _u.AddVoteIDs(ids...)</span>
}

// Mutation returns the PollMutation object of the builder.
func (_u *PollUpdate) Mutation() *PollMutation <span class="cov0" title="0">{
        return _u.mutation
}</span>

// ClearOwner clears the "owner" edge to the User entity.
func (_u *PollUpdate) ClearOwner() *PollUpdate <span class="cov0" title="0">{
        _u.mutation.ClearOwner()
        return _u
}</span>

// ClearOptions clears all "options" edges to the PollOption entity.
func (_u *PollUpdate) ClearOptions() *PollUpdate <span class="cov0" title="0">{
        _u.mutation.ClearOptions()
        return _u
}</span>

// RemoveOptionIDs removes the "options" edge to PollOption entities by IDs.
func (_u *PollUpdate) RemoveOptionIDs(ids ...int) *PollUpdate <span class="cov0" title="0">{
        _u.mutation.RemoveOptionIDs(ids...)
        return _u
}</span>

// RemoveOptions removes "options" edges to PollOption entities.
func (_u *PollUpdate) RemoveOptions(v ...*PollOption) *PollUpdate <span class="cov0" title="0">{
        ids := make([]int, len(v))
        for i := range v </span><span class="cov0" title="0">{
                ids[i] = v[i].ID
        }</span>
        <span class="cov0" title="0">return _u.RemoveOptionIDs(ids...)</span>
}

// ClearVotes clears all "votes" edges to the Vote entity.
func (_u *PollUpdate) ClearVotes() *PollUpdate <span class="cov0" title="0">{
        _u.mutation.ClearVotes()
        return _u
}</span>

// RemoveVoteIDs removes the "votes" edge to Vote entities by IDs.
func (_u *PollUpdate) RemoveVoteIDs(ids ...int) *PollUpdate <span class="cov0" title="0">{
        _u.mutation.RemoveVoteIDs(ids...)
        return _u
}</span>

// RemoveVotes removes "votes" edges to Vote entities.
func (_u *PollUpdate) RemoveVotes(v ...*Vote) *PollUpdate <span class="cov0" title="0">{
        ids := make([]int, len(v))
        for i := range v </span><span class="cov0" title="0">{
                ids[i] = v[i].ID
        }</span>
        <span class="cov0" title="0">return _u.RemoveVoteIDs(ids...)</span>
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (_u *PollUpdate) Save(ctx context.Context) (int, error) <span class="cov0" title="0">{
        return withHooks(ctx, _u.sqlSave, _u.mutation, _u.hooks)
}</span>

// SaveX is like Save, but panics if an error occurs.
func (_u *PollUpdate) SaveX(ctx context.Context) int <span class="cov0" title="0">{
        affected, err := _u.Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return affected</span>
}

// Exec executes the query.
func (_u *PollUpdate) Exec(ctx context.Context) error <span class="cov0" title="0">{
        _, err := _u.Save(ctx)
        return err
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (_u *PollUpdate) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := _u.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// check runs all checks and user-defined validators on the builder.
func (_u *PollUpdate) check() error <span class="cov0" title="0">{
        if v, ok := _u.mutation.Title(); ok </span><span class="cov0" title="0">{
                if err := poll.TitleValidator(v); err != nil </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: "title", err: fmt.Errorf(`ent: validator failed for field "Poll.title": %w`, err)}
                }</span>
        }
        <span class="cov0" title="0">if _u.mutation.OwnerCleared() &amp;&amp; len(_u.mutation.OwnerIDs()) &gt; 0 </span><span class="cov0" title="0">{
                return errors.New(`ent: clearing a required unique edge "Poll.owner"`)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (_u *PollUpdate) sqlSave(ctx context.Context) (_node int, err error) <span class="cov0" title="0">{
        if err := _u.check(); err != nil </span><span class="cov0" title="0">{
                return _node, err
        }</span>
        <span class="cov0" title="0">_spec := sqlgraph.NewUpdateSpec(poll.Table, poll.Columns, sqlgraph.NewFieldSpec(poll.FieldID, field.TypeInt))
        if ps := _u.mutation.predicates; len(ps) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Predicate = func(selector *sql.Selector) </span><span class="cov0" title="0">{
                        for i := range ps </span><span class="cov0" title="0">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov0" title="0">if value, ok := _u.mutation.Title(); ok </span><span class="cov0" title="0">{
                _spec.SetField(poll.FieldTitle, field.TypeString, value)
        }</span>
        <span class="cov0" title="0">if _u.mutation.OwnerCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2O,
                        Inverse: true,
                        Table:   poll.OwnerTable,
                        Columns: []string{poll.OwnerColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeInt),
                        },
                }
                _spec.Edges.Clear = append(_spec.Edges.Clear, edge)
        }</span>
        <span class="cov0" title="0">if nodes := _u.mutation.OwnerIDs(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2O,
                        Inverse: true,
                        Table:   poll.OwnerTable,
                        Columns: []string{poll.OwnerColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeInt),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges.Add = append(_spec.Edges.Add, edge)</span>
        }
        <span class="cov0" title="0">if _u.mutation.OptionsCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   poll.OptionsTable,
                        Columns: []string{poll.OptionsColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(polloption.FieldID, field.TypeInt),
                        },
                }
                _spec.Edges.Clear = append(_spec.Edges.Clear, edge)
        }</span>
        <span class="cov0" title="0">if nodes := _u.mutation.RemovedOptionsIDs(); len(nodes) &gt; 0 &amp;&amp; !_u.mutation.OptionsCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   poll.OptionsTable,
                        Columns: []string{poll.OptionsColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(polloption.FieldID, field.TypeInt),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges.Clear = append(_spec.Edges.Clear, edge)</span>
        }
        <span class="cov0" title="0">if nodes := _u.mutation.OptionsIDs(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   poll.OptionsTable,
                        Columns: []string{poll.OptionsColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(polloption.FieldID, field.TypeInt),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges.Add = append(_spec.Edges.Add, edge)</span>
        }
        <span class="cov0" title="0">if _u.mutation.VotesCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   poll.VotesTable,
                        Columns: []string{poll.VotesColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(vote.FieldID, field.TypeInt),
                        },
                }
                _spec.Edges.Clear = append(_spec.Edges.Clear, edge)
        }</span>
        <span class="cov0" title="0">if nodes := _u.mutation.RemovedVotesIDs(); len(nodes) &gt; 0 &amp;&amp; !_u.mutation.VotesCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   poll.VotesTable,
                        Columns: []string{poll.VotesColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(vote.FieldID, field.TypeInt),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges.Clear = append(_spec.Edges.Clear, edge)</span>
        }
        <span class="cov0" title="0">if nodes := _u.mutation.VotesIDs(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   poll.VotesTable,
                        Columns: []string{poll.VotesColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(vote.FieldID, field.TypeInt),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges.Add = append(_spec.Edges.Add, edge)</span>
        }
        <span class="cov0" title="0">if _node, err = sqlgraph.UpdateNodes(ctx, _u.driver, _spec); err != nil </span><span class="cov0" title="0">{
                if _, ok := err.(*sqlgraph.NotFoundError); ok </span><span class="cov0" title="0">{
                        err = &amp;NotFoundError{poll.Label}
                }</span> else<span class="cov0" title="0"> if sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                        err = &amp;ConstraintError{msg: err.Error(), wrap: err}
                }</span>
                <span class="cov0" title="0">return 0, err</span>
        }
        <span class="cov0" title="0">_u.mutation.done = true
        return _node, nil</span>
}

// PollUpdateOne is the builder for updating a single Poll entity.
type PollUpdateOne struct {
        config
        fields   []string
        hooks    []Hook
        mutation *PollMutation
}

// SetOwnerID sets the "owner_id" field.
func (_u *PollUpdateOne) SetOwnerID(v int) *PollUpdateOne <span class="cov0" title="0">{
        _u.mutation.SetOwnerID(v)
        return _u
}</span>

// SetNillableOwnerID sets the "owner_id" field if the given value is not nil.
func (_u *PollUpdateOne) SetNillableOwnerID(v *int) *PollUpdateOne <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetOwnerID(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// SetTitle sets the "title" field.
func (_u *PollUpdateOne) SetTitle(v string) *PollUpdateOne <span class="cov0" title="0">{
        _u.mutation.SetTitle(v)
        return _u
}</span>

// SetNillableTitle sets the "title" field if the given value is not nil.
func (_u *PollUpdateOne) SetNillableTitle(v *string) *PollUpdateOne <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetTitle(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// SetOwner sets the "owner" edge to the User entity.
func (_u *PollUpdateOne) SetOwner(v *User) *PollUpdateOne <span class="cov0" title="0">{
        return _u.SetOwnerID(v.ID)
}</span>

// AddOptionIDs adds the "options" edge to the PollOption entity by IDs.
func (_u *PollUpdateOne) AddOptionIDs(ids ...int) *PollUpdateOne <span class="cov0" title="0">{
        _u.mutation.AddOptionIDs(ids...)
        return _u
}</span>

// AddOptions adds the "options" edges to the PollOption entity.
func (_u *PollUpdateOne) AddOptions(v ...*PollOption) *PollUpdateOne <span class="cov0" title="0">{
        ids := make([]int, len(v))
        for i := range v </span><span class="cov0" title="0">{
                ids[i] = v[i].ID
        }</span>
        <span class="cov0" title="0">return _u.AddOptionIDs(ids...)</span>
}

// AddVoteIDs adds the "votes" edge to the Vote entity by IDs.
func (_u *PollUpdateOne) AddVoteIDs(ids ...int) *PollUpdateOne <span class="cov0" title="0">{
        _u.mutation.AddVoteIDs(ids...)
        return _u
}</span>

// AddVotes adds the "votes" edges to the Vote entity.
func (_u *PollUpdateOne) AddVotes(v ...*Vote) *PollUpdateOne <span class="cov0" title="0">{
        ids := make([]int, len(v))
        for i := range v </span><span class="cov0" title="0">{
                ids[i] = v[i].ID
        }</span>
        <span class="cov0" title="0">return _u.AddVoteIDs(ids...)</span>
}

// Mutation returns the PollMutation object of the builder.
func (_u *PollUpdateOne) Mutation() *PollMutation <span class="cov0" title="0">{
        return _u.mutation
}</span>

// ClearOwner clears the "owner" edge to the User entity.
func (_u *PollUpdateOne) ClearOwner() *PollUpdateOne <span class="cov0" title="0">{
        _u.mutation.ClearOwner()
        return _u
}</span>

// ClearOptions clears all "options" edges to the PollOption entity.
func (_u *PollUpdateOne) ClearOptions() *PollUpdateOne <span class="cov0" title="0">{
        _u.mutation.ClearOptions()
        return _u
}</span>

// RemoveOptionIDs removes the "options" edge to PollOption entities by IDs.
func (_u *PollUpdateOne) RemoveOptionIDs(ids ...int) *PollUpdateOne <span class="cov0" title="0">{
        _u.mutation.RemoveOptionIDs(ids...)
        return _u
}</span>

// RemoveOptions removes "options" edges to PollOption entities.
func (_u *PollUpdateOne) RemoveOptions(v ...*PollOption) *PollUpdateOne <span class="cov0" title="0">{
        ids := make([]int, len(v))
        for i := range v </span><span class="cov0" title="0">{
                ids[i] = v[i].ID
        }</span>
        <span class="cov0" title="0">return _u.RemoveOptionIDs(ids...)</span>
}

// ClearVotes clears all "votes" edges to the Vote entity.
func (_u *PollUpdateOne) ClearVotes() *PollUpdateOne <span class="cov0" title="0">{
        _u.mutation.ClearVotes()
        return _u
}</span>

// RemoveVoteIDs removes the "votes" edge to Vote entities by IDs.
func (_u *PollUpdateOne) RemoveVoteIDs(ids ...int) *PollUpdateOne <span class="cov0" title="0">{
        _u.mutation.RemoveVoteIDs(ids...)
        return _u
}</span>

// RemoveVotes removes "votes" edges to Vote entities.
func (_u *PollUpdateOne) RemoveVotes(v ...*Vote) *PollUpdateOne <span class="cov0" title="0">{
        ids := make([]int, len(v))
        for i := range v </span><span class="cov0" title="0">{
                ids[i] = v[i].ID
        }</span>
        <span class="cov0" title="0">return _u.RemoveVoteIDs(ids...)</span>
}

// Where appends a list predicates to the PollUpdate builder.
func (_u *PollUpdateOne) Where(ps ...predicate.Poll) *PollUpdateOne <span class="cov0" title="0">{
        _u.mutation.Where(ps...)
        return _u
}</span>

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (_u *PollUpdateOne) Select(field string, fields ...string) *PollUpdateOne <span class="cov0" title="0">{
        _u.fields = append([]string{field}, fields...)
        return _u
}</span>

// Save executes the query and returns the updated Poll entity.
func (_u *PollUpdateOne) Save(ctx context.Context) (*Poll, error) <span class="cov0" title="0">{
        return withHooks(ctx, _u.sqlSave, _u.mutation, _u.hooks)
}</span>

// SaveX is like Save, but panics if an error occurs.
func (_u *PollUpdateOne) SaveX(ctx context.Context) *Poll <span class="cov0" title="0">{
        node, err := _u.Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return node</span>
}

// Exec executes the query on the entity.
func (_u *PollUpdateOne) Exec(ctx context.Context) error <span class="cov0" title="0">{
        _, err := _u.Save(ctx)
        return err
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (_u *PollUpdateOne) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := _u.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// check runs all checks and user-defined validators on the builder.
func (_u *PollUpdateOne) check() error <span class="cov0" title="0">{
        if v, ok := _u.mutation.Title(); ok </span><span class="cov0" title="0">{
                if err := poll.TitleValidator(v); err != nil </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: "title", err: fmt.Errorf(`ent: validator failed for field "Poll.title": %w`, err)}
                }</span>
        }
        <span class="cov0" title="0">if _u.mutation.OwnerCleared() &amp;&amp; len(_u.mutation.OwnerIDs()) &gt; 0 </span><span class="cov0" title="0">{
                return errors.New(`ent: clearing a required unique edge "Poll.owner"`)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (_u *PollUpdateOne) sqlSave(ctx context.Context) (_node *Poll, err error) <span class="cov0" title="0">{
        if err := _u.check(); err != nil </span><span class="cov0" title="0">{
                return _node, err
        }</span>
        <span class="cov0" title="0">_spec := sqlgraph.NewUpdateSpec(poll.Table, poll.Columns, sqlgraph.NewFieldSpec(poll.FieldID, field.TypeInt))
        id, ok := _u.mutation.ID()
        if !ok </span><span class="cov0" title="0">{
                return nil, &amp;ValidationError{Name: "id", err: errors.New(`ent: missing "Poll.id" for update`)}
        }</span>
        <span class="cov0" title="0">_spec.Node.ID.Value = id
        if fields := _u.fields; len(fields) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Node.Columns = make([]string, 0, len(fields))
                _spec.Node.Columns = append(_spec.Node.Columns, poll.FieldID)
                for _, f := range fields </span><span class="cov0" title="0">{
                        if !poll.ValidColumn(f) </span><span class="cov0" title="0">{
                                return nil, &amp;ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
                        }</span>
                        <span class="cov0" title="0">if f != poll.FieldID </span><span class="cov0" title="0">{
                                _spec.Node.Columns = append(_spec.Node.Columns, f)
                        }</span>
                }
        }
        <span class="cov0" title="0">if ps := _u.mutation.predicates; len(ps) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Predicate = func(selector *sql.Selector) </span><span class="cov0" title="0">{
                        for i := range ps </span><span class="cov0" title="0">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov0" title="0">if value, ok := _u.mutation.Title(); ok </span><span class="cov0" title="0">{
                _spec.SetField(poll.FieldTitle, field.TypeString, value)
        }</span>
        <span class="cov0" title="0">if _u.mutation.OwnerCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2O,
                        Inverse: true,
                        Table:   poll.OwnerTable,
                        Columns: []string{poll.OwnerColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeInt),
                        },
                }
                _spec.Edges.Clear = append(_spec.Edges.Clear, edge)
        }</span>
        <span class="cov0" title="0">if nodes := _u.mutation.OwnerIDs(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2O,
                        Inverse: true,
                        Table:   poll.OwnerTable,
                        Columns: []string{poll.OwnerColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeInt),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges.Add = append(_spec.Edges.Add, edge)</span>
        }
        <span class="cov0" title="0">if _u.mutation.OptionsCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   poll.OptionsTable,
                        Columns: []string{poll.OptionsColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(polloption.FieldID, field.TypeInt),
                        },
                }
                _spec.Edges.Clear = append(_spec.Edges.Clear, edge)
        }</span>
        <span class="cov0" title="0">if nodes := _u.mutation.RemovedOptionsIDs(); len(nodes) &gt; 0 &amp;&amp; !_u.mutation.OptionsCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   poll.OptionsTable,
                        Columns: []string{poll.OptionsColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(polloption.FieldID, field.TypeInt),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges.Clear = append(_spec.Edges.Clear, edge)</span>
        }
        <span class="cov0" title="0">if nodes := _u.mutation.OptionsIDs(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   poll.OptionsTable,
                        Columns: []string{poll.OptionsColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(polloption.FieldID, field.TypeInt),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges.Add = append(_spec.Edges.Add, edge)</span>
        }
        <span class="cov0" title="0">if _u.mutation.VotesCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   poll.VotesTable,
                        Columns: []string{poll.VotesColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(vote.FieldID, field.TypeInt),
                        },
                }
                _spec.Edges.Clear = append(_spec.Edges.Clear, edge)
        }</span>
        <span class="cov0" title="0">if nodes := _u.mutation.RemovedVotesIDs(); len(nodes) &gt; 0 &amp;&amp; !_u.mutation.VotesCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   poll.VotesTable,
                        Columns: []string{poll.VotesColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(vote.FieldID, field.TypeInt),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges.Clear = append(_spec.Edges.Clear, edge)</span>
        }
        <span class="cov0" title="0">if nodes := _u.mutation.VotesIDs(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   poll.VotesTable,
                        Columns: []string{poll.VotesColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(vote.FieldID, field.TypeInt),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges.Add = append(_spec.Edges.Add, edge)</span>
        }
        <span class="cov0" title="0">_node = &amp;Poll{config: _u.config}
        _spec.Assign = _node.assignValues
        _spec.ScanValues = _node.scanValues
        if err = sqlgraph.UpdateNode(ctx, _u.driver, _spec); err != nil </span><span class="cov0" title="0">{
                if _, ok := err.(*sqlgraph.NotFoundError); ok </span><span class="cov0" title="0">{
                        err = &amp;NotFoundError{poll.Label}
                }</span> else<span class="cov0" title="0"> if sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                        err = &amp;ConstraintError{msg: err.Error(), wrap: err}
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">_u.mutation.done = true
        return _node, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "fmt"
        "strings"
        "time"

        "entgo.io/ent"
        "entgo.io/ent/dialect/sql"
        "github.com/ivankorhner/polling-app/internal/ent/poll"
        "github.com/ivankorhner/polling-app/internal/ent/polloption"
)

// PollOption is the model entity for the PollOption schema.
type PollOption struct {
        config `json:"-"`
        // ID of the ent.
        ID int `json:"id,omitempty"`
        // PollID holds the value of the "poll_id" field.
        PollID int `json:"poll_id,omitempty"`
        // Text holds the value of the "text" field.
        Text string `json:"text,omitempty"`
        // CreatedAt holds the value of the "created_at" field.
        CreatedAt time.Time `json:"created_at,omitempty"`
        // Edges holds the relations/edges for other nodes in the graph.
        // The values are being populated by the PollOptionQuery when eager-loading is set.
        Edges        PollOptionEdges `json:"edges"`
        selectValues sql.SelectValues
}

// PollOptionEdges holds the relations/edges for other nodes in the graph.
type PollOptionEdges struct {
        // Poll holds the value of the poll edge.
        Poll *Poll `json:"poll,omitempty"`
        // Votes holds the value of the votes edge.
        Votes []*Vote `json:"votes,omitempty"`
        // loadedTypes holds the information for reporting if a
        // type was loaded (or requested) in eager-loading or not.
        loadedTypes [2]bool
}

// PollOrErr returns the Poll value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e PollOptionEdges) PollOrErr() (*Poll, error) <span class="cov0" title="0">{
        if e.Poll != nil </span><span class="cov0" title="0">{
                return e.Poll, nil
        }</span> else<span class="cov0" title="0"> if e.loadedTypes[0] </span><span class="cov0" title="0">{
                return nil, &amp;NotFoundError{label: poll.Label}
        }</span>
        <span class="cov0" title="0">return nil, &amp;NotLoadedError{edge: "poll"}</span>
}

// VotesOrErr returns the Votes value or an error if the edge
// was not loaded in eager-loading.
func (e PollOptionEdges) VotesOrErr() ([]*Vote, error) <span class="cov0" title="0">{
        if e.loadedTypes[1] </span><span class="cov0" title="0">{
                return e.Votes, nil
        }</span>
        <span class="cov0" title="0">return nil, &amp;NotLoadedError{edge: "votes"}</span>
}

// scanValues returns the types for scanning values from sql.Rows.
func (*PollOption) scanValues(columns []string) ([]any, error) <span class="cov0" title="0">{
        values := make([]any, len(columns))
        for i := range columns </span><span class="cov0" title="0">{
                switch columns[i] </span>{
                case polloption.FieldID, polloption.FieldPollID:<span class="cov0" title="0">
                        values[i] = new(sql.NullInt64)</span>
                case polloption.FieldText:<span class="cov0" title="0">
                        values[i] = new(sql.NullString)</span>
                case polloption.FieldCreatedAt:<span class="cov0" title="0">
                        values[i] = new(sql.NullTime)</span>
                default:<span class="cov0" title="0">
                        values[i] = new(sql.UnknownType)</span>
                }
        }
        <span class="cov0" title="0">return values, nil</span>
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the PollOption fields.
func (_m *PollOption) assignValues(columns []string, values []any) error <span class="cov0" title="0">{
        if m, n := len(values), len(columns); m &lt; n </span><span class="cov0" title="0">{
                return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
        }</span>
        <span class="cov0" title="0">for i := range columns </span><span class="cov0" title="0">{
                switch columns[i] </span>{
                case polloption.FieldID:<span class="cov0" title="0">
                        value, ok := values[i].(*sql.NullInt64)
                        if !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field id", value)
                        }</span>
                        <span class="cov0" title="0">_m.ID = int(value.Int64)</span>
                case polloption.FieldPollID:<span class="cov0" title="0">
                        if value, ok := values[i].(*sql.NullInt64); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field poll_id", values[i])
                        }</span> else<span class="cov0" title="0"> if value.Valid </span><span class="cov0" title="0">{
                                _m.PollID = int(value.Int64)
                        }</span>
                case polloption.FieldText:<span class="cov0" title="0">
                        if value, ok := values[i].(*sql.NullString); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field text", values[i])
                        }</span> else<span class="cov0" title="0"> if value.Valid </span><span class="cov0" title="0">{
                                _m.Text = value.String
                        }</span>
                case polloption.FieldCreatedAt:<span class="cov0" title="0">
                        if value, ok := values[i].(*sql.NullTime); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field created_at", values[i])
                        }</span> else<span class="cov0" title="0"> if value.Valid </span><span class="cov0" title="0">{
                                _m.CreatedAt = value.Time
                        }</span>
                default:<span class="cov0" title="0">
                        _m.selectValues.Set(columns[i], values[i])</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// Value returns the ent.Value that was dynamically selected and assigned to the PollOption.
// This includes values selected through modifiers, order, etc.
func (_m *PollOption) Value(name string) (ent.Value, error) <span class="cov0" title="0">{
        return _m.selectValues.Get(name)
}</span>

// QueryPoll queries the "poll" edge of the PollOption entity.
func (_m *PollOption) QueryPoll() *PollQuery <span class="cov0" title="0">{
        return NewPollOptionClient(_m.config).QueryPoll(_m)
}</span>

// QueryVotes queries the "votes" edge of the PollOption entity.
func (_m *PollOption) QueryVotes() *VoteQuery <span class="cov0" title="0">{
        return NewPollOptionClient(_m.config).QueryVotes(_m)
}</span>

// Update returns a builder for updating this PollOption.
// Note that you need to call PollOption.Unwrap() before calling this method if this PollOption
// was returned from a transaction, and the transaction was committed or rolled back.
func (_m *PollOption) Update() *PollOptionUpdateOne <span class="cov0" title="0">{
        return NewPollOptionClient(_m.config).UpdateOne(_m)
}</span>

// Unwrap unwraps the PollOption entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (_m *PollOption) Unwrap() *PollOption <span class="cov0" title="0">{
        _tx, ok := _m.config.driver.(*txDriver)
        if !ok </span><span class="cov0" title="0">{
                panic("ent: PollOption is not a transactional entity")</span>
        }
        <span class="cov0" title="0">_m.config.driver = _tx.drv
        return _m</span>
}

// String implements the fmt.Stringer.
func (_m *PollOption) String() string <span class="cov0" title="0">{
        var builder strings.Builder
        builder.WriteString("PollOption(")
        builder.WriteString(fmt.Sprintf("id=%v, ", _m.ID))
        builder.WriteString("poll_id=")
        builder.WriteString(fmt.Sprintf("%v", _m.PollID))
        builder.WriteString(", ")
        builder.WriteString("text=")
        builder.WriteString(_m.Text)
        builder.WriteString(", ")
        builder.WriteString("created_at=")
        builder.WriteString(_m.CreatedAt.Format(time.ANSIC))
        builder.WriteByte(')')
        return builder.String()
}</span>

// PollOptions is a parsable slice of PollOption.
type PollOptions []*PollOption
</pre>
		
		<pre class="file" id="file18" style="display: none">// Code generated by ent, DO NOT EDIT.

package polloption

import (
        "time"

        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
)

const (
        // Label holds the string label denoting the polloption type in the database.
        Label = "poll_option"
        // FieldID holds the string denoting the id field in the database.
        FieldID = "id"
        // FieldPollID holds the string denoting the poll_id field in the database.
        FieldPollID = "poll_id"
        // FieldText holds the string denoting the text field in the database.
        FieldText = "text"
        // FieldCreatedAt holds the string denoting the created_at field in the database.
        FieldCreatedAt = "created_at"
        // EdgePoll holds the string denoting the poll edge name in mutations.
        EdgePoll = "poll"
        // EdgeVotes holds the string denoting the votes edge name in mutations.
        EdgeVotes = "votes"
        // Table holds the table name of the polloption in the database.
        Table = "poll_options"
        // PollTable is the table that holds the poll relation/edge.
        PollTable = "poll_options"
        // PollInverseTable is the table name for the Poll entity.
        // It exists in this package in order to avoid circular dependency with the "poll" package.
        PollInverseTable = "polls"
        // PollColumn is the table column denoting the poll relation/edge.
        PollColumn = "poll_id"
        // VotesTable is the table that holds the votes relation/edge.
        VotesTable = "votes"
        // VotesInverseTable is the table name for the Vote entity.
        // It exists in this package in order to avoid circular dependency with the "vote" package.
        VotesInverseTable = "votes"
        // VotesColumn is the table column denoting the votes relation/edge.
        VotesColumn = "option_id"
)

// Columns holds all SQL columns for polloption fields.
var Columns = []string{
        FieldID,
        FieldPollID,
        FieldText,
        FieldCreatedAt,
}

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool <span class="cov0" title="0">{
        for i := range Columns </span><span class="cov0" title="0">{
                if column == Columns[i] </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

var (
        // TextValidator is a validator for the "text" field. It is called by the builders before save.
        TextValidator func(string) error
        // DefaultCreatedAt holds the default value on creation for the "created_at" field.
        DefaultCreatedAt func() time.Time
)

// OrderOption defines the ordering options for the PollOption queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldID, opts...).ToFunc()
}</span>

// ByPollID orders the results by the poll_id field.
func ByPollID(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldPollID, opts...).ToFunc()
}</span>

// ByText orders the results by the text field.
func ByText(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldText, opts...).ToFunc()
}</span>

// ByCreatedAt orders the results by the created_at field.
func ByCreatedAt(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldCreatedAt, opts...).ToFunc()
}</span>

// ByPollField orders the results by poll field.
func ByPollField(field string, opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return func(s *sql.Selector) </span><span class="cov0" title="0">{
                sqlgraph.OrderByNeighborTerms(s, newPollStep(), sql.OrderByField(field, opts...))
        }</span>
}

// ByVotesCount orders the results by votes count.
func ByVotesCount(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return func(s *sql.Selector) </span><span class="cov0" title="0">{
                sqlgraph.OrderByNeighborsCount(s, newVotesStep(), opts...)
        }</span>
}

// ByVotes orders the results by votes terms.
func ByVotes(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption <span class="cov0" title="0">{
        return func(s *sql.Selector) </span><span class="cov0" title="0">{
                sqlgraph.OrderByNeighborTerms(s, newVotesStep(), append([]sql.OrderTerm{term}, terms...)...)
        }</span>
}
func newPollStep() *sqlgraph.Step <span class="cov0" title="0">{
        return sqlgraph.NewStep(
                sqlgraph.From(Table, FieldID),
                sqlgraph.To(PollInverseTable, FieldID),
                sqlgraph.Edge(sqlgraph.M2O, true, PollTable, PollColumn),
        )
}</span>
func newVotesStep() *sqlgraph.Step <span class="cov0" title="0">{
        return sqlgraph.NewStep(
                sqlgraph.From(Table, FieldID),
                sqlgraph.To(VotesInverseTable, FieldID),
                sqlgraph.Edge(sqlgraph.O2M, false, VotesTable, VotesColumn),
        )
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">// Code generated by ent, DO NOT EDIT.

package polloption

import (
        "time"

        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
        "github.com/ivankorhner/polling-app/internal/ent/predicate"
)

// ID filters vertices based on their ID field.
func ID(id int) predicate.PollOption <span class="cov0" title="0">{
        return predicate.PollOption(sql.FieldEQ(FieldID, id))
}</span>

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id int) predicate.PollOption <span class="cov0" title="0">{
        return predicate.PollOption(sql.FieldEQ(FieldID, id))
}</span>

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id int) predicate.PollOption <span class="cov0" title="0">{
        return predicate.PollOption(sql.FieldNEQ(FieldID, id))
}</span>

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...int) predicate.PollOption <span class="cov0" title="0">{
        return predicate.PollOption(sql.FieldIn(FieldID, ids...))
}</span>

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...int) predicate.PollOption <span class="cov0" title="0">{
        return predicate.PollOption(sql.FieldNotIn(FieldID, ids...))
}</span>

// IDGT applies the GT predicate on the ID field.
func IDGT(id int) predicate.PollOption <span class="cov0" title="0">{
        return predicate.PollOption(sql.FieldGT(FieldID, id))
}</span>

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id int) predicate.PollOption <span class="cov0" title="0">{
        return predicate.PollOption(sql.FieldGTE(FieldID, id))
}</span>

// IDLT applies the LT predicate on the ID field.
func IDLT(id int) predicate.PollOption <span class="cov0" title="0">{
        return predicate.PollOption(sql.FieldLT(FieldID, id))
}</span>

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id int) predicate.PollOption <span class="cov0" title="0">{
        return predicate.PollOption(sql.FieldLTE(FieldID, id))
}</span>

// PollID applies equality check predicate on the "poll_id" field. It's identical to PollIDEQ.
func PollID(v int) predicate.PollOption <span class="cov0" title="0">{
        return predicate.PollOption(sql.FieldEQ(FieldPollID, v))
}</span>

// Text applies equality check predicate on the "text" field. It's identical to TextEQ.
func Text(v string) predicate.PollOption <span class="cov0" title="0">{
        return predicate.PollOption(sql.FieldEQ(FieldText, v))
}</span>

// CreatedAt applies equality check predicate on the "created_at" field. It's identical to CreatedAtEQ.
func CreatedAt(v time.Time) predicate.PollOption <span class="cov0" title="0">{
        return predicate.PollOption(sql.FieldEQ(FieldCreatedAt, v))
}</span>

// PollIDEQ applies the EQ predicate on the "poll_id" field.
func PollIDEQ(v int) predicate.PollOption <span class="cov0" title="0">{
        return predicate.PollOption(sql.FieldEQ(FieldPollID, v))
}</span>

// PollIDNEQ applies the NEQ predicate on the "poll_id" field.
func PollIDNEQ(v int) predicate.PollOption <span class="cov0" title="0">{
        return predicate.PollOption(sql.FieldNEQ(FieldPollID, v))
}</span>

// PollIDIn applies the In predicate on the "poll_id" field.
func PollIDIn(vs ...int) predicate.PollOption <span class="cov0" title="0">{
        return predicate.PollOption(sql.FieldIn(FieldPollID, vs...))
}</span>

// PollIDNotIn applies the NotIn predicate on the "poll_id" field.
func PollIDNotIn(vs ...int) predicate.PollOption <span class="cov0" title="0">{
        return predicate.PollOption(sql.FieldNotIn(FieldPollID, vs...))
}</span>

// TextEQ applies the EQ predicate on the "text" field.
func TextEQ(v string) predicate.PollOption <span class="cov0" title="0">{
        return predicate.PollOption(sql.FieldEQ(FieldText, v))
}</span>

// TextNEQ applies the NEQ predicate on the "text" field.
func TextNEQ(v string) predicate.PollOption <span class="cov0" title="0">{
        return predicate.PollOption(sql.FieldNEQ(FieldText, v))
}</span>

// TextIn applies the In predicate on the "text" field.
func TextIn(vs ...string) predicate.PollOption <span class="cov0" title="0">{
        return predicate.PollOption(sql.FieldIn(FieldText, vs...))
}</span>

// TextNotIn applies the NotIn predicate on the "text" field.
func TextNotIn(vs ...string) predicate.PollOption <span class="cov0" title="0">{
        return predicate.PollOption(sql.FieldNotIn(FieldText, vs...))
}</span>

// TextGT applies the GT predicate on the "text" field.
func TextGT(v string) predicate.PollOption <span class="cov0" title="0">{
        return predicate.PollOption(sql.FieldGT(FieldText, v))
}</span>

// TextGTE applies the GTE predicate on the "text" field.
func TextGTE(v string) predicate.PollOption <span class="cov0" title="0">{
        return predicate.PollOption(sql.FieldGTE(FieldText, v))
}</span>

// TextLT applies the LT predicate on the "text" field.
func TextLT(v string) predicate.PollOption <span class="cov0" title="0">{
        return predicate.PollOption(sql.FieldLT(FieldText, v))
}</span>

// TextLTE applies the LTE predicate on the "text" field.
func TextLTE(v string) predicate.PollOption <span class="cov0" title="0">{
        return predicate.PollOption(sql.FieldLTE(FieldText, v))
}</span>

// TextContains applies the Contains predicate on the "text" field.
func TextContains(v string) predicate.PollOption <span class="cov0" title="0">{
        return predicate.PollOption(sql.FieldContains(FieldText, v))
}</span>

// TextHasPrefix applies the HasPrefix predicate on the "text" field.
func TextHasPrefix(v string) predicate.PollOption <span class="cov0" title="0">{
        return predicate.PollOption(sql.FieldHasPrefix(FieldText, v))
}</span>

// TextHasSuffix applies the HasSuffix predicate on the "text" field.
func TextHasSuffix(v string) predicate.PollOption <span class="cov0" title="0">{
        return predicate.PollOption(sql.FieldHasSuffix(FieldText, v))
}</span>

// TextEqualFold applies the EqualFold predicate on the "text" field.
func TextEqualFold(v string) predicate.PollOption <span class="cov0" title="0">{
        return predicate.PollOption(sql.FieldEqualFold(FieldText, v))
}</span>

// TextContainsFold applies the ContainsFold predicate on the "text" field.
func TextContainsFold(v string) predicate.PollOption <span class="cov0" title="0">{
        return predicate.PollOption(sql.FieldContainsFold(FieldText, v))
}</span>

// CreatedAtEQ applies the EQ predicate on the "created_at" field.
func CreatedAtEQ(v time.Time) predicate.PollOption <span class="cov0" title="0">{
        return predicate.PollOption(sql.FieldEQ(FieldCreatedAt, v))
}</span>

// CreatedAtNEQ applies the NEQ predicate on the "created_at" field.
func CreatedAtNEQ(v time.Time) predicate.PollOption <span class="cov0" title="0">{
        return predicate.PollOption(sql.FieldNEQ(FieldCreatedAt, v))
}</span>

// CreatedAtIn applies the In predicate on the "created_at" field.
func CreatedAtIn(vs ...time.Time) predicate.PollOption <span class="cov0" title="0">{
        return predicate.PollOption(sql.FieldIn(FieldCreatedAt, vs...))
}</span>

// CreatedAtNotIn applies the NotIn predicate on the "created_at" field.
func CreatedAtNotIn(vs ...time.Time) predicate.PollOption <span class="cov0" title="0">{
        return predicate.PollOption(sql.FieldNotIn(FieldCreatedAt, vs...))
}</span>

// CreatedAtGT applies the GT predicate on the "created_at" field.
func CreatedAtGT(v time.Time) predicate.PollOption <span class="cov0" title="0">{
        return predicate.PollOption(sql.FieldGT(FieldCreatedAt, v))
}</span>

// CreatedAtGTE applies the GTE predicate on the "created_at" field.
func CreatedAtGTE(v time.Time) predicate.PollOption <span class="cov0" title="0">{
        return predicate.PollOption(sql.FieldGTE(FieldCreatedAt, v))
}</span>

// CreatedAtLT applies the LT predicate on the "created_at" field.
func CreatedAtLT(v time.Time) predicate.PollOption <span class="cov0" title="0">{
        return predicate.PollOption(sql.FieldLT(FieldCreatedAt, v))
}</span>

// CreatedAtLTE applies the LTE predicate on the "created_at" field.
func CreatedAtLTE(v time.Time) predicate.PollOption <span class="cov0" title="0">{
        return predicate.PollOption(sql.FieldLTE(FieldCreatedAt, v))
}</span>

// HasPoll applies the HasEdge predicate on the "poll" edge.
func HasPoll() predicate.PollOption <span class="cov0" title="0">{
        return predicate.PollOption(func(s *sql.Selector) </span><span class="cov0" title="0">{
                step := sqlgraph.NewStep(
                        sqlgraph.From(Table, FieldID),
                        sqlgraph.Edge(sqlgraph.M2O, true, PollTable, PollColumn),
                )
                sqlgraph.HasNeighbors(s, step)
        }</span>)
}

// HasPollWith applies the HasEdge predicate on the "poll" edge with a given conditions (other predicates).
func HasPollWith(preds ...predicate.Poll) predicate.PollOption <span class="cov0" title="0">{
        return predicate.PollOption(func(s *sql.Selector) </span><span class="cov0" title="0">{
                step := newPollStep()
                sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) </span><span class="cov0" title="0">{
                        for _, p := range preds </span><span class="cov0" title="0">{
                                p(s)
                        }</span>
                })
        })
}

// HasVotes applies the HasEdge predicate on the "votes" edge.
func HasVotes() predicate.PollOption <span class="cov0" title="0">{
        return predicate.PollOption(func(s *sql.Selector) </span><span class="cov0" title="0">{
                step := sqlgraph.NewStep(
                        sqlgraph.From(Table, FieldID),
                        sqlgraph.Edge(sqlgraph.O2M, false, VotesTable, VotesColumn),
                )
                sqlgraph.HasNeighbors(s, step)
        }</span>)
}

// HasVotesWith applies the HasEdge predicate on the "votes" edge with a given conditions (other predicates).
func HasVotesWith(preds ...predicate.Vote) predicate.PollOption <span class="cov0" title="0">{
        return predicate.PollOption(func(s *sql.Selector) </span><span class="cov0" title="0">{
                step := newVotesStep()
                sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) </span><span class="cov0" title="0">{
                        for _, p := range preds </span><span class="cov0" title="0">{
                                p(s)
                        }</span>
                })
        })
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.PollOption) predicate.PollOption <span class="cov0" title="0">{
        return predicate.PollOption(sql.AndPredicates(predicates...))
}</span>

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.PollOption) predicate.PollOption <span class="cov0" title="0">{
        return predicate.PollOption(sql.OrPredicates(predicates...))
}</span>

// Not applies the not operator on the given predicate.
func Not(p predicate.PollOption) predicate.PollOption <span class="cov0" title="0">{
        return predicate.PollOption(sql.NotPredicates(p))
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "context"
        "errors"
        "fmt"
        "time"

        "entgo.io/ent/dialect/sql/sqlgraph"
        "entgo.io/ent/schema/field"
        "github.com/ivankorhner/polling-app/internal/ent/poll"
        "github.com/ivankorhner/polling-app/internal/ent/polloption"
        "github.com/ivankorhner/polling-app/internal/ent/vote"
)

// PollOptionCreate is the builder for creating a PollOption entity.
type PollOptionCreate struct {
        config
        mutation *PollOptionMutation
        hooks    []Hook
}

// SetPollID sets the "poll_id" field.
func (_c *PollOptionCreate) SetPollID(v int) *PollOptionCreate <span class="cov0" title="0">{
        _c.mutation.SetPollID(v)
        return _c
}</span>

// SetText sets the "text" field.
func (_c *PollOptionCreate) SetText(v string) *PollOptionCreate <span class="cov0" title="0">{
        _c.mutation.SetText(v)
        return _c
}</span>

// SetCreatedAt sets the "created_at" field.
func (_c *PollOptionCreate) SetCreatedAt(v time.Time) *PollOptionCreate <span class="cov0" title="0">{
        _c.mutation.SetCreatedAt(v)
        return _c
}</span>

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (_c *PollOptionCreate) SetNillableCreatedAt(v *time.Time) *PollOptionCreate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _c.SetCreatedAt(*v)
        }</span>
        <span class="cov0" title="0">return _c</span>
}

// SetID sets the "id" field.
func (_c *PollOptionCreate) SetID(v int) *PollOptionCreate <span class="cov0" title="0">{
        _c.mutation.SetID(v)
        return _c
}</span>

// SetPoll sets the "poll" edge to the Poll entity.
func (_c *PollOptionCreate) SetPoll(v *Poll) *PollOptionCreate <span class="cov0" title="0">{
        return _c.SetPollID(v.ID)
}</span>

// AddVoteIDs adds the "votes" edge to the Vote entity by IDs.
func (_c *PollOptionCreate) AddVoteIDs(ids ...int) *PollOptionCreate <span class="cov0" title="0">{
        _c.mutation.AddVoteIDs(ids...)
        return _c
}</span>

// AddVotes adds the "votes" edges to the Vote entity.
func (_c *PollOptionCreate) AddVotes(v ...*Vote) *PollOptionCreate <span class="cov0" title="0">{
        ids := make([]int, len(v))
        for i := range v </span><span class="cov0" title="0">{
                ids[i] = v[i].ID
        }</span>
        <span class="cov0" title="0">return _c.AddVoteIDs(ids...)</span>
}

// Mutation returns the PollOptionMutation object of the builder.
func (_c *PollOptionCreate) Mutation() *PollOptionMutation <span class="cov0" title="0">{
        return _c.mutation
}</span>

// Save creates the PollOption in the database.
func (_c *PollOptionCreate) Save(ctx context.Context) (*PollOption, error) <span class="cov0" title="0">{
        _c.defaults()
        return withHooks(ctx, _c.sqlSave, _c.mutation, _c.hooks)
}</span>

// SaveX calls Save and panics if Save returns an error.
func (_c *PollOptionCreate) SaveX(ctx context.Context) *PollOption <span class="cov0" title="0">{
        v, err := _c.Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return v</span>
}

// Exec executes the query.
func (_c *PollOptionCreate) Exec(ctx context.Context) error <span class="cov0" title="0">{
        _, err := _c.Save(ctx)
        return err
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (_c *PollOptionCreate) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := _c.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// defaults sets the default values of the builder before save.
func (_c *PollOptionCreate) defaults() <span class="cov0" title="0">{
        if _, ok := _c.mutation.CreatedAt(); !ok </span><span class="cov0" title="0">{
                v := polloption.DefaultCreatedAt()
                _c.mutation.SetCreatedAt(v)
        }</span>
}

// check runs all checks and user-defined validators on the builder.
func (_c *PollOptionCreate) check() error <span class="cov0" title="0">{
        if _, ok := _c.mutation.PollID(); !ok </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "poll_id", err: errors.New(`ent: missing required field "PollOption.poll_id"`)}
        }</span>
        <span class="cov0" title="0">if _, ok := _c.mutation.Text(); !ok </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "text", err: errors.New(`ent: missing required field "PollOption.text"`)}
        }</span>
        <span class="cov0" title="0">if v, ok := _c.mutation.Text(); ok </span><span class="cov0" title="0">{
                if err := polloption.TextValidator(v); err != nil </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: "text", err: fmt.Errorf(`ent: validator failed for field "PollOption.text": %w`, err)}
                }</span>
        }
        <span class="cov0" title="0">if _, ok := _c.mutation.CreatedAt(); !ok </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "created_at", err: errors.New(`ent: missing required field "PollOption.created_at"`)}
        }</span>
        <span class="cov0" title="0">if len(_c.mutation.PollIDs()) == 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "poll", err: errors.New(`ent: missing required edge "PollOption.poll"`)}
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (_c *PollOptionCreate) sqlSave(ctx context.Context) (*PollOption, error) <span class="cov0" title="0">{
        if err := _c.check(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">_node, _spec := _c.createSpec()
        if err := sqlgraph.CreateNode(ctx, _c.driver, _spec); err != nil </span><span class="cov0" title="0">{
                if sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                        err = &amp;ConstraintError{msg: err.Error(), wrap: err}
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">if _spec.ID.Value != _node.ID </span><span class="cov0" title="0">{
                id := _spec.ID.Value.(int64)
                _node.ID = int(id)
        }</span>
        <span class="cov0" title="0">_c.mutation.id = &amp;_node.ID
        _c.mutation.done = true
        return _node, nil</span>
}

func (_c *PollOptionCreate) createSpec() (*PollOption, *sqlgraph.CreateSpec) <span class="cov0" title="0">{
        var (
                _node = &amp;PollOption{config: _c.config}
                _spec = sqlgraph.NewCreateSpec(polloption.Table, sqlgraph.NewFieldSpec(polloption.FieldID, field.TypeInt))
        )
        if id, ok := _c.mutation.ID(); ok </span><span class="cov0" title="0">{
                _node.ID = id
                _spec.ID.Value = id
        }</span>
        <span class="cov0" title="0">if value, ok := _c.mutation.Text(); ok </span><span class="cov0" title="0">{
                _spec.SetField(polloption.FieldText, field.TypeString, value)
                _node.Text = value
        }</span>
        <span class="cov0" title="0">if value, ok := _c.mutation.CreatedAt(); ok </span><span class="cov0" title="0">{
                _spec.SetField(polloption.FieldCreatedAt, field.TypeTime, value)
                _node.CreatedAt = value
        }</span>
        <span class="cov0" title="0">if nodes := _c.mutation.PollIDs(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2O,
                        Inverse: true,
                        Table:   polloption.PollTable,
                        Columns: []string{polloption.PollColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(poll.FieldID, field.TypeInt),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_node.PollID = nodes[0]
                _spec.Edges = append(_spec.Edges, edge)</span>
        }
        <span class="cov0" title="0">if nodes := _c.mutation.VotesIDs(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   polloption.VotesTable,
                        Columns: []string{polloption.VotesColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(vote.FieldID, field.TypeInt),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges = append(_spec.Edges, edge)</span>
        }
        <span class="cov0" title="0">return _node, _spec</span>
}

// PollOptionCreateBulk is the builder for creating many PollOption entities in bulk.
type PollOptionCreateBulk struct {
        config
        err      error
        builders []*PollOptionCreate
}

// Save creates the PollOption entities in the database.
func (_c *PollOptionCreateBulk) Save(ctx context.Context) ([]*PollOption, error) <span class="cov0" title="0">{
        if _c.err != nil </span><span class="cov0" title="0">{
                return nil, _c.err
        }</span>
        <span class="cov0" title="0">specs := make([]*sqlgraph.CreateSpec, len(_c.builders))
        nodes := make([]*PollOption, len(_c.builders))
        mutators := make([]Mutator, len(_c.builders))
        for i := range _c.builders </span><span class="cov0" title="0">{
                func(i int, root context.Context) </span><span class="cov0" title="0">{
                        builder := _c.builders[i]
                        builder.defaults()
                        var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) </span><span class="cov0" title="0">{
                                mutation, ok := m.(*PollOptionMutation)
                                if !ok </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("unexpected mutation type %T", m)
                                }</span>
                                <span class="cov0" title="0">if err := builder.check(); err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">builder.mutation = mutation
                                var err error
                                nodes[i], specs[i] = builder.createSpec()
                                if i &lt; len(mutators)-1 </span><span class="cov0" title="0">{
                                        _, err = mutators[i+1].Mutate(root, _c.builders[i+1].mutation)
                                }</span> else<span class="cov0" title="0"> {
                                        spec := &amp;sqlgraph.BatchCreateSpec{Nodes: specs}
                                        // Invoke the actual operation on the latest mutation in the chain.
                                        if err = sqlgraph.BatchCreate(ctx, _c.driver, spec); err != nil </span><span class="cov0" title="0">{
                                                if sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                                                        err = &amp;ConstraintError{msg: err.Error(), wrap: err}
                                                }</span>
                                        }
                                }
                                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">mutation.id = &amp;nodes[i].ID
                                if specs[i].ID.Value != nil &amp;&amp; nodes[i].ID == 0 </span><span class="cov0" title="0">{
                                        id := specs[i].ID.Value.(int64)
                                        nodes[i].ID = int(id)
                                }</span>
                                <span class="cov0" title="0">mutation.done = true
                                return nodes[i], nil</span>
                        })
                        <span class="cov0" title="0">for i := len(builder.hooks) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                                mut = builder.hooks[i](mut)
                        }</span>
                        <span class="cov0" title="0">mutators[i] = mut</span>
                }(i, ctx)
        }
        <span class="cov0" title="0">if len(mutators) &gt; 0 </span><span class="cov0" title="0">{
                if _, err := mutators[0].Mutate(ctx, _c.builders[0].mutation); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return nodes, nil</span>
}

// SaveX is like Save, but panics if an error occurs.
func (_c *PollOptionCreateBulk) SaveX(ctx context.Context) []*PollOption <span class="cov0" title="0">{
        v, err := _c.Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return v</span>
}

// Exec executes the query.
func (_c *PollOptionCreateBulk) Exec(ctx context.Context) error <span class="cov0" title="0">{
        _, err := _c.Save(ctx)
        return err
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (_c *PollOptionCreateBulk) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := _c.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "context"

        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
        "entgo.io/ent/schema/field"
        "github.com/ivankorhner/polling-app/internal/ent/polloption"
        "github.com/ivankorhner/polling-app/internal/ent/predicate"
)

// PollOptionDelete is the builder for deleting a PollOption entity.
type PollOptionDelete struct {
        config
        hooks    []Hook
        mutation *PollOptionMutation
}

// Where appends a list predicates to the PollOptionDelete builder.
func (_d *PollOptionDelete) Where(ps ...predicate.PollOption) *PollOptionDelete <span class="cov0" title="0">{
        _d.mutation.Where(ps...)
        return _d
}</span>

// Exec executes the deletion query and returns how many vertices were deleted.
func (_d *PollOptionDelete) Exec(ctx context.Context) (int, error) <span class="cov0" title="0">{
        return withHooks(ctx, _d.sqlExec, _d.mutation, _d.hooks)
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (_d *PollOptionDelete) ExecX(ctx context.Context) int <span class="cov0" title="0">{
        n, err := _d.Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return n</span>
}

func (_d *PollOptionDelete) sqlExec(ctx context.Context) (int, error) <span class="cov0" title="0">{
        _spec := sqlgraph.NewDeleteSpec(polloption.Table, sqlgraph.NewFieldSpec(polloption.FieldID, field.TypeInt))
        if ps := _d.mutation.predicates; len(ps) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Predicate = func(selector *sql.Selector) </span><span class="cov0" title="0">{
                        for i := range ps </span><span class="cov0" title="0">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov0" title="0">affected, err := sqlgraph.DeleteNodes(ctx, _d.driver, _spec)
        if err != nil &amp;&amp; sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                err = &amp;ConstraintError{msg: err.Error(), wrap: err}
        }</span>
        <span class="cov0" title="0">_d.mutation.done = true
        return affected, err</span>
}

// PollOptionDeleteOne is the builder for deleting a single PollOption entity.
type PollOptionDeleteOne struct {
        _d *PollOptionDelete
}

// Where appends a list predicates to the PollOptionDelete builder.
func (_d *PollOptionDeleteOne) Where(ps ...predicate.PollOption) *PollOptionDeleteOne <span class="cov0" title="0">{
        _d._d.mutation.Where(ps...)
        return _d
}</span>

// Exec executes the deletion query.
func (_d *PollOptionDeleteOne) Exec(ctx context.Context) error <span class="cov0" title="0">{
        n, err := _d._d.Exec(ctx)
        switch </span>{
        case err != nil:<span class="cov0" title="0">
                return err</span>
        case n == 0:<span class="cov0" title="0">
                return &amp;NotFoundError{polloption.Label}</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

// ExecX is like Exec, but panics if an error occurs.
func (_d *PollOptionDeleteOne) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := _d.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}
</pre>
		
		<pre class="file" id="file22" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "context"
        "database/sql/driver"
        "fmt"
        "math"

        "entgo.io/ent"
        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
        "entgo.io/ent/schema/field"
        "github.com/ivankorhner/polling-app/internal/ent/poll"
        "github.com/ivankorhner/polling-app/internal/ent/polloption"
        "github.com/ivankorhner/polling-app/internal/ent/predicate"
        "github.com/ivankorhner/polling-app/internal/ent/vote"
)

// PollOptionQuery is the builder for querying PollOption entities.
type PollOptionQuery struct {
        config
        ctx        *QueryContext
        order      []polloption.OrderOption
        inters     []Interceptor
        predicates []predicate.PollOption
        withPoll   *PollQuery
        withVotes  *VoteQuery
        // intermediate query (i.e. traversal path).
        sql  *sql.Selector
        path func(context.Context) (*sql.Selector, error)
}

// Where adds a new predicate for the PollOptionQuery builder.
func (_q *PollOptionQuery) Where(ps ...predicate.PollOption) *PollOptionQuery <span class="cov0" title="0">{
        _q.predicates = append(_q.predicates, ps...)
        return _q
}</span>

// Limit the number of records to be returned by this query.
func (_q *PollOptionQuery) Limit(limit int) *PollOptionQuery <span class="cov0" title="0">{
        _q.ctx.Limit = &amp;limit
        return _q
}</span>

// Offset to start from.
func (_q *PollOptionQuery) Offset(offset int) *PollOptionQuery <span class="cov0" title="0">{
        _q.ctx.Offset = &amp;offset
        return _q
}</span>

// Unique configures the query builder to filter duplicate records on query.
// By default, unique is set to true, and can be disabled using this method.
func (_q *PollOptionQuery) Unique(unique bool) *PollOptionQuery <span class="cov0" title="0">{
        _q.ctx.Unique = &amp;unique
        return _q
}</span>

// Order specifies how the records should be ordered.
func (_q *PollOptionQuery) Order(o ...polloption.OrderOption) *PollOptionQuery <span class="cov0" title="0">{
        _q.order = append(_q.order, o...)
        return _q
}</span>

// QueryPoll chains the current query on the "poll" edge.
func (_q *PollOptionQuery) QueryPoll() *PollQuery <span class="cov0" title="0">{
        query := (&amp;PollClient{config: _q.config}).Query()
        query.path = func(ctx context.Context) (fromU *sql.Selector, err error) </span><span class="cov0" title="0">{
                if err := _q.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">selector := _q.sqlQuery(ctx)
                if err := selector.Err(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">step := sqlgraph.NewStep(
                        sqlgraph.From(polloption.Table, polloption.FieldID, selector),
                        sqlgraph.To(poll.Table, poll.FieldID),
                        sqlgraph.Edge(sqlgraph.M2O, true, polloption.PollTable, polloption.PollColumn),
                )
                fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
                return fromU, nil</span>
        }
        <span class="cov0" title="0">return query</span>
}

// QueryVotes chains the current query on the "votes" edge.
func (_q *PollOptionQuery) QueryVotes() *VoteQuery <span class="cov0" title="0">{
        query := (&amp;VoteClient{config: _q.config}).Query()
        query.path = func(ctx context.Context) (fromU *sql.Selector, err error) </span><span class="cov0" title="0">{
                if err := _q.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">selector := _q.sqlQuery(ctx)
                if err := selector.Err(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">step := sqlgraph.NewStep(
                        sqlgraph.From(polloption.Table, polloption.FieldID, selector),
                        sqlgraph.To(vote.Table, vote.FieldID),
                        sqlgraph.Edge(sqlgraph.O2M, false, polloption.VotesTable, polloption.VotesColumn),
                )
                fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
                return fromU, nil</span>
        }
        <span class="cov0" title="0">return query</span>
}

// First returns the first PollOption entity from the query.
// Returns a *NotFoundError when no PollOption was found.
func (_q *PollOptionQuery) First(ctx context.Context) (*PollOption, error) <span class="cov0" title="0">{
        nodes, err := _q.Limit(1).All(setContextOp(ctx, _q.ctx, ent.OpQueryFirst))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(nodes) == 0 </span><span class="cov0" title="0">{
                return nil, &amp;NotFoundError{polloption.Label}
        }</span>
        <span class="cov0" title="0">return nodes[0], nil</span>
}

// FirstX is like First, but panics if an error occurs.
func (_q *PollOptionQuery) FirstX(ctx context.Context) *PollOption <span class="cov0" title="0">{
        node, err := _q.First(ctx)
        if err != nil &amp;&amp; !IsNotFound(err) </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return node</span>
}

// FirstID returns the first PollOption ID from the query.
// Returns a *NotFoundError when no PollOption ID was found.
func (_q *PollOptionQuery) FirstID(ctx context.Context) (id int, err error) <span class="cov0" title="0">{
        var ids []int
        if ids, err = _q.Limit(1).IDs(setContextOp(ctx, _q.ctx, ent.OpQueryFirstID)); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if len(ids) == 0 </span><span class="cov0" title="0">{
                err = &amp;NotFoundError{polloption.Label}
                return
        }</span>
        <span class="cov0" title="0">return ids[0], nil</span>
}

// FirstIDX is like FirstID, but panics if an error occurs.
func (_q *PollOptionQuery) FirstIDX(ctx context.Context) int <span class="cov0" title="0">{
        id, err := _q.FirstID(ctx)
        if err != nil &amp;&amp; !IsNotFound(err) </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return id</span>
}

// Only returns a single PollOption entity found by the query, ensuring it only returns one.
// Returns a *NotSingularError when more than one PollOption entity is found.
// Returns a *NotFoundError when no PollOption entities are found.
func (_q *PollOptionQuery) Only(ctx context.Context) (*PollOption, error) <span class="cov0" title="0">{
        nodes, err := _q.Limit(2).All(setContextOp(ctx, _q.ctx, ent.OpQueryOnly))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">switch len(nodes) </span>{
        case 1:<span class="cov0" title="0">
                return nodes[0], nil</span>
        case 0:<span class="cov0" title="0">
                return nil, &amp;NotFoundError{polloption.Label}</span>
        default:<span class="cov0" title="0">
                return nil, &amp;NotSingularError{polloption.Label}</span>
        }
}

// OnlyX is like Only, but panics if an error occurs.
func (_q *PollOptionQuery) OnlyX(ctx context.Context) *PollOption <span class="cov0" title="0">{
        node, err := _q.Only(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return node</span>
}

// OnlyID is like Only, but returns the only PollOption ID in the query.
// Returns a *NotSingularError when more than one PollOption ID is found.
// Returns a *NotFoundError when no entities are found.
func (_q *PollOptionQuery) OnlyID(ctx context.Context) (id int, err error) <span class="cov0" title="0">{
        var ids []int
        if ids, err = _q.Limit(2).IDs(setContextOp(ctx, _q.ctx, ent.OpQueryOnlyID)); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">switch len(ids) </span>{
        case 1:<span class="cov0" title="0">
                id = ids[0]</span>
        case 0:<span class="cov0" title="0">
                err = &amp;NotFoundError{polloption.Label}</span>
        default:<span class="cov0" title="0">
                err = &amp;NotSingularError{polloption.Label}</span>
        }
        <span class="cov0" title="0">return</span>
}

// OnlyIDX is like OnlyID, but panics if an error occurs.
func (_q *PollOptionQuery) OnlyIDX(ctx context.Context) int <span class="cov0" title="0">{
        id, err := _q.OnlyID(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return id</span>
}

// All executes the query and returns a list of PollOptions.
func (_q *PollOptionQuery) All(ctx context.Context) ([]*PollOption, error) <span class="cov0" title="0">{
        ctx = setContextOp(ctx, _q.ctx, ent.OpQueryAll)
        if err := _q.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">qr := querierAll[[]*PollOption, *PollOptionQuery]()
        return withInterceptors[[]*PollOption](ctx, _q, qr, _q.inters)</span>
}

// AllX is like All, but panics if an error occurs.
func (_q *PollOptionQuery) AllX(ctx context.Context) []*PollOption <span class="cov0" title="0">{
        nodes, err := _q.All(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return nodes</span>
}

// IDs executes the query and returns a list of PollOption IDs.
func (_q *PollOptionQuery) IDs(ctx context.Context) (ids []int, err error) <span class="cov0" title="0">{
        if _q.ctx.Unique == nil &amp;&amp; _q.path != nil </span><span class="cov0" title="0">{
                _q.Unique(true)
        }</span>
        <span class="cov0" title="0">ctx = setContextOp(ctx, _q.ctx, ent.OpQueryIDs)
        if err = _q.Select(polloption.FieldID).Scan(ctx, &amp;ids); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ids, nil</span>
}

// IDsX is like IDs, but panics if an error occurs.
func (_q *PollOptionQuery) IDsX(ctx context.Context) []int <span class="cov0" title="0">{
        ids, err := _q.IDs(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return ids</span>
}

// Count returns the count of the given query.
func (_q *PollOptionQuery) Count(ctx context.Context) (int, error) <span class="cov0" title="0">{
        ctx = setContextOp(ctx, _q.ctx, ent.OpQueryCount)
        if err := _q.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return withInterceptors[int](ctx, _q, querierCount[*PollOptionQuery](), _q.inters)</span>
}

// CountX is like Count, but panics if an error occurs.
func (_q *PollOptionQuery) CountX(ctx context.Context) int <span class="cov0" title="0">{
        count, err := _q.Count(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return count</span>
}

// Exist returns true if the query has elements in the graph.
func (_q *PollOptionQuery) Exist(ctx context.Context) (bool, error) <span class="cov0" title="0">{
        ctx = setContextOp(ctx, _q.ctx, ent.OpQueryExist)
        switch _, err := _q.FirstID(ctx); </span>{
        case IsNotFound(err):<span class="cov0" title="0">
                return false, nil</span>
        case err != nil:<span class="cov0" title="0">
                return false, fmt.Errorf("ent: check existence: %w", err)</span>
        default:<span class="cov0" title="0">
                return true, nil</span>
        }
}

// ExistX is like Exist, but panics if an error occurs.
func (_q *PollOptionQuery) ExistX(ctx context.Context) bool <span class="cov0" title="0">{
        exist, err := _q.Exist(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return exist</span>
}

// Clone returns a duplicate of the PollOptionQuery builder, including all associated steps. It can be
// used to prepare common query builders and use them differently after the clone is made.
func (_q *PollOptionQuery) Clone() *PollOptionQuery <span class="cov0" title="0">{
        if _q == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;PollOptionQuery{
                config:     _q.config,
                ctx:        _q.ctx.Clone(),
                order:      append([]polloption.OrderOption{}, _q.order...),
                inters:     append([]Interceptor{}, _q.inters...),
                predicates: append([]predicate.PollOption{}, _q.predicates...),
                withPoll:   _q.withPoll.Clone(),
                withVotes:  _q.withVotes.Clone(),
                // clone intermediate query.
                sql:  _q.sql.Clone(),
                path: _q.path,
        }</span>
}

// WithPoll tells the query-builder to eager-load the nodes that are connected to
// the "poll" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *PollOptionQuery) WithPoll(opts ...func(*PollQuery)) *PollOptionQuery <span class="cov0" title="0">{
        query := (&amp;PollClient{config: _q.config}).Query()
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(query)
        }</span>
        <span class="cov0" title="0">_q.withPoll = query
        return _q</span>
}

// WithVotes tells the query-builder to eager-load the nodes that are connected to
// the "votes" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *PollOptionQuery) WithVotes(opts ...func(*VoteQuery)) *PollOptionQuery <span class="cov0" title="0">{
        query := (&amp;VoteClient{config: _q.config}).Query()
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(query)
        }</span>
        <span class="cov0" title="0">_q.withVotes = query
        return _q</span>
}

// GroupBy is used to group vertices by one or more fields/columns.
// It is often used with aggregate functions, like: count, max, mean, min, sum.
//
// Example:
//
//        var v []struct {
//                PollID int `json:"poll_id,omitempty"`
//                Count int `json:"count,omitempty"`
//        }
//
//        client.PollOption.Query().
//                GroupBy(polloption.FieldPollID).
//                Aggregate(ent.Count()).
//                Scan(ctx, &amp;v)
func (_q *PollOptionQuery) GroupBy(field string, fields ...string) *PollOptionGroupBy <span class="cov0" title="0">{
        _q.ctx.Fields = append([]string{field}, fields...)
        grbuild := &amp;PollOptionGroupBy{build: _q}
        grbuild.flds = &amp;_q.ctx.Fields
        grbuild.label = polloption.Label
        grbuild.scan = grbuild.Scan
        return grbuild
}</span>

// Select allows the selection one or more fields/columns for the given query,
// instead of selecting all fields in the entity.
//
// Example:
//
//        var v []struct {
//                PollID int `json:"poll_id,omitempty"`
//        }
//
//        client.PollOption.Query().
//                Select(polloption.FieldPollID).
//                Scan(ctx, &amp;v)
func (_q *PollOptionQuery) Select(fields ...string) *PollOptionSelect <span class="cov0" title="0">{
        _q.ctx.Fields = append(_q.ctx.Fields, fields...)
        sbuild := &amp;PollOptionSelect{PollOptionQuery: _q}
        sbuild.label = polloption.Label
        sbuild.flds, sbuild.scan = &amp;_q.ctx.Fields, sbuild.Scan
        return sbuild
}</span>

// Aggregate returns a PollOptionSelect configured with the given aggregations.
func (_q *PollOptionQuery) Aggregate(fns ...AggregateFunc) *PollOptionSelect <span class="cov0" title="0">{
        return _q.Select().Aggregate(fns...)
}</span>

func (_q *PollOptionQuery) prepareQuery(ctx context.Context) error <span class="cov0" title="0">{
        for _, inter := range _q.inters </span><span class="cov0" title="0">{
                if inter == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("ent: uninitialized interceptor (forgotten import ent/runtime?)")
                }</span>
                <span class="cov0" title="0">if trv, ok := inter.(Traverser); ok </span><span class="cov0" title="0">{
                        if err := trv.Traverse(ctx, _q); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov0" title="0">for _, f := range _q.ctx.Fields </span><span class="cov0" title="0">{
                if !polloption.ValidColumn(f) </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
                }</span>
        }
        <span class="cov0" title="0">if _q.path != nil </span><span class="cov0" title="0">{
                prev, err := _q.path(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">_q.sql = prev</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (_q *PollOptionQuery) sqlAll(ctx context.Context, hooks ...queryHook) ([]*PollOption, error) <span class="cov0" title="0">{
        var (
                nodes       = []*PollOption{}
                _spec       = _q.querySpec()
                loadedTypes = [2]bool{
                        _q.withPoll != nil,
                        _q.withVotes != nil,
                }
        )
        _spec.ScanValues = func(columns []string) ([]any, error) </span><span class="cov0" title="0">{
                return (*PollOption).scanValues(nil, columns)
        }</span>
        <span class="cov0" title="0">_spec.Assign = func(columns []string, values []any) error </span><span class="cov0" title="0">{
                node := &amp;PollOption{config: _q.config}
                nodes = append(nodes, node)
                node.Edges.loadedTypes = loadedTypes
                return node.assignValues(columns, values)
        }</span>
        <span class="cov0" title="0">for i := range hooks </span><span class="cov0" title="0">{
                hooks[i](ctx, _spec)
        }</span>
        <span class="cov0" title="0">if err := sqlgraph.QueryNodes(ctx, _q.driver, _spec); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(nodes) == 0 </span><span class="cov0" title="0">{
                return nodes, nil
        }</span>
        <span class="cov0" title="0">if query := _q.withPoll; query != nil </span><span class="cov0" title="0">{
                if err := _q.loadPoll(ctx, query, nodes, nil,
                        func(n *PollOption, e *Poll) </span><span class="cov0" title="0">{ n.Edges.Poll = e }</span>); err != nil <span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">if query := _q.withVotes; query != nil </span><span class="cov0" title="0">{
                if err := _q.loadVotes(ctx, query, nodes,
                        func(n *PollOption) </span><span class="cov0" title="0">{ n.Edges.Votes = []*Vote{} }</span>,
                        func(n *PollOption, e *Vote) <span class="cov0" title="0">{ n.Edges.Votes = append(n.Edges.Votes, e) }</span>); err != nil <span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return nodes, nil</span>
}

func (_q *PollOptionQuery) loadPoll(ctx context.Context, query *PollQuery, nodes []*PollOption, init func(*PollOption), assign func(*PollOption, *Poll)) error <span class="cov0" title="0">{
        ids := make([]int, 0, len(nodes))
        nodeids := make(map[int][]*PollOption)
        for i := range nodes </span><span class="cov0" title="0">{
                fk := nodes[i].PollID
                if _, ok := nodeids[fk]; !ok </span><span class="cov0" title="0">{
                        ids = append(ids, fk)
                }</span>
                <span class="cov0" title="0">nodeids[fk] = append(nodeids[fk], nodes[i])</span>
        }
        <span class="cov0" title="0">if len(ids) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">query.Where(poll.IDIn(ids...))
        neighbors, err := query.All(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, n := range neighbors </span><span class="cov0" title="0">{
                nodes, ok := nodeids[n.ID]
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf(`unexpected foreign-key "poll_id" returned %v`, n.ID)
                }</span>
                <span class="cov0" title="0">for i := range nodes </span><span class="cov0" title="0">{
                        assign(nodes[i], n)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
func (_q *PollOptionQuery) loadVotes(ctx context.Context, query *VoteQuery, nodes []*PollOption, init func(*PollOption), assign func(*PollOption, *Vote)) error <span class="cov0" title="0">{
        fks := make([]driver.Value, 0, len(nodes))
        nodeids := make(map[int]*PollOption)
        for i := range nodes </span><span class="cov0" title="0">{
                fks = append(fks, nodes[i].ID)
                nodeids[nodes[i].ID] = nodes[i]
                if init != nil </span><span class="cov0" title="0">{
                        init(nodes[i])
                }</span>
        }
        <span class="cov0" title="0">if len(query.ctx.Fields) &gt; 0 </span><span class="cov0" title="0">{
                query.ctx.AppendFieldOnce(vote.FieldOptionID)
        }</span>
        <span class="cov0" title="0">query.Where(predicate.Vote(func(s *sql.Selector) </span><span class="cov0" title="0">{
                s.Where(sql.InValues(s.C(polloption.VotesColumn), fks...))
        }</span>))
        <span class="cov0" title="0">neighbors, err := query.All(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, n := range neighbors </span><span class="cov0" title="0">{
                fk := n.OptionID
                node, ok := nodeids[fk]
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf(`unexpected referenced foreign-key "option_id" returned %v for node %v`, fk, n.ID)
                }</span>
                <span class="cov0" title="0">assign(node, n)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (_q *PollOptionQuery) sqlCount(ctx context.Context) (int, error) <span class="cov0" title="0">{
        _spec := _q.querySpec()
        _spec.Node.Columns = _q.ctx.Fields
        if len(_q.ctx.Fields) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Unique = _q.ctx.Unique != nil &amp;&amp; *_q.ctx.Unique
        }</span>
        <span class="cov0" title="0">return sqlgraph.CountNodes(ctx, _q.driver, _spec)</span>
}

func (_q *PollOptionQuery) querySpec() *sqlgraph.QuerySpec <span class="cov0" title="0">{
        _spec := sqlgraph.NewQuerySpec(polloption.Table, polloption.Columns, sqlgraph.NewFieldSpec(polloption.FieldID, field.TypeInt))
        _spec.From = _q.sql
        if unique := _q.ctx.Unique; unique != nil </span><span class="cov0" title="0">{
                _spec.Unique = *unique
        }</span> else<span class="cov0" title="0"> if _q.path != nil </span><span class="cov0" title="0">{
                _spec.Unique = true
        }</span>
        <span class="cov0" title="0">if fields := _q.ctx.Fields; len(fields) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Node.Columns = make([]string, 0, len(fields))
                _spec.Node.Columns = append(_spec.Node.Columns, polloption.FieldID)
                for i := range fields </span><span class="cov0" title="0">{
                        if fields[i] != polloption.FieldID </span><span class="cov0" title="0">{
                                _spec.Node.Columns = append(_spec.Node.Columns, fields[i])
                        }</span>
                }
                <span class="cov0" title="0">if _q.withPoll != nil </span><span class="cov0" title="0">{
                        _spec.Node.AddColumnOnce(polloption.FieldPollID)
                }</span>
        }
        <span class="cov0" title="0">if ps := _q.predicates; len(ps) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Predicate = func(selector *sql.Selector) </span><span class="cov0" title="0">{
                        for i := range ps </span><span class="cov0" title="0">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov0" title="0">if limit := _q.ctx.Limit; limit != nil </span><span class="cov0" title="0">{
                _spec.Limit = *limit
        }</span>
        <span class="cov0" title="0">if offset := _q.ctx.Offset; offset != nil </span><span class="cov0" title="0">{
                _spec.Offset = *offset
        }</span>
        <span class="cov0" title="0">if ps := _q.order; len(ps) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Order = func(selector *sql.Selector) </span><span class="cov0" title="0">{
                        for i := range ps </span><span class="cov0" title="0">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov0" title="0">return _spec</span>
}

func (_q *PollOptionQuery) sqlQuery(ctx context.Context) *sql.Selector <span class="cov0" title="0">{
        builder := sql.Dialect(_q.driver.Dialect())
        t1 := builder.Table(polloption.Table)
        columns := _q.ctx.Fields
        if len(columns) == 0 </span><span class="cov0" title="0">{
                columns = polloption.Columns
        }</span>
        <span class="cov0" title="0">selector := builder.Select(t1.Columns(columns...)...).From(t1)
        if _q.sql != nil </span><span class="cov0" title="0">{
                selector = _q.sql
                selector.Select(selector.Columns(columns...)...)
        }</span>
        <span class="cov0" title="0">if _q.ctx.Unique != nil &amp;&amp; *_q.ctx.Unique </span><span class="cov0" title="0">{
                selector.Distinct()
        }</span>
        <span class="cov0" title="0">for _, p := range _q.predicates </span><span class="cov0" title="0">{
                p(selector)
        }</span>
        <span class="cov0" title="0">for _, p := range _q.order </span><span class="cov0" title="0">{
                p(selector)
        }</span>
        <span class="cov0" title="0">if offset := _q.ctx.Offset; offset != nil </span><span class="cov0" title="0">{
                // limit is mandatory for offset clause. We start
                // with default value, and override it below if needed.
                selector.Offset(*offset).Limit(math.MaxInt32)
        }</span>
        <span class="cov0" title="0">if limit := _q.ctx.Limit; limit != nil </span><span class="cov0" title="0">{
                selector.Limit(*limit)
        }</span>
        <span class="cov0" title="0">return selector</span>
}

// PollOptionGroupBy is the group-by builder for PollOption entities.
type PollOptionGroupBy struct {
        selector
        build *PollOptionQuery
}

// Aggregate adds the given aggregation functions to the group-by query.
func (_g *PollOptionGroupBy) Aggregate(fns ...AggregateFunc) *PollOptionGroupBy <span class="cov0" title="0">{
        _g.fns = append(_g.fns, fns...)
        return _g
}</span>

// Scan applies the selector query and scans the result into the given value.
func (_g *PollOptionGroupBy) Scan(ctx context.Context, v any) error <span class="cov0" title="0">{
        ctx = setContextOp(ctx, _g.build.ctx, ent.OpQueryGroupBy)
        if err := _g.build.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return scanWithInterceptors[*PollOptionQuery, *PollOptionGroupBy](ctx, _g.build, _g, _g.build.inters, v)</span>
}

func (_g *PollOptionGroupBy) sqlScan(ctx context.Context, root *PollOptionQuery, v any) error <span class="cov0" title="0">{
        selector := root.sqlQuery(ctx).Select()
        aggregation := make([]string, 0, len(_g.fns))
        for _, fn := range _g.fns </span><span class="cov0" title="0">{
                aggregation = append(aggregation, fn(selector))
        }</span>
        <span class="cov0" title="0">if len(selector.SelectedColumns()) == 0 </span><span class="cov0" title="0">{
                columns := make([]string, 0, len(*_g.flds)+len(_g.fns))
                for _, f := range *_g.flds </span><span class="cov0" title="0">{
                        columns = append(columns, selector.C(f))
                }</span>
                <span class="cov0" title="0">columns = append(columns, aggregation...)
                selector.Select(columns...)</span>
        }
        <span class="cov0" title="0">selector.GroupBy(selector.Columns(*_g.flds...)...)
        if err := selector.Err(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">rows := &amp;sql.Rows{}
        query, args := selector.Query()
        if err := _g.build.driver.Query(ctx, query, args, rows); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        return sql.ScanSlice(rows, v)</span>
}

// PollOptionSelect is the builder for selecting fields of PollOption entities.
type PollOptionSelect struct {
        *PollOptionQuery
        selector
}

// Aggregate adds the given aggregation functions to the selector query.
func (_s *PollOptionSelect) Aggregate(fns ...AggregateFunc) *PollOptionSelect <span class="cov0" title="0">{
        _s.fns = append(_s.fns, fns...)
        return _s
}</span>

// Scan applies the selector query and scans the result into the given value.
func (_s *PollOptionSelect) Scan(ctx context.Context, v any) error <span class="cov0" title="0">{
        ctx = setContextOp(ctx, _s.ctx, ent.OpQuerySelect)
        if err := _s.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return scanWithInterceptors[*PollOptionQuery, *PollOptionSelect](ctx, _s.PollOptionQuery, _s, _s.inters, v)</span>
}

func (_s *PollOptionSelect) sqlScan(ctx context.Context, root *PollOptionQuery, v any) error <span class="cov0" title="0">{
        selector := root.sqlQuery(ctx)
        aggregation := make([]string, 0, len(_s.fns))
        for _, fn := range _s.fns </span><span class="cov0" title="0">{
                aggregation = append(aggregation, fn(selector))
        }</span>
        <span class="cov0" title="0">switch n := len(*_s.selector.flds); </span>{
        case n == 0 &amp;&amp; len(aggregation) &gt; 0:<span class="cov0" title="0">
                selector.Select(aggregation...)</span>
        case n != 0 &amp;&amp; len(aggregation) &gt; 0:<span class="cov0" title="0">
                selector.AppendSelect(aggregation...)</span>
        }
        <span class="cov0" title="0">rows := &amp;sql.Rows{}
        query, args := selector.Query()
        if err := _s.driver.Query(ctx, query, args, rows); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        return sql.ScanSlice(rows, v)</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "context"
        "errors"
        "fmt"
        "time"

        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
        "entgo.io/ent/schema/field"
        "github.com/ivankorhner/polling-app/internal/ent/polloption"
        "github.com/ivankorhner/polling-app/internal/ent/predicate"
        "github.com/ivankorhner/polling-app/internal/ent/vote"
)

// PollOptionUpdate is the builder for updating PollOption entities.
type PollOptionUpdate struct {
        config
        hooks    []Hook
        mutation *PollOptionMutation
}

// Where appends a list predicates to the PollOptionUpdate builder.
func (_u *PollOptionUpdate) Where(ps ...predicate.PollOption) *PollOptionUpdate <span class="cov0" title="0">{
        _u.mutation.Where(ps...)
        return _u
}</span>

// SetText sets the "text" field.
func (_u *PollOptionUpdate) SetText(v string) *PollOptionUpdate <span class="cov0" title="0">{
        _u.mutation.SetText(v)
        return _u
}</span>

// SetNillableText sets the "text" field if the given value is not nil.
func (_u *PollOptionUpdate) SetNillableText(v *string) *PollOptionUpdate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetText(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// SetCreatedAt sets the "created_at" field.
func (_u *PollOptionUpdate) SetCreatedAt(v time.Time) *PollOptionUpdate <span class="cov0" title="0">{
        _u.mutation.SetCreatedAt(v)
        return _u
}</span>

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (_u *PollOptionUpdate) SetNillableCreatedAt(v *time.Time) *PollOptionUpdate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetCreatedAt(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// AddVoteIDs adds the "votes" edge to the Vote entity by IDs.
func (_u *PollOptionUpdate) AddVoteIDs(ids ...int) *PollOptionUpdate <span class="cov0" title="0">{
        _u.mutation.AddVoteIDs(ids...)
        return _u
}</span>

// AddVotes adds the "votes" edges to the Vote entity.
func (_u *PollOptionUpdate) AddVotes(v ...*Vote) *PollOptionUpdate <span class="cov0" title="0">{
        ids := make([]int, len(v))
        for i := range v </span><span class="cov0" title="0">{
                ids[i] = v[i].ID
        }</span>
        <span class="cov0" title="0">return _u.AddVoteIDs(ids...)</span>
}

// Mutation returns the PollOptionMutation object of the builder.
func (_u *PollOptionUpdate) Mutation() *PollOptionMutation <span class="cov0" title="0">{
        return _u.mutation
}</span>

// ClearVotes clears all "votes" edges to the Vote entity.
func (_u *PollOptionUpdate) ClearVotes() *PollOptionUpdate <span class="cov0" title="0">{
        _u.mutation.ClearVotes()
        return _u
}</span>

// RemoveVoteIDs removes the "votes" edge to Vote entities by IDs.
func (_u *PollOptionUpdate) RemoveVoteIDs(ids ...int) *PollOptionUpdate <span class="cov0" title="0">{
        _u.mutation.RemoveVoteIDs(ids...)
        return _u
}</span>

// RemoveVotes removes "votes" edges to Vote entities.
func (_u *PollOptionUpdate) RemoveVotes(v ...*Vote) *PollOptionUpdate <span class="cov0" title="0">{
        ids := make([]int, len(v))
        for i := range v </span><span class="cov0" title="0">{
                ids[i] = v[i].ID
        }</span>
        <span class="cov0" title="0">return _u.RemoveVoteIDs(ids...)</span>
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (_u *PollOptionUpdate) Save(ctx context.Context) (int, error) <span class="cov0" title="0">{
        return withHooks(ctx, _u.sqlSave, _u.mutation, _u.hooks)
}</span>

// SaveX is like Save, but panics if an error occurs.
func (_u *PollOptionUpdate) SaveX(ctx context.Context) int <span class="cov0" title="0">{
        affected, err := _u.Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return affected</span>
}

// Exec executes the query.
func (_u *PollOptionUpdate) Exec(ctx context.Context) error <span class="cov0" title="0">{
        _, err := _u.Save(ctx)
        return err
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (_u *PollOptionUpdate) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := _u.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// check runs all checks and user-defined validators on the builder.
func (_u *PollOptionUpdate) check() error <span class="cov0" title="0">{
        if v, ok := _u.mutation.Text(); ok </span><span class="cov0" title="0">{
                if err := polloption.TextValidator(v); err != nil </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: "text", err: fmt.Errorf(`ent: validator failed for field "PollOption.text": %w`, err)}
                }</span>
        }
        <span class="cov0" title="0">if _u.mutation.PollCleared() &amp;&amp; len(_u.mutation.PollIDs()) &gt; 0 </span><span class="cov0" title="0">{
                return errors.New(`ent: clearing a required unique edge "PollOption.poll"`)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (_u *PollOptionUpdate) sqlSave(ctx context.Context) (_node int, err error) <span class="cov0" title="0">{
        if err := _u.check(); err != nil </span><span class="cov0" title="0">{
                return _node, err
        }</span>
        <span class="cov0" title="0">_spec := sqlgraph.NewUpdateSpec(polloption.Table, polloption.Columns, sqlgraph.NewFieldSpec(polloption.FieldID, field.TypeInt))
        if ps := _u.mutation.predicates; len(ps) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Predicate = func(selector *sql.Selector) </span><span class="cov0" title="0">{
                        for i := range ps </span><span class="cov0" title="0">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov0" title="0">if value, ok := _u.mutation.Text(); ok </span><span class="cov0" title="0">{
                _spec.SetField(polloption.FieldText, field.TypeString, value)
        }</span>
        <span class="cov0" title="0">if value, ok := _u.mutation.CreatedAt(); ok </span><span class="cov0" title="0">{
                _spec.SetField(polloption.FieldCreatedAt, field.TypeTime, value)
        }</span>
        <span class="cov0" title="0">if _u.mutation.VotesCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   polloption.VotesTable,
                        Columns: []string{polloption.VotesColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(vote.FieldID, field.TypeInt),
                        },
                }
                _spec.Edges.Clear = append(_spec.Edges.Clear, edge)
        }</span>
        <span class="cov0" title="0">if nodes := _u.mutation.RemovedVotesIDs(); len(nodes) &gt; 0 &amp;&amp; !_u.mutation.VotesCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   polloption.VotesTable,
                        Columns: []string{polloption.VotesColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(vote.FieldID, field.TypeInt),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges.Clear = append(_spec.Edges.Clear, edge)</span>
        }
        <span class="cov0" title="0">if nodes := _u.mutation.VotesIDs(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   polloption.VotesTable,
                        Columns: []string{polloption.VotesColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(vote.FieldID, field.TypeInt),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges.Add = append(_spec.Edges.Add, edge)</span>
        }
        <span class="cov0" title="0">if _node, err = sqlgraph.UpdateNodes(ctx, _u.driver, _spec); err != nil </span><span class="cov0" title="0">{
                if _, ok := err.(*sqlgraph.NotFoundError); ok </span><span class="cov0" title="0">{
                        err = &amp;NotFoundError{polloption.Label}
                }</span> else<span class="cov0" title="0"> if sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                        err = &amp;ConstraintError{msg: err.Error(), wrap: err}
                }</span>
                <span class="cov0" title="0">return 0, err</span>
        }
        <span class="cov0" title="0">_u.mutation.done = true
        return _node, nil</span>
}

// PollOptionUpdateOne is the builder for updating a single PollOption entity.
type PollOptionUpdateOne struct {
        config
        fields   []string
        hooks    []Hook
        mutation *PollOptionMutation
}

// SetText sets the "text" field.
func (_u *PollOptionUpdateOne) SetText(v string) *PollOptionUpdateOne <span class="cov0" title="0">{
        _u.mutation.SetText(v)
        return _u
}</span>

// SetNillableText sets the "text" field if the given value is not nil.
func (_u *PollOptionUpdateOne) SetNillableText(v *string) *PollOptionUpdateOne <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetText(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// SetCreatedAt sets the "created_at" field.
func (_u *PollOptionUpdateOne) SetCreatedAt(v time.Time) *PollOptionUpdateOne <span class="cov0" title="0">{
        _u.mutation.SetCreatedAt(v)
        return _u
}</span>

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (_u *PollOptionUpdateOne) SetNillableCreatedAt(v *time.Time) *PollOptionUpdateOne <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetCreatedAt(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// AddVoteIDs adds the "votes" edge to the Vote entity by IDs.
func (_u *PollOptionUpdateOne) AddVoteIDs(ids ...int) *PollOptionUpdateOne <span class="cov0" title="0">{
        _u.mutation.AddVoteIDs(ids...)
        return _u
}</span>

// AddVotes adds the "votes" edges to the Vote entity.
func (_u *PollOptionUpdateOne) AddVotes(v ...*Vote) *PollOptionUpdateOne <span class="cov0" title="0">{
        ids := make([]int, len(v))
        for i := range v </span><span class="cov0" title="0">{
                ids[i] = v[i].ID
        }</span>
        <span class="cov0" title="0">return _u.AddVoteIDs(ids...)</span>
}

// Mutation returns the PollOptionMutation object of the builder.
func (_u *PollOptionUpdateOne) Mutation() *PollOptionMutation <span class="cov0" title="0">{
        return _u.mutation
}</span>

// ClearVotes clears all "votes" edges to the Vote entity.
func (_u *PollOptionUpdateOne) ClearVotes() *PollOptionUpdateOne <span class="cov0" title="0">{
        _u.mutation.ClearVotes()
        return _u
}</span>

// RemoveVoteIDs removes the "votes" edge to Vote entities by IDs.
func (_u *PollOptionUpdateOne) RemoveVoteIDs(ids ...int) *PollOptionUpdateOne <span class="cov0" title="0">{
        _u.mutation.RemoveVoteIDs(ids...)
        return _u
}</span>

// RemoveVotes removes "votes" edges to Vote entities.
func (_u *PollOptionUpdateOne) RemoveVotes(v ...*Vote) *PollOptionUpdateOne <span class="cov0" title="0">{
        ids := make([]int, len(v))
        for i := range v </span><span class="cov0" title="0">{
                ids[i] = v[i].ID
        }</span>
        <span class="cov0" title="0">return _u.RemoveVoteIDs(ids...)</span>
}

// Where appends a list predicates to the PollOptionUpdate builder.
func (_u *PollOptionUpdateOne) Where(ps ...predicate.PollOption) *PollOptionUpdateOne <span class="cov0" title="0">{
        _u.mutation.Where(ps...)
        return _u
}</span>

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (_u *PollOptionUpdateOne) Select(field string, fields ...string) *PollOptionUpdateOne <span class="cov0" title="0">{
        _u.fields = append([]string{field}, fields...)
        return _u
}</span>

// Save executes the query and returns the updated PollOption entity.
func (_u *PollOptionUpdateOne) Save(ctx context.Context) (*PollOption, error) <span class="cov0" title="0">{
        return withHooks(ctx, _u.sqlSave, _u.mutation, _u.hooks)
}</span>

// SaveX is like Save, but panics if an error occurs.
func (_u *PollOptionUpdateOne) SaveX(ctx context.Context) *PollOption <span class="cov0" title="0">{
        node, err := _u.Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return node</span>
}

// Exec executes the query on the entity.
func (_u *PollOptionUpdateOne) Exec(ctx context.Context) error <span class="cov0" title="0">{
        _, err := _u.Save(ctx)
        return err
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (_u *PollOptionUpdateOne) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := _u.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// check runs all checks and user-defined validators on the builder.
func (_u *PollOptionUpdateOne) check() error <span class="cov0" title="0">{
        if v, ok := _u.mutation.Text(); ok </span><span class="cov0" title="0">{
                if err := polloption.TextValidator(v); err != nil </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: "text", err: fmt.Errorf(`ent: validator failed for field "PollOption.text": %w`, err)}
                }</span>
        }
        <span class="cov0" title="0">if _u.mutation.PollCleared() &amp;&amp; len(_u.mutation.PollIDs()) &gt; 0 </span><span class="cov0" title="0">{
                return errors.New(`ent: clearing a required unique edge "PollOption.poll"`)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (_u *PollOptionUpdateOne) sqlSave(ctx context.Context) (_node *PollOption, err error) <span class="cov0" title="0">{
        if err := _u.check(); err != nil </span><span class="cov0" title="0">{
                return _node, err
        }</span>
        <span class="cov0" title="0">_spec := sqlgraph.NewUpdateSpec(polloption.Table, polloption.Columns, sqlgraph.NewFieldSpec(polloption.FieldID, field.TypeInt))
        id, ok := _u.mutation.ID()
        if !ok </span><span class="cov0" title="0">{
                return nil, &amp;ValidationError{Name: "id", err: errors.New(`ent: missing "PollOption.id" for update`)}
        }</span>
        <span class="cov0" title="0">_spec.Node.ID.Value = id
        if fields := _u.fields; len(fields) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Node.Columns = make([]string, 0, len(fields))
                _spec.Node.Columns = append(_spec.Node.Columns, polloption.FieldID)
                for _, f := range fields </span><span class="cov0" title="0">{
                        if !polloption.ValidColumn(f) </span><span class="cov0" title="0">{
                                return nil, &amp;ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
                        }</span>
                        <span class="cov0" title="0">if f != polloption.FieldID </span><span class="cov0" title="0">{
                                _spec.Node.Columns = append(_spec.Node.Columns, f)
                        }</span>
                }
        }
        <span class="cov0" title="0">if ps := _u.mutation.predicates; len(ps) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Predicate = func(selector *sql.Selector) </span><span class="cov0" title="0">{
                        for i := range ps </span><span class="cov0" title="0">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov0" title="0">if value, ok := _u.mutation.Text(); ok </span><span class="cov0" title="0">{
                _spec.SetField(polloption.FieldText, field.TypeString, value)
        }</span>
        <span class="cov0" title="0">if value, ok := _u.mutation.CreatedAt(); ok </span><span class="cov0" title="0">{
                _spec.SetField(polloption.FieldCreatedAt, field.TypeTime, value)
        }</span>
        <span class="cov0" title="0">if _u.mutation.VotesCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   polloption.VotesTable,
                        Columns: []string{polloption.VotesColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(vote.FieldID, field.TypeInt),
                        },
                }
                _spec.Edges.Clear = append(_spec.Edges.Clear, edge)
        }</span>
        <span class="cov0" title="0">if nodes := _u.mutation.RemovedVotesIDs(); len(nodes) &gt; 0 &amp;&amp; !_u.mutation.VotesCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   polloption.VotesTable,
                        Columns: []string{polloption.VotesColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(vote.FieldID, field.TypeInt),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges.Clear = append(_spec.Edges.Clear, edge)</span>
        }
        <span class="cov0" title="0">if nodes := _u.mutation.VotesIDs(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   polloption.VotesTable,
                        Columns: []string{polloption.VotesColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(vote.FieldID, field.TypeInt),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges.Add = append(_spec.Edges.Add, edge)</span>
        }
        <span class="cov0" title="0">_node = &amp;PollOption{config: _u.config}
        _spec.Assign = _node.assignValues
        _spec.ScanValues = _node.scanValues
        if err = sqlgraph.UpdateNode(ctx, _u.driver, _spec); err != nil </span><span class="cov0" title="0">{
                if _, ok := err.(*sqlgraph.NotFoundError); ok </span><span class="cov0" title="0">{
                        err = &amp;NotFoundError{polloption.Label}
                }</span> else<span class="cov0" title="0"> if sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                        err = &amp;ConstraintError{msg: err.Error(), wrap: err}
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">_u.mutation.done = true
        return _node, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "time"

        "github.com/ivankorhner/polling-app/internal/ent/poll"
        "github.com/ivankorhner/polling-app/internal/ent/polloption"
        "github.com/ivankorhner/polling-app/internal/ent/schema"
        "github.com/ivankorhner/polling-app/internal/ent/user"
        "github.com/ivankorhner/polling-app/internal/ent/vote"
)

// The init function reads all schema descriptors with runtime code
// (default values, validators, hooks and policies) and stitches it
// to their package variables.
func init() <span class="cov0" title="0">{
        pollFields := schema.Poll{}.Fields()
        _ = pollFields
        // pollDescTitle is the schema descriptor for title field.
        pollDescTitle := pollFields[2].Descriptor()
        // poll.TitleValidator is a validator for the "title" field. It is called by the builders before save.
        poll.TitleValidator = pollDescTitle.Validators[0].(func(string) error)
        // pollDescCreatedAt is the schema descriptor for created_at field.
        pollDescCreatedAt := pollFields[3].Descriptor()
        // poll.DefaultCreatedAt holds the default value on creation for the created_at field.
        poll.DefaultCreatedAt = pollDescCreatedAt.Default.(func() time.Time)
        polloptionFields := schema.PollOption{}.Fields()
        _ = polloptionFields
        // polloptionDescText is the schema descriptor for text field.
        polloptionDescText := polloptionFields[2].Descriptor()
        // polloption.TextValidator is a validator for the "text" field. It is called by the builders before save.
        polloption.TextValidator = polloptionDescText.Validators[0].(func(string) error)
        // polloptionDescCreatedAt is the schema descriptor for created_at field.
        polloptionDescCreatedAt := polloptionFields[3].Descriptor()
        // polloption.DefaultCreatedAt holds the default value on creation for the created_at field.
        polloption.DefaultCreatedAt = polloptionDescCreatedAt.Default.(func() time.Time)
        userFields := schema.User{}.Fields()
        _ = userFields
        // userDescUsername is the schema descriptor for username field.
        userDescUsername := userFields[1].Descriptor()
        // user.UsernameValidator is a validator for the "username" field. It is called by the builders before save.
        user.UsernameValidator = userDescUsername.Validators[0].(func(string) error)
        // userDescEmail is the schema descriptor for email field.
        userDescEmail := userFields[2].Descriptor()
        // user.EmailValidator is a validator for the "email" field. It is called by the builders before save.
        user.EmailValidator = userDescEmail.Validators[0].(func(string) error)
        // userDescCreatedAt is the schema descriptor for created_at field.
        userDescCreatedAt := userFields[3].Descriptor()
        // user.DefaultCreatedAt holds the default value on creation for the created_at field.
        user.DefaultCreatedAt = userDescCreatedAt.Default.(func() time.Time)
        voteFields := schema.Vote{}.Fields()
        _ = voteFields
        // voteDescCreatedAt is the schema descriptor for created_at field.
        voteDescCreatedAt := voteFields[4].Descriptor()
        // vote.DefaultCreatedAt holds the default value on creation for the created_at field.
        vote.DefaultCreatedAt = voteDescCreatedAt.Default.(func() time.Time)
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package schema

import (
        "time"

        "entgo.io/ent"
        "entgo.io/ent/dialect/entsql"
        "entgo.io/ent/schema/edge"
        "entgo.io/ent/schema/field"
)

// Poll holds the schema definition for the Poll entity.
type Poll struct {
        ent.Schema
}

// Fields of the Poll.
func (Poll) Fields() []ent.Field <span class="cov0" title="0">{
        return []ent.Field{
                field.Int("id"),
                field.Int("owner_id"),
                field.String("title").
                        NotEmpty(),
                field.Time("created_at").
                        Default(time.Now).
                        Immutable(),
        }
}</span>

// Edges of the Poll.
func (Poll) Edges() []ent.Edge <span class="cov0" title="0">{
        return []ent.Edge{
                edge.From("owner", User.Type).
                        Ref("polls").
                        Field("owner_id").
                        Unique().
                        Required().
                        Annotations(entsql.OnDelete(entsql.Cascade)),
                edge.To("options", PollOption.Type).
                        Annotations(entsql.OnDelete(entsql.Cascade)),
                edge.To("votes", Vote.Type).
                        Annotations(entsql.OnDelete(entsql.Cascade)),
        }
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package schema

import (
        "time"

        "entgo.io/ent"
        "entgo.io/ent/schema/edge"
        "entgo.io/ent/schema/field"
)

// PollOption holds the schema definition for the PollOption entity.
type PollOption struct {
        ent.Schema
}

// Fields of the PollOption.
func (PollOption) Fields() []ent.Field <span class="cov0" title="0">{
        return []ent.Field{
                field.Int("id"),
                field.Int("poll_id").
                        Immutable(),
                field.String("text").
                        NotEmpty(),
                field.Time("created_at").
                        Default(time.Now),
        }
}</span>

// Edges of the PollOption.
func (PollOption) Edges() []ent.Edge <span class="cov0" title="0">{
        return []ent.Edge{
                edge.From("poll", Poll.Type).
                        Ref("options").
                        Field("poll_id").
                        Unique().
                        Required().
                        Immutable(),
                edge.To("votes", Vote.Type),
        }
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package schema

import (
        "time"

        "entgo.io/ent"
        "entgo.io/ent/schema/edge"
        "entgo.io/ent/schema/field"
)

// User holds the schema definition for the User entity.
type User struct {
        ent.Schema
}

// Fields of the User.
func (User) Fields() []ent.Field <span class="cov0" title="0">{
        return []ent.Field{
                field.Int("id"),
                field.String("username").
                        NotEmpty().
                        Unique(),
                field.String("email").
                        NotEmpty().
                        Unique(),
                field.Time("created_at").
                        Default(time.Now).
                        Immutable(),
        }
}</span>

// Edges of the User.
func (User) Edges() []ent.Edge <span class="cov0" title="0">{
        return []ent.Edge{
                edge.To("polls", Poll.Type),
                edge.To("votes", Vote.Type),
        }
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package schema

import (
        "time"

        "entgo.io/ent"
        "entgo.io/ent/dialect/entsql"
        "entgo.io/ent/schema/edge"
        "entgo.io/ent/schema/field"
        "entgo.io/ent/schema/index"
)

// Vote holds the schema definition for the Vote entity.
type Vote struct {
        ent.Schema
}

// Fields of the Vote.
func (Vote) Fields() []ent.Field <span class="cov0" title="0">{
        return []ent.Field{
                field.Int("id"),
                field.Int("poll_id").
                        Immutable(),
                field.Int("option_id").
                        Immutable(),
                field.Int("user_id").
                        Immutable(),
                field.Time("created_at").
                        Default(time.Now).
                        Immutable(),
        }
}</span>

// Edges of the Vote.
func (Vote) Edges() []ent.Edge <span class="cov0" title="0">{
        return []ent.Edge{
                edge.From("poll", Poll.Type).
                        Ref("votes").
                        Field("poll_id").
                        Required().
                        Unique().
                        Immutable(),
                edge.From("option", PollOption.Type).
                        Ref("votes").
                        Field("option_id").
                        Required().
                        Unique().
                        Immutable().
                        Annotations(entsql.OnDelete(entsql.Cascade)),
                edge.From("user", User.Type).
                        Ref("votes").
                        Field("user_id").
                        Required().
                        Unique().
                        Immutable().
                        Annotations(entsql.OnDelete(entsql.Cascade)),
        }
}</span>

// Indexes of the Vote - prevents duplicate votes from same user on same poll
func (Vote) Indexes() []ent.Index <span class="cov0" title="0">{
        return []ent.Index{
                index.Fields("user_id", "poll_id").
                        Unique(),
        }
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "context"
        "sync"

        "entgo.io/ent/dialect"
)

// Tx is a transactional client that is created by calling Client.Tx().
type Tx struct {
        config
        // Poll is the client for interacting with the Poll builders.
        Poll *PollClient
        // PollOption is the client for interacting with the PollOption builders.
        PollOption *PollOptionClient
        // User is the client for interacting with the User builders.
        User *UserClient
        // Vote is the client for interacting with the Vote builders.
        Vote *VoteClient

        // lazily loaded.
        client     *Client
        clientOnce sync.Once
        // ctx lives for the life of the transaction. It is
        // the same context used by the underlying connection.
        ctx context.Context
}

type (
        // Committer is the interface that wraps the Commit method.
        Committer interface {
                Commit(context.Context, *Tx) error
        }

        // The CommitFunc type is an adapter to allow the use of ordinary
        // function as a Committer. If f is a function with the appropriate
        // signature, CommitFunc(f) is a Committer that calls f.
        CommitFunc func(context.Context, *Tx) error

        // CommitHook defines the "commit middleware". A function that gets a Committer
        // and returns a Committer. For example:
        //
        //        hook := func(next ent.Committer) ent.Committer {
        //                return ent.CommitFunc(func(ctx context.Context, tx *ent.Tx) error {
        //                        // Do some stuff before.
        //                        if err := next.Commit(ctx, tx); err != nil {
        //                                return err
        //                        }
        //                        // Do some stuff after.
        //                        return nil
        //                })
        //        }
        //
        CommitHook func(Committer) Committer
)

// Commit calls f(ctx, m).
func (f CommitFunc) Commit(ctx context.Context, tx *Tx) error <span class="cov0" title="0">{
        return f(ctx, tx)
}</span>

// Commit commits the transaction.
func (tx *Tx) Commit() error <span class="cov0" title="0">{
        txDriver := tx.config.driver.(*txDriver)
        var fn Committer = CommitFunc(func(context.Context, *Tx) error </span><span class="cov0" title="0">{
                return txDriver.tx.Commit()
        }</span>)
        <span class="cov0" title="0">txDriver.mu.Lock()
        hooks := append([]CommitHook(nil), txDriver.onCommit...)
        txDriver.mu.Unlock()
        for i := len(hooks) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                fn = hooks[i](fn)
        }</span>
        <span class="cov0" title="0">return fn.Commit(tx.ctx, tx)</span>
}

// OnCommit adds a hook to call on commit.
func (tx *Tx) OnCommit(f CommitHook) <span class="cov0" title="0">{
        txDriver := tx.config.driver.(*txDriver)
        txDriver.mu.Lock()
        txDriver.onCommit = append(txDriver.onCommit, f)
        txDriver.mu.Unlock()
}</span>

type (
        // Rollbacker is the interface that wraps the Rollback method.
        Rollbacker interface {
                Rollback(context.Context, *Tx) error
        }

        // The RollbackFunc type is an adapter to allow the use of ordinary
        // function as a Rollbacker. If f is a function with the appropriate
        // signature, RollbackFunc(f) is a Rollbacker that calls f.
        RollbackFunc func(context.Context, *Tx) error

        // RollbackHook defines the "rollback middleware". A function that gets a Rollbacker
        // and returns a Rollbacker. For example:
        //
        //        hook := func(next ent.Rollbacker) ent.Rollbacker {
        //                return ent.RollbackFunc(func(ctx context.Context, tx *ent.Tx) error {
        //                        // Do some stuff before.
        //                        if err := next.Rollback(ctx, tx); err != nil {
        //                                return err
        //                        }
        //                        // Do some stuff after.
        //                        return nil
        //                })
        //        }
        //
        RollbackHook func(Rollbacker) Rollbacker
)

// Rollback calls f(ctx, m).
func (f RollbackFunc) Rollback(ctx context.Context, tx *Tx) error <span class="cov0" title="0">{
        return f(ctx, tx)
}</span>

// Rollback rollbacks the transaction.
func (tx *Tx) Rollback() error <span class="cov0" title="0">{
        txDriver := tx.config.driver.(*txDriver)
        var fn Rollbacker = RollbackFunc(func(context.Context, *Tx) error </span><span class="cov0" title="0">{
                return txDriver.tx.Rollback()
        }</span>)
        <span class="cov0" title="0">txDriver.mu.Lock()
        hooks := append([]RollbackHook(nil), txDriver.onRollback...)
        txDriver.mu.Unlock()
        for i := len(hooks) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                fn = hooks[i](fn)
        }</span>
        <span class="cov0" title="0">return fn.Rollback(tx.ctx, tx)</span>
}

// OnRollback adds a hook to call on rollback.
func (tx *Tx) OnRollback(f RollbackHook) <span class="cov0" title="0">{
        txDriver := tx.config.driver.(*txDriver)
        txDriver.mu.Lock()
        txDriver.onRollback = append(txDriver.onRollback, f)
        txDriver.mu.Unlock()
}</span>

// Client returns a Client that binds to current transaction.
func (tx *Tx) Client() *Client <span class="cov0" title="0">{
        tx.clientOnce.Do(func() </span><span class="cov0" title="0">{
                tx.client = &amp;Client{config: tx.config}
                tx.client.init()
        }</span>)
        <span class="cov0" title="0">return tx.client</span>
}

func (tx *Tx) init() <span class="cov0" title="0">{
        tx.Poll = NewPollClient(tx.config)
        tx.PollOption = NewPollOptionClient(tx.config)
        tx.User = NewUserClient(tx.config)
        tx.Vote = NewVoteClient(tx.config)
}</span>

// txDriver wraps the given dialect.Tx with a nop dialect.Driver implementation.
// The idea is to support transactions without adding any extra code to the builders.
// When a builder calls to driver.Tx(), it gets the same dialect.Tx instance.
// Commit and Rollback are nop for the internal builders and the user must call one
// of them in order to commit or rollback the transaction.
//
// If a closed transaction is embedded in one of the generated entities, and the entity
// applies a query, for example: Poll.QueryXXX(), the query will be executed
// through the driver which created this transaction.
//
// Note that txDriver is not goroutine safe.
type txDriver struct {
        // the driver we started the transaction from.
        drv dialect.Driver
        // tx is the underlying transaction.
        tx dialect.Tx
        // completion hooks.
        mu         sync.Mutex
        onCommit   []CommitHook
        onRollback []RollbackHook
}

// newTx creates a new transactional driver.
func newTx(ctx context.Context, drv dialect.Driver) (*txDriver, error) <span class="cov0" title="0">{
        tx, err := drv.Tx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;txDriver{tx: tx, drv: drv}, nil</span>
}

// Tx returns the transaction wrapper (txDriver) to avoid Commit or Rollback calls
// from the internal builders. Should be called only by the internal builders.
func (tx *txDriver) Tx(context.Context) (dialect.Tx, error) <span class="cov0" title="0">{ return tx, nil }</span>

// Dialect returns the dialect of the driver we started the transaction from.
func (tx *txDriver) Dialect() string <span class="cov0" title="0">{ return tx.drv.Dialect() }</span>

// Close is a nop close.
func (*txDriver) Close() error <span class="cov0" title="0">{ return nil }</span>

// Commit is a nop commit for the internal builders.
// User must call `Tx.Commit` in order to commit the transaction.
func (*txDriver) Commit() error <span class="cov0" title="0">{ return nil }</span>

// Rollback is a nop rollback for the internal builders.
// User must call `Tx.Rollback` in order to rollback the transaction.
func (*txDriver) Rollback() error <span class="cov0" title="0">{ return nil }</span>

// Exec calls tx.Exec.
func (tx *txDriver) Exec(ctx context.Context, query string, args, v any) error <span class="cov0" title="0">{
        return tx.tx.Exec(ctx, query, args, v)
}</span>

// Query calls tx.Query.
func (tx *txDriver) Query(ctx context.Context, query string, args, v any) error <span class="cov0" title="0">{
        return tx.tx.Query(ctx, query, args, v)
}</span>

var _ dialect.Driver = (*txDriver)(nil)
</pre>
		
		<pre class="file" id="file30" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "fmt"
        "strings"
        "time"

        "entgo.io/ent"
        "entgo.io/ent/dialect/sql"
        "github.com/ivankorhner/polling-app/internal/ent/user"
)

// User is the model entity for the User schema.
type User struct {
        config `json:"-"`
        // ID of the ent.
        ID int `json:"id,omitempty"`
        // Username holds the value of the "username" field.
        Username string `json:"username,omitempty"`
        // Email holds the value of the "email" field.
        Email string `json:"email,omitempty"`
        // CreatedAt holds the value of the "created_at" field.
        CreatedAt time.Time `json:"created_at,omitempty"`
        // Edges holds the relations/edges for other nodes in the graph.
        // The values are being populated by the UserQuery when eager-loading is set.
        Edges        UserEdges `json:"edges"`
        selectValues sql.SelectValues
}

// UserEdges holds the relations/edges for other nodes in the graph.
type UserEdges struct {
        // Polls holds the value of the polls edge.
        Polls []*Poll `json:"polls,omitempty"`
        // Votes holds the value of the votes edge.
        Votes []*Vote `json:"votes,omitempty"`
        // loadedTypes holds the information for reporting if a
        // type was loaded (or requested) in eager-loading or not.
        loadedTypes [2]bool
}

// PollsOrErr returns the Polls value or an error if the edge
// was not loaded in eager-loading.
func (e UserEdges) PollsOrErr() ([]*Poll, error) <span class="cov0" title="0">{
        if e.loadedTypes[0] </span><span class="cov0" title="0">{
                return e.Polls, nil
        }</span>
        <span class="cov0" title="0">return nil, &amp;NotLoadedError{edge: "polls"}</span>
}

// VotesOrErr returns the Votes value or an error if the edge
// was not loaded in eager-loading.
func (e UserEdges) VotesOrErr() ([]*Vote, error) <span class="cov0" title="0">{
        if e.loadedTypes[1] </span><span class="cov0" title="0">{
                return e.Votes, nil
        }</span>
        <span class="cov0" title="0">return nil, &amp;NotLoadedError{edge: "votes"}</span>
}

// scanValues returns the types for scanning values from sql.Rows.
func (*User) scanValues(columns []string) ([]any, error) <span class="cov0" title="0">{
        values := make([]any, len(columns))
        for i := range columns </span><span class="cov0" title="0">{
                switch columns[i] </span>{
                case user.FieldID:<span class="cov0" title="0">
                        values[i] = new(sql.NullInt64)</span>
                case user.FieldUsername, user.FieldEmail:<span class="cov0" title="0">
                        values[i] = new(sql.NullString)</span>
                case user.FieldCreatedAt:<span class="cov0" title="0">
                        values[i] = new(sql.NullTime)</span>
                default:<span class="cov0" title="0">
                        values[i] = new(sql.UnknownType)</span>
                }
        }
        <span class="cov0" title="0">return values, nil</span>
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the User fields.
func (_m *User) assignValues(columns []string, values []any) error <span class="cov0" title="0">{
        if m, n := len(values), len(columns); m &lt; n </span><span class="cov0" title="0">{
                return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
        }</span>
        <span class="cov0" title="0">for i := range columns </span><span class="cov0" title="0">{
                switch columns[i] </span>{
                case user.FieldID:<span class="cov0" title="0">
                        value, ok := values[i].(*sql.NullInt64)
                        if !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field id", value)
                        }</span>
                        <span class="cov0" title="0">_m.ID = int(value.Int64)</span>
                case user.FieldUsername:<span class="cov0" title="0">
                        if value, ok := values[i].(*sql.NullString); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field username", values[i])
                        }</span> else<span class="cov0" title="0"> if value.Valid </span><span class="cov0" title="0">{
                                _m.Username = value.String
                        }</span>
                case user.FieldEmail:<span class="cov0" title="0">
                        if value, ok := values[i].(*sql.NullString); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field email", values[i])
                        }</span> else<span class="cov0" title="0"> if value.Valid </span><span class="cov0" title="0">{
                                _m.Email = value.String
                        }</span>
                case user.FieldCreatedAt:<span class="cov0" title="0">
                        if value, ok := values[i].(*sql.NullTime); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field created_at", values[i])
                        }</span> else<span class="cov0" title="0"> if value.Valid </span><span class="cov0" title="0">{
                                _m.CreatedAt = value.Time
                        }</span>
                default:<span class="cov0" title="0">
                        _m.selectValues.Set(columns[i], values[i])</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// Value returns the ent.Value that was dynamically selected and assigned to the User.
// This includes values selected through modifiers, order, etc.
func (_m *User) Value(name string) (ent.Value, error) <span class="cov0" title="0">{
        return _m.selectValues.Get(name)
}</span>

// QueryPolls queries the "polls" edge of the User entity.
func (_m *User) QueryPolls() *PollQuery <span class="cov0" title="0">{
        return NewUserClient(_m.config).QueryPolls(_m)
}</span>

// QueryVotes queries the "votes" edge of the User entity.
func (_m *User) QueryVotes() *VoteQuery <span class="cov0" title="0">{
        return NewUserClient(_m.config).QueryVotes(_m)
}</span>

// Update returns a builder for updating this User.
// Note that you need to call User.Unwrap() before calling this method if this User
// was returned from a transaction, and the transaction was committed or rolled back.
func (_m *User) Update() *UserUpdateOne <span class="cov0" title="0">{
        return NewUserClient(_m.config).UpdateOne(_m)
}</span>

// Unwrap unwraps the User entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (_m *User) Unwrap() *User <span class="cov0" title="0">{
        _tx, ok := _m.config.driver.(*txDriver)
        if !ok </span><span class="cov0" title="0">{
                panic("ent: User is not a transactional entity")</span>
        }
        <span class="cov0" title="0">_m.config.driver = _tx.drv
        return _m</span>
}

// String implements the fmt.Stringer.
func (_m *User) String() string <span class="cov0" title="0">{
        var builder strings.Builder
        builder.WriteString("User(")
        builder.WriteString(fmt.Sprintf("id=%v, ", _m.ID))
        builder.WriteString("username=")
        builder.WriteString(_m.Username)
        builder.WriteString(", ")
        builder.WriteString("email=")
        builder.WriteString(_m.Email)
        builder.WriteString(", ")
        builder.WriteString("created_at=")
        builder.WriteString(_m.CreatedAt.Format(time.ANSIC))
        builder.WriteByte(')')
        return builder.String()
}</span>

// Users is a parsable slice of User.
type Users []*User
</pre>
		
		<pre class="file" id="file31" style="display: none">// Code generated by ent, DO NOT EDIT.

package user

import (
        "time"

        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
)

const (
        // Label holds the string label denoting the user type in the database.
        Label = "user"
        // FieldID holds the string denoting the id field in the database.
        FieldID = "id"
        // FieldUsername holds the string denoting the username field in the database.
        FieldUsername = "username"
        // FieldEmail holds the string denoting the email field in the database.
        FieldEmail = "email"
        // FieldCreatedAt holds the string denoting the created_at field in the database.
        FieldCreatedAt = "created_at"
        // EdgePolls holds the string denoting the polls edge name in mutations.
        EdgePolls = "polls"
        // EdgeVotes holds the string denoting the votes edge name in mutations.
        EdgeVotes = "votes"
        // Table holds the table name of the user in the database.
        Table = "users"
        // PollsTable is the table that holds the polls relation/edge.
        PollsTable = "polls"
        // PollsInverseTable is the table name for the Poll entity.
        // It exists in this package in order to avoid circular dependency with the "poll" package.
        PollsInverseTable = "polls"
        // PollsColumn is the table column denoting the polls relation/edge.
        PollsColumn = "owner_id"
        // VotesTable is the table that holds the votes relation/edge.
        VotesTable = "votes"
        // VotesInverseTable is the table name for the Vote entity.
        // It exists in this package in order to avoid circular dependency with the "vote" package.
        VotesInverseTable = "votes"
        // VotesColumn is the table column denoting the votes relation/edge.
        VotesColumn = "user_id"
)

// Columns holds all SQL columns for user fields.
var Columns = []string{
        FieldID,
        FieldUsername,
        FieldEmail,
        FieldCreatedAt,
}

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool <span class="cov0" title="0">{
        for i := range Columns </span><span class="cov0" title="0">{
                if column == Columns[i] </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

var (
        // UsernameValidator is a validator for the "username" field. It is called by the builders before save.
        UsernameValidator func(string) error
        // EmailValidator is a validator for the "email" field. It is called by the builders before save.
        EmailValidator func(string) error
        // DefaultCreatedAt holds the default value on creation for the "created_at" field.
        DefaultCreatedAt func() time.Time
)

// OrderOption defines the ordering options for the User queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldID, opts...).ToFunc()
}</span>

// ByUsername orders the results by the username field.
func ByUsername(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldUsername, opts...).ToFunc()
}</span>

// ByEmail orders the results by the email field.
func ByEmail(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldEmail, opts...).ToFunc()
}</span>

// ByCreatedAt orders the results by the created_at field.
func ByCreatedAt(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldCreatedAt, opts...).ToFunc()
}</span>

// ByPollsCount orders the results by polls count.
func ByPollsCount(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return func(s *sql.Selector) </span><span class="cov0" title="0">{
                sqlgraph.OrderByNeighborsCount(s, newPollsStep(), opts...)
        }</span>
}

// ByPolls orders the results by polls terms.
func ByPolls(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption <span class="cov0" title="0">{
        return func(s *sql.Selector) </span><span class="cov0" title="0">{
                sqlgraph.OrderByNeighborTerms(s, newPollsStep(), append([]sql.OrderTerm{term}, terms...)...)
        }</span>
}

// ByVotesCount orders the results by votes count.
func ByVotesCount(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return func(s *sql.Selector) </span><span class="cov0" title="0">{
                sqlgraph.OrderByNeighborsCount(s, newVotesStep(), opts...)
        }</span>
}

// ByVotes orders the results by votes terms.
func ByVotes(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption <span class="cov0" title="0">{
        return func(s *sql.Selector) </span><span class="cov0" title="0">{
                sqlgraph.OrderByNeighborTerms(s, newVotesStep(), append([]sql.OrderTerm{term}, terms...)...)
        }</span>
}
func newPollsStep() *sqlgraph.Step <span class="cov0" title="0">{
        return sqlgraph.NewStep(
                sqlgraph.From(Table, FieldID),
                sqlgraph.To(PollsInverseTable, FieldID),
                sqlgraph.Edge(sqlgraph.O2M, false, PollsTable, PollsColumn),
        )
}</span>
func newVotesStep() *sqlgraph.Step <span class="cov0" title="0">{
        return sqlgraph.NewStep(
                sqlgraph.From(Table, FieldID),
                sqlgraph.To(VotesInverseTable, FieldID),
                sqlgraph.Edge(sqlgraph.O2M, false, VotesTable, VotesColumn),
        )
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">// Code generated by ent, DO NOT EDIT.

package user

import (
        "time"

        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
        "github.com/ivankorhner/polling-app/internal/ent/predicate"
)

// ID filters vertices based on their ID field.
func ID(id int) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldEQ(FieldID, id))
}</span>

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id int) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldEQ(FieldID, id))
}</span>

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id int) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldNEQ(FieldID, id))
}</span>

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...int) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldIn(FieldID, ids...))
}</span>

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...int) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldNotIn(FieldID, ids...))
}</span>

// IDGT applies the GT predicate on the ID field.
func IDGT(id int) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldGT(FieldID, id))
}</span>

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id int) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldGTE(FieldID, id))
}</span>

// IDLT applies the LT predicate on the ID field.
func IDLT(id int) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldLT(FieldID, id))
}</span>

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id int) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldLTE(FieldID, id))
}</span>

// Username applies equality check predicate on the "username" field. It's identical to UsernameEQ.
func Username(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldEQ(FieldUsername, v))
}</span>

// Email applies equality check predicate on the "email" field. It's identical to EmailEQ.
func Email(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldEQ(FieldEmail, v))
}</span>

// CreatedAt applies equality check predicate on the "created_at" field. It's identical to CreatedAtEQ.
func CreatedAt(v time.Time) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldEQ(FieldCreatedAt, v))
}</span>

// UsernameEQ applies the EQ predicate on the "username" field.
func UsernameEQ(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldEQ(FieldUsername, v))
}</span>

// UsernameNEQ applies the NEQ predicate on the "username" field.
func UsernameNEQ(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldNEQ(FieldUsername, v))
}</span>

// UsernameIn applies the In predicate on the "username" field.
func UsernameIn(vs ...string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldIn(FieldUsername, vs...))
}</span>

// UsernameNotIn applies the NotIn predicate on the "username" field.
func UsernameNotIn(vs ...string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldNotIn(FieldUsername, vs...))
}</span>

// UsernameGT applies the GT predicate on the "username" field.
func UsernameGT(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldGT(FieldUsername, v))
}</span>

// UsernameGTE applies the GTE predicate on the "username" field.
func UsernameGTE(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldGTE(FieldUsername, v))
}</span>

// UsernameLT applies the LT predicate on the "username" field.
func UsernameLT(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldLT(FieldUsername, v))
}</span>

// UsernameLTE applies the LTE predicate on the "username" field.
func UsernameLTE(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldLTE(FieldUsername, v))
}</span>

// UsernameContains applies the Contains predicate on the "username" field.
func UsernameContains(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldContains(FieldUsername, v))
}</span>

// UsernameHasPrefix applies the HasPrefix predicate on the "username" field.
func UsernameHasPrefix(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldHasPrefix(FieldUsername, v))
}</span>

// UsernameHasSuffix applies the HasSuffix predicate on the "username" field.
func UsernameHasSuffix(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldHasSuffix(FieldUsername, v))
}</span>

// UsernameEqualFold applies the EqualFold predicate on the "username" field.
func UsernameEqualFold(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldEqualFold(FieldUsername, v))
}</span>

// UsernameContainsFold applies the ContainsFold predicate on the "username" field.
func UsernameContainsFold(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldContainsFold(FieldUsername, v))
}</span>

// EmailEQ applies the EQ predicate on the "email" field.
func EmailEQ(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldEQ(FieldEmail, v))
}</span>

// EmailNEQ applies the NEQ predicate on the "email" field.
func EmailNEQ(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldNEQ(FieldEmail, v))
}</span>

// EmailIn applies the In predicate on the "email" field.
func EmailIn(vs ...string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldIn(FieldEmail, vs...))
}</span>

// EmailNotIn applies the NotIn predicate on the "email" field.
func EmailNotIn(vs ...string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldNotIn(FieldEmail, vs...))
}</span>

// EmailGT applies the GT predicate on the "email" field.
func EmailGT(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldGT(FieldEmail, v))
}</span>

// EmailGTE applies the GTE predicate on the "email" field.
func EmailGTE(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldGTE(FieldEmail, v))
}</span>

// EmailLT applies the LT predicate on the "email" field.
func EmailLT(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldLT(FieldEmail, v))
}</span>

// EmailLTE applies the LTE predicate on the "email" field.
func EmailLTE(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldLTE(FieldEmail, v))
}</span>

// EmailContains applies the Contains predicate on the "email" field.
func EmailContains(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldContains(FieldEmail, v))
}</span>

// EmailHasPrefix applies the HasPrefix predicate on the "email" field.
func EmailHasPrefix(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldHasPrefix(FieldEmail, v))
}</span>

// EmailHasSuffix applies the HasSuffix predicate on the "email" field.
func EmailHasSuffix(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldHasSuffix(FieldEmail, v))
}</span>

// EmailEqualFold applies the EqualFold predicate on the "email" field.
func EmailEqualFold(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldEqualFold(FieldEmail, v))
}</span>

// EmailContainsFold applies the ContainsFold predicate on the "email" field.
func EmailContainsFold(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldContainsFold(FieldEmail, v))
}</span>

// CreatedAtEQ applies the EQ predicate on the "created_at" field.
func CreatedAtEQ(v time.Time) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldEQ(FieldCreatedAt, v))
}</span>

// CreatedAtNEQ applies the NEQ predicate on the "created_at" field.
func CreatedAtNEQ(v time.Time) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldNEQ(FieldCreatedAt, v))
}</span>

// CreatedAtIn applies the In predicate on the "created_at" field.
func CreatedAtIn(vs ...time.Time) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldIn(FieldCreatedAt, vs...))
}</span>

// CreatedAtNotIn applies the NotIn predicate on the "created_at" field.
func CreatedAtNotIn(vs ...time.Time) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldNotIn(FieldCreatedAt, vs...))
}</span>

// CreatedAtGT applies the GT predicate on the "created_at" field.
func CreatedAtGT(v time.Time) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldGT(FieldCreatedAt, v))
}</span>

// CreatedAtGTE applies the GTE predicate on the "created_at" field.
func CreatedAtGTE(v time.Time) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldGTE(FieldCreatedAt, v))
}</span>

// CreatedAtLT applies the LT predicate on the "created_at" field.
func CreatedAtLT(v time.Time) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldLT(FieldCreatedAt, v))
}</span>

// CreatedAtLTE applies the LTE predicate on the "created_at" field.
func CreatedAtLTE(v time.Time) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldLTE(FieldCreatedAt, v))
}</span>

// HasPolls applies the HasEdge predicate on the "polls" edge.
func HasPolls() predicate.User <span class="cov0" title="0">{
        return predicate.User(func(s *sql.Selector) </span><span class="cov0" title="0">{
                step := sqlgraph.NewStep(
                        sqlgraph.From(Table, FieldID),
                        sqlgraph.Edge(sqlgraph.O2M, false, PollsTable, PollsColumn),
                )
                sqlgraph.HasNeighbors(s, step)
        }</span>)
}

// HasPollsWith applies the HasEdge predicate on the "polls" edge with a given conditions (other predicates).
func HasPollsWith(preds ...predicate.Poll) predicate.User <span class="cov0" title="0">{
        return predicate.User(func(s *sql.Selector) </span><span class="cov0" title="0">{
                step := newPollsStep()
                sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) </span><span class="cov0" title="0">{
                        for _, p := range preds </span><span class="cov0" title="0">{
                                p(s)
                        }</span>
                })
        })
}

// HasVotes applies the HasEdge predicate on the "votes" edge.
func HasVotes() predicate.User <span class="cov0" title="0">{
        return predicate.User(func(s *sql.Selector) </span><span class="cov0" title="0">{
                step := sqlgraph.NewStep(
                        sqlgraph.From(Table, FieldID),
                        sqlgraph.Edge(sqlgraph.O2M, false, VotesTable, VotesColumn),
                )
                sqlgraph.HasNeighbors(s, step)
        }</span>)
}

// HasVotesWith applies the HasEdge predicate on the "votes" edge with a given conditions (other predicates).
func HasVotesWith(preds ...predicate.Vote) predicate.User <span class="cov0" title="0">{
        return predicate.User(func(s *sql.Selector) </span><span class="cov0" title="0">{
                step := newVotesStep()
                sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) </span><span class="cov0" title="0">{
                        for _, p := range preds </span><span class="cov0" title="0">{
                                p(s)
                        }</span>
                })
        })
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.User) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.AndPredicates(predicates...))
}</span>

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.User) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.OrPredicates(predicates...))
}</span>

// Not applies the not operator on the given predicate.
func Not(p predicate.User) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.NotPredicates(p))
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "context"
        "errors"
        "fmt"
        "time"

        "entgo.io/ent/dialect/sql/sqlgraph"
        "entgo.io/ent/schema/field"
        "github.com/ivankorhner/polling-app/internal/ent/poll"
        "github.com/ivankorhner/polling-app/internal/ent/user"
        "github.com/ivankorhner/polling-app/internal/ent/vote"
)

// UserCreate is the builder for creating a User entity.
type UserCreate struct {
        config
        mutation *UserMutation
        hooks    []Hook
}

// SetUsername sets the "username" field.
func (_c *UserCreate) SetUsername(v string) *UserCreate <span class="cov0" title="0">{
        _c.mutation.SetUsername(v)
        return _c
}</span>

// SetEmail sets the "email" field.
func (_c *UserCreate) SetEmail(v string) *UserCreate <span class="cov0" title="0">{
        _c.mutation.SetEmail(v)
        return _c
}</span>

// SetCreatedAt sets the "created_at" field.
func (_c *UserCreate) SetCreatedAt(v time.Time) *UserCreate <span class="cov0" title="0">{
        _c.mutation.SetCreatedAt(v)
        return _c
}</span>

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (_c *UserCreate) SetNillableCreatedAt(v *time.Time) *UserCreate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _c.SetCreatedAt(*v)
        }</span>
        <span class="cov0" title="0">return _c</span>
}

// SetID sets the "id" field.
func (_c *UserCreate) SetID(v int) *UserCreate <span class="cov0" title="0">{
        _c.mutation.SetID(v)
        return _c
}</span>

// AddPollIDs adds the "polls" edge to the Poll entity by IDs.
func (_c *UserCreate) AddPollIDs(ids ...int) *UserCreate <span class="cov0" title="0">{
        _c.mutation.AddPollIDs(ids...)
        return _c
}</span>

// AddPolls adds the "polls" edges to the Poll entity.
func (_c *UserCreate) AddPolls(v ...*Poll) *UserCreate <span class="cov0" title="0">{
        ids := make([]int, len(v))
        for i := range v </span><span class="cov0" title="0">{
                ids[i] = v[i].ID
        }</span>
        <span class="cov0" title="0">return _c.AddPollIDs(ids...)</span>
}

// AddVoteIDs adds the "votes" edge to the Vote entity by IDs.
func (_c *UserCreate) AddVoteIDs(ids ...int) *UserCreate <span class="cov0" title="0">{
        _c.mutation.AddVoteIDs(ids...)
        return _c
}</span>

// AddVotes adds the "votes" edges to the Vote entity.
func (_c *UserCreate) AddVotes(v ...*Vote) *UserCreate <span class="cov0" title="0">{
        ids := make([]int, len(v))
        for i := range v </span><span class="cov0" title="0">{
                ids[i] = v[i].ID
        }</span>
        <span class="cov0" title="0">return _c.AddVoteIDs(ids...)</span>
}

// Mutation returns the UserMutation object of the builder.
func (_c *UserCreate) Mutation() *UserMutation <span class="cov0" title="0">{
        return _c.mutation
}</span>

// Save creates the User in the database.
func (_c *UserCreate) Save(ctx context.Context) (*User, error) <span class="cov0" title="0">{
        _c.defaults()
        return withHooks(ctx, _c.sqlSave, _c.mutation, _c.hooks)
}</span>

// SaveX calls Save and panics if Save returns an error.
func (_c *UserCreate) SaveX(ctx context.Context) *User <span class="cov0" title="0">{
        v, err := _c.Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return v</span>
}

// Exec executes the query.
func (_c *UserCreate) Exec(ctx context.Context) error <span class="cov0" title="0">{
        _, err := _c.Save(ctx)
        return err
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (_c *UserCreate) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := _c.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// defaults sets the default values of the builder before save.
func (_c *UserCreate) defaults() <span class="cov0" title="0">{
        if _, ok := _c.mutation.CreatedAt(); !ok </span><span class="cov0" title="0">{
                v := user.DefaultCreatedAt()
                _c.mutation.SetCreatedAt(v)
        }</span>
}

// check runs all checks and user-defined validators on the builder.
func (_c *UserCreate) check() error <span class="cov0" title="0">{
        if _, ok := _c.mutation.Username(); !ok </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "username", err: errors.New(`ent: missing required field "User.username"`)}
        }</span>
        <span class="cov0" title="0">if v, ok := _c.mutation.Username(); ok </span><span class="cov0" title="0">{
                if err := user.UsernameValidator(v); err != nil </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: "username", err: fmt.Errorf(`ent: validator failed for field "User.username": %w`, err)}
                }</span>
        }
        <span class="cov0" title="0">if _, ok := _c.mutation.Email(); !ok </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "email", err: errors.New(`ent: missing required field "User.email"`)}
        }</span>
        <span class="cov0" title="0">if v, ok := _c.mutation.Email(); ok </span><span class="cov0" title="0">{
                if err := user.EmailValidator(v); err != nil </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: "email", err: fmt.Errorf(`ent: validator failed for field "User.email": %w`, err)}
                }</span>
        }
        <span class="cov0" title="0">if _, ok := _c.mutation.CreatedAt(); !ok </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "created_at", err: errors.New(`ent: missing required field "User.created_at"`)}
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (_c *UserCreate) sqlSave(ctx context.Context) (*User, error) <span class="cov0" title="0">{
        if err := _c.check(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">_node, _spec := _c.createSpec()
        if err := sqlgraph.CreateNode(ctx, _c.driver, _spec); err != nil </span><span class="cov0" title="0">{
                if sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                        err = &amp;ConstraintError{msg: err.Error(), wrap: err}
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">if _spec.ID.Value != _node.ID </span><span class="cov0" title="0">{
                id := _spec.ID.Value.(int64)
                _node.ID = int(id)
        }</span>
        <span class="cov0" title="0">_c.mutation.id = &amp;_node.ID
        _c.mutation.done = true
        return _node, nil</span>
}

func (_c *UserCreate) createSpec() (*User, *sqlgraph.CreateSpec) <span class="cov0" title="0">{
        var (
                _node = &amp;User{config: _c.config}
                _spec = sqlgraph.NewCreateSpec(user.Table, sqlgraph.NewFieldSpec(user.FieldID, field.TypeInt))
        )
        if id, ok := _c.mutation.ID(); ok </span><span class="cov0" title="0">{
                _node.ID = id
                _spec.ID.Value = id
        }</span>
        <span class="cov0" title="0">if value, ok := _c.mutation.Username(); ok </span><span class="cov0" title="0">{
                _spec.SetField(user.FieldUsername, field.TypeString, value)
                _node.Username = value
        }</span>
        <span class="cov0" title="0">if value, ok := _c.mutation.Email(); ok </span><span class="cov0" title="0">{
                _spec.SetField(user.FieldEmail, field.TypeString, value)
                _node.Email = value
        }</span>
        <span class="cov0" title="0">if value, ok := _c.mutation.CreatedAt(); ok </span><span class="cov0" title="0">{
                _spec.SetField(user.FieldCreatedAt, field.TypeTime, value)
                _node.CreatedAt = value
        }</span>
        <span class="cov0" title="0">if nodes := _c.mutation.PollsIDs(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   user.PollsTable,
                        Columns: []string{user.PollsColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(poll.FieldID, field.TypeInt),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges = append(_spec.Edges, edge)</span>
        }
        <span class="cov0" title="0">if nodes := _c.mutation.VotesIDs(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   user.VotesTable,
                        Columns: []string{user.VotesColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(vote.FieldID, field.TypeInt),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges = append(_spec.Edges, edge)</span>
        }
        <span class="cov0" title="0">return _node, _spec</span>
}

// UserCreateBulk is the builder for creating many User entities in bulk.
type UserCreateBulk struct {
        config
        err      error
        builders []*UserCreate
}

// Save creates the User entities in the database.
func (_c *UserCreateBulk) Save(ctx context.Context) ([]*User, error) <span class="cov0" title="0">{
        if _c.err != nil </span><span class="cov0" title="0">{
                return nil, _c.err
        }</span>
        <span class="cov0" title="0">specs := make([]*sqlgraph.CreateSpec, len(_c.builders))
        nodes := make([]*User, len(_c.builders))
        mutators := make([]Mutator, len(_c.builders))
        for i := range _c.builders </span><span class="cov0" title="0">{
                func(i int, root context.Context) </span><span class="cov0" title="0">{
                        builder := _c.builders[i]
                        builder.defaults()
                        var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) </span><span class="cov0" title="0">{
                                mutation, ok := m.(*UserMutation)
                                if !ok </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("unexpected mutation type %T", m)
                                }</span>
                                <span class="cov0" title="0">if err := builder.check(); err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">builder.mutation = mutation
                                var err error
                                nodes[i], specs[i] = builder.createSpec()
                                if i &lt; len(mutators)-1 </span><span class="cov0" title="0">{
                                        _, err = mutators[i+1].Mutate(root, _c.builders[i+1].mutation)
                                }</span> else<span class="cov0" title="0"> {
                                        spec := &amp;sqlgraph.BatchCreateSpec{Nodes: specs}
                                        // Invoke the actual operation on the latest mutation in the chain.
                                        if err = sqlgraph.BatchCreate(ctx, _c.driver, spec); err != nil </span><span class="cov0" title="0">{
                                                if sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                                                        err = &amp;ConstraintError{msg: err.Error(), wrap: err}
                                                }</span>
                                        }
                                }
                                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">mutation.id = &amp;nodes[i].ID
                                if specs[i].ID.Value != nil &amp;&amp; nodes[i].ID == 0 </span><span class="cov0" title="0">{
                                        id := specs[i].ID.Value.(int64)
                                        nodes[i].ID = int(id)
                                }</span>
                                <span class="cov0" title="0">mutation.done = true
                                return nodes[i], nil</span>
                        })
                        <span class="cov0" title="0">for i := len(builder.hooks) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                                mut = builder.hooks[i](mut)
                        }</span>
                        <span class="cov0" title="0">mutators[i] = mut</span>
                }(i, ctx)
        }
        <span class="cov0" title="0">if len(mutators) &gt; 0 </span><span class="cov0" title="0">{
                if _, err := mutators[0].Mutate(ctx, _c.builders[0].mutation); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return nodes, nil</span>
}

// SaveX is like Save, but panics if an error occurs.
func (_c *UserCreateBulk) SaveX(ctx context.Context) []*User <span class="cov0" title="0">{
        v, err := _c.Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return v</span>
}

// Exec executes the query.
func (_c *UserCreateBulk) Exec(ctx context.Context) error <span class="cov0" title="0">{
        _, err := _c.Save(ctx)
        return err
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (_c *UserCreateBulk) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := _c.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}
</pre>
		
		<pre class="file" id="file34" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "context"

        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
        "entgo.io/ent/schema/field"
        "github.com/ivankorhner/polling-app/internal/ent/predicate"
        "github.com/ivankorhner/polling-app/internal/ent/user"
)

// UserDelete is the builder for deleting a User entity.
type UserDelete struct {
        config
        hooks    []Hook
        mutation *UserMutation
}

// Where appends a list predicates to the UserDelete builder.
func (_d *UserDelete) Where(ps ...predicate.User) *UserDelete <span class="cov0" title="0">{
        _d.mutation.Where(ps...)
        return _d
}</span>

// Exec executes the deletion query and returns how many vertices were deleted.
func (_d *UserDelete) Exec(ctx context.Context) (int, error) <span class="cov0" title="0">{
        return withHooks(ctx, _d.sqlExec, _d.mutation, _d.hooks)
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (_d *UserDelete) ExecX(ctx context.Context) int <span class="cov0" title="0">{
        n, err := _d.Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return n</span>
}

func (_d *UserDelete) sqlExec(ctx context.Context) (int, error) <span class="cov0" title="0">{
        _spec := sqlgraph.NewDeleteSpec(user.Table, sqlgraph.NewFieldSpec(user.FieldID, field.TypeInt))
        if ps := _d.mutation.predicates; len(ps) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Predicate = func(selector *sql.Selector) </span><span class="cov0" title="0">{
                        for i := range ps </span><span class="cov0" title="0">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov0" title="0">affected, err := sqlgraph.DeleteNodes(ctx, _d.driver, _spec)
        if err != nil &amp;&amp; sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                err = &amp;ConstraintError{msg: err.Error(), wrap: err}
        }</span>
        <span class="cov0" title="0">_d.mutation.done = true
        return affected, err</span>
}

// UserDeleteOne is the builder for deleting a single User entity.
type UserDeleteOne struct {
        _d *UserDelete
}

// Where appends a list predicates to the UserDelete builder.
func (_d *UserDeleteOne) Where(ps ...predicate.User) *UserDeleteOne <span class="cov0" title="0">{
        _d._d.mutation.Where(ps...)
        return _d
}</span>

// Exec executes the deletion query.
func (_d *UserDeleteOne) Exec(ctx context.Context) error <span class="cov0" title="0">{
        n, err := _d._d.Exec(ctx)
        switch </span>{
        case err != nil:<span class="cov0" title="0">
                return err</span>
        case n == 0:<span class="cov0" title="0">
                return &amp;NotFoundError{user.Label}</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

// ExecX is like Exec, but panics if an error occurs.
func (_d *UserDeleteOne) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := _d.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}
</pre>
		
		<pre class="file" id="file35" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "context"
        "database/sql/driver"
        "fmt"
        "math"

        "entgo.io/ent"
        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
        "entgo.io/ent/schema/field"
        "github.com/ivankorhner/polling-app/internal/ent/poll"
        "github.com/ivankorhner/polling-app/internal/ent/predicate"
        "github.com/ivankorhner/polling-app/internal/ent/user"
        "github.com/ivankorhner/polling-app/internal/ent/vote"
)

// UserQuery is the builder for querying User entities.
type UserQuery struct {
        config
        ctx        *QueryContext
        order      []user.OrderOption
        inters     []Interceptor
        predicates []predicate.User
        withPolls  *PollQuery
        withVotes  *VoteQuery
        // intermediate query (i.e. traversal path).
        sql  *sql.Selector
        path func(context.Context) (*sql.Selector, error)
}

// Where adds a new predicate for the UserQuery builder.
func (_q *UserQuery) Where(ps ...predicate.User) *UserQuery <span class="cov0" title="0">{
        _q.predicates = append(_q.predicates, ps...)
        return _q
}</span>

// Limit the number of records to be returned by this query.
func (_q *UserQuery) Limit(limit int) *UserQuery <span class="cov0" title="0">{
        _q.ctx.Limit = &amp;limit
        return _q
}</span>

// Offset to start from.
func (_q *UserQuery) Offset(offset int) *UserQuery <span class="cov0" title="0">{
        _q.ctx.Offset = &amp;offset
        return _q
}</span>

// Unique configures the query builder to filter duplicate records on query.
// By default, unique is set to true, and can be disabled using this method.
func (_q *UserQuery) Unique(unique bool) *UserQuery <span class="cov0" title="0">{
        _q.ctx.Unique = &amp;unique
        return _q
}</span>

// Order specifies how the records should be ordered.
func (_q *UserQuery) Order(o ...user.OrderOption) *UserQuery <span class="cov0" title="0">{
        _q.order = append(_q.order, o...)
        return _q
}</span>

// QueryPolls chains the current query on the "polls" edge.
func (_q *UserQuery) QueryPolls() *PollQuery <span class="cov0" title="0">{
        query := (&amp;PollClient{config: _q.config}).Query()
        query.path = func(ctx context.Context) (fromU *sql.Selector, err error) </span><span class="cov0" title="0">{
                if err := _q.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">selector := _q.sqlQuery(ctx)
                if err := selector.Err(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">step := sqlgraph.NewStep(
                        sqlgraph.From(user.Table, user.FieldID, selector),
                        sqlgraph.To(poll.Table, poll.FieldID),
                        sqlgraph.Edge(sqlgraph.O2M, false, user.PollsTable, user.PollsColumn),
                )
                fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
                return fromU, nil</span>
        }
        <span class="cov0" title="0">return query</span>
}

// QueryVotes chains the current query on the "votes" edge.
func (_q *UserQuery) QueryVotes() *VoteQuery <span class="cov0" title="0">{
        query := (&amp;VoteClient{config: _q.config}).Query()
        query.path = func(ctx context.Context) (fromU *sql.Selector, err error) </span><span class="cov0" title="0">{
                if err := _q.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">selector := _q.sqlQuery(ctx)
                if err := selector.Err(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">step := sqlgraph.NewStep(
                        sqlgraph.From(user.Table, user.FieldID, selector),
                        sqlgraph.To(vote.Table, vote.FieldID),
                        sqlgraph.Edge(sqlgraph.O2M, false, user.VotesTable, user.VotesColumn),
                )
                fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
                return fromU, nil</span>
        }
        <span class="cov0" title="0">return query</span>
}

// First returns the first User entity from the query.
// Returns a *NotFoundError when no User was found.
func (_q *UserQuery) First(ctx context.Context) (*User, error) <span class="cov0" title="0">{
        nodes, err := _q.Limit(1).All(setContextOp(ctx, _q.ctx, ent.OpQueryFirst))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(nodes) == 0 </span><span class="cov0" title="0">{
                return nil, &amp;NotFoundError{user.Label}
        }</span>
        <span class="cov0" title="0">return nodes[0], nil</span>
}

// FirstX is like First, but panics if an error occurs.
func (_q *UserQuery) FirstX(ctx context.Context) *User <span class="cov0" title="0">{
        node, err := _q.First(ctx)
        if err != nil &amp;&amp; !IsNotFound(err) </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return node</span>
}

// FirstID returns the first User ID from the query.
// Returns a *NotFoundError when no User ID was found.
func (_q *UserQuery) FirstID(ctx context.Context) (id int, err error) <span class="cov0" title="0">{
        var ids []int
        if ids, err = _q.Limit(1).IDs(setContextOp(ctx, _q.ctx, ent.OpQueryFirstID)); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if len(ids) == 0 </span><span class="cov0" title="0">{
                err = &amp;NotFoundError{user.Label}
                return
        }</span>
        <span class="cov0" title="0">return ids[0], nil</span>
}

// FirstIDX is like FirstID, but panics if an error occurs.
func (_q *UserQuery) FirstIDX(ctx context.Context) int <span class="cov0" title="0">{
        id, err := _q.FirstID(ctx)
        if err != nil &amp;&amp; !IsNotFound(err) </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return id</span>
}

// Only returns a single User entity found by the query, ensuring it only returns one.
// Returns a *NotSingularError when more than one User entity is found.
// Returns a *NotFoundError when no User entities are found.
func (_q *UserQuery) Only(ctx context.Context) (*User, error) <span class="cov0" title="0">{
        nodes, err := _q.Limit(2).All(setContextOp(ctx, _q.ctx, ent.OpQueryOnly))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">switch len(nodes) </span>{
        case 1:<span class="cov0" title="0">
                return nodes[0], nil</span>
        case 0:<span class="cov0" title="0">
                return nil, &amp;NotFoundError{user.Label}</span>
        default:<span class="cov0" title="0">
                return nil, &amp;NotSingularError{user.Label}</span>
        }
}

// OnlyX is like Only, but panics if an error occurs.
func (_q *UserQuery) OnlyX(ctx context.Context) *User <span class="cov0" title="0">{
        node, err := _q.Only(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return node</span>
}

// OnlyID is like Only, but returns the only User ID in the query.
// Returns a *NotSingularError when more than one User ID is found.
// Returns a *NotFoundError when no entities are found.
func (_q *UserQuery) OnlyID(ctx context.Context) (id int, err error) <span class="cov0" title="0">{
        var ids []int
        if ids, err = _q.Limit(2).IDs(setContextOp(ctx, _q.ctx, ent.OpQueryOnlyID)); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">switch len(ids) </span>{
        case 1:<span class="cov0" title="0">
                id = ids[0]</span>
        case 0:<span class="cov0" title="0">
                err = &amp;NotFoundError{user.Label}</span>
        default:<span class="cov0" title="0">
                err = &amp;NotSingularError{user.Label}</span>
        }
        <span class="cov0" title="0">return</span>
}

// OnlyIDX is like OnlyID, but panics if an error occurs.
func (_q *UserQuery) OnlyIDX(ctx context.Context) int <span class="cov0" title="0">{
        id, err := _q.OnlyID(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return id</span>
}

// All executes the query and returns a list of Users.
func (_q *UserQuery) All(ctx context.Context) ([]*User, error) <span class="cov0" title="0">{
        ctx = setContextOp(ctx, _q.ctx, ent.OpQueryAll)
        if err := _q.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">qr := querierAll[[]*User, *UserQuery]()
        return withInterceptors[[]*User](ctx, _q, qr, _q.inters)</span>
}

// AllX is like All, but panics if an error occurs.
func (_q *UserQuery) AllX(ctx context.Context) []*User <span class="cov0" title="0">{
        nodes, err := _q.All(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return nodes</span>
}

// IDs executes the query and returns a list of User IDs.
func (_q *UserQuery) IDs(ctx context.Context) (ids []int, err error) <span class="cov0" title="0">{
        if _q.ctx.Unique == nil &amp;&amp; _q.path != nil </span><span class="cov0" title="0">{
                _q.Unique(true)
        }</span>
        <span class="cov0" title="0">ctx = setContextOp(ctx, _q.ctx, ent.OpQueryIDs)
        if err = _q.Select(user.FieldID).Scan(ctx, &amp;ids); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ids, nil</span>
}

// IDsX is like IDs, but panics if an error occurs.
func (_q *UserQuery) IDsX(ctx context.Context) []int <span class="cov0" title="0">{
        ids, err := _q.IDs(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return ids</span>
}

// Count returns the count of the given query.
func (_q *UserQuery) Count(ctx context.Context) (int, error) <span class="cov0" title="0">{
        ctx = setContextOp(ctx, _q.ctx, ent.OpQueryCount)
        if err := _q.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return withInterceptors[int](ctx, _q, querierCount[*UserQuery](), _q.inters)</span>
}

// CountX is like Count, but panics if an error occurs.
func (_q *UserQuery) CountX(ctx context.Context) int <span class="cov0" title="0">{
        count, err := _q.Count(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return count</span>
}

// Exist returns true if the query has elements in the graph.
func (_q *UserQuery) Exist(ctx context.Context) (bool, error) <span class="cov0" title="0">{
        ctx = setContextOp(ctx, _q.ctx, ent.OpQueryExist)
        switch _, err := _q.FirstID(ctx); </span>{
        case IsNotFound(err):<span class="cov0" title="0">
                return false, nil</span>
        case err != nil:<span class="cov0" title="0">
                return false, fmt.Errorf("ent: check existence: %w", err)</span>
        default:<span class="cov0" title="0">
                return true, nil</span>
        }
}

// ExistX is like Exist, but panics if an error occurs.
func (_q *UserQuery) ExistX(ctx context.Context) bool <span class="cov0" title="0">{
        exist, err := _q.Exist(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return exist</span>
}

// Clone returns a duplicate of the UserQuery builder, including all associated steps. It can be
// used to prepare common query builders and use them differently after the clone is made.
func (_q *UserQuery) Clone() *UserQuery <span class="cov0" title="0">{
        if _q == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;UserQuery{
                config:     _q.config,
                ctx:        _q.ctx.Clone(),
                order:      append([]user.OrderOption{}, _q.order...),
                inters:     append([]Interceptor{}, _q.inters...),
                predicates: append([]predicate.User{}, _q.predicates...),
                withPolls:  _q.withPolls.Clone(),
                withVotes:  _q.withVotes.Clone(),
                // clone intermediate query.
                sql:  _q.sql.Clone(),
                path: _q.path,
        }</span>
}

// WithPolls tells the query-builder to eager-load the nodes that are connected to
// the "polls" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *UserQuery) WithPolls(opts ...func(*PollQuery)) *UserQuery <span class="cov0" title="0">{
        query := (&amp;PollClient{config: _q.config}).Query()
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(query)
        }</span>
        <span class="cov0" title="0">_q.withPolls = query
        return _q</span>
}

// WithVotes tells the query-builder to eager-load the nodes that are connected to
// the "votes" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *UserQuery) WithVotes(opts ...func(*VoteQuery)) *UserQuery <span class="cov0" title="0">{
        query := (&amp;VoteClient{config: _q.config}).Query()
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(query)
        }</span>
        <span class="cov0" title="0">_q.withVotes = query
        return _q</span>
}

// GroupBy is used to group vertices by one or more fields/columns.
// It is often used with aggregate functions, like: count, max, mean, min, sum.
//
// Example:
//
//        var v []struct {
//                Username string `json:"username,omitempty"`
//                Count int `json:"count,omitempty"`
//        }
//
//        client.User.Query().
//                GroupBy(user.FieldUsername).
//                Aggregate(ent.Count()).
//                Scan(ctx, &amp;v)
func (_q *UserQuery) GroupBy(field string, fields ...string) *UserGroupBy <span class="cov0" title="0">{
        _q.ctx.Fields = append([]string{field}, fields...)
        grbuild := &amp;UserGroupBy{build: _q}
        grbuild.flds = &amp;_q.ctx.Fields
        grbuild.label = user.Label
        grbuild.scan = grbuild.Scan
        return grbuild
}</span>

// Select allows the selection one or more fields/columns for the given query,
// instead of selecting all fields in the entity.
//
// Example:
//
//        var v []struct {
//                Username string `json:"username,omitempty"`
//        }
//
//        client.User.Query().
//                Select(user.FieldUsername).
//                Scan(ctx, &amp;v)
func (_q *UserQuery) Select(fields ...string) *UserSelect <span class="cov0" title="0">{
        _q.ctx.Fields = append(_q.ctx.Fields, fields...)
        sbuild := &amp;UserSelect{UserQuery: _q}
        sbuild.label = user.Label
        sbuild.flds, sbuild.scan = &amp;_q.ctx.Fields, sbuild.Scan
        return sbuild
}</span>

// Aggregate returns a UserSelect configured with the given aggregations.
func (_q *UserQuery) Aggregate(fns ...AggregateFunc) *UserSelect <span class="cov0" title="0">{
        return _q.Select().Aggregate(fns...)
}</span>

func (_q *UserQuery) prepareQuery(ctx context.Context) error <span class="cov0" title="0">{
        for _, inter := range _q.inters </span><span class="cov0" title="0">{
                if inter == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("ent: uninitialized interceptor (forgotten import ent/runtime?)")
                }</span>
                <span class="cov0" title="0">if trv, ok := inter.(Traverser); ok </span><span class="cov0" title="0">{
                        if err := trv.Traverse(ctx, _q); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov0" title="0">for _, f := range _q.ctx.Fields </span><span class="cov0" title="0">{
                if !user.ValidColumn(f) </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
                }</span>
        }
        <span class="cov0" title="0">if _q.path != nil </span><span class="cov0" title="0">{
                prev, err := _q.path(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">_q.sql = prev</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (_q *UserQuery) sqlAll(ctx context.Context, hooks ...queryHook) ([]*User, error) <span class="cov0" title="0">{
        var (
                nodes       = []*User{}
                _spec       = _q.querySpec()
                loadedTypes = [2]bool{
                        _q.withPolls != nil,
                        _q.withVotes != nil,
                }
        )
        _spec.ScanValues = func(columns []string) ([]any, error) </span><span class="cov0" title="0">{
                return (*User).scanValues(nil, columns)
        }</span>
        <span class="cov0" title="0">_spec.Assign = func(columns []string, values []any) error </span><span class="cov0" title="0">{
                node := &amp;User{config: _q.config}
                nodes = append(nodes, node)
                node.Edges.loadedTypes = loadedTypes
                return node.assignValues(columns, values)
        }</span>
        <span class="cov0" title="0">for i := range hooks </span><span class="cov0" title="0">{
                hooks[i](ctx, _spec)
        }</span>
        <span class="cov0" title="0">if err := sqlgraph.QueryNodes(ctx, _q.driver, _spec); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(nodes) == 0 </span><span class="cov0" title="0">{
                return nodes, nil
        }</span>
        <span class="cov0" title="0">if query := _q.withPolls; query != nil </span><span class="cov0" title="0">{
                if err := _q.loadPolls(ctx, query, nodes,
                        func(n *User) </span><span class="cov0" title="0">{ n.Edges.Polls = []*Poll{} }</span>,
                        func(n *User, e *Poll) <span class="cov0" title="0">{ n.Edges.Polls = append(n.Edges.Polls, e) }</span>); err != nil <span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">if query := _q.withVotes; query != nil </span><span class="cov0" title="0">{
                if err := _q.loadVotes(ctx, query, nodes,
                        func(n *User) </span><span class="cov0" title="0">{ n.Edges.Votes = []*Vote{} }</span>,
                        func(n *User, e *Vote) <span class="cov0" title="0">{ n.Edges.Votes = append(n.Edges.Votes, e) }</span>); err != nil <span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return nodes, nil</span>
}

func (_q *UserQuery) loadPolls(ctx context.Context, query *PollQuery, nodes []*User, init func(*User), assign func(*User, *Poll)) error <span class="cov0" title="0">{
        fks := make([]driver.Value, 0, len(nodes))
        nodeids := make(map[int]*User)
        for i := range nodes </span><span class="cov0" title="0">{
                fks = append(fks, nodes[i].ID)
                nodeids[nodes[i].ID] = nodes[i]
                if init != nil </span><span class="cov0" title="0">{
                        init(nodes[i])
                }</span>
        }
        <span class="cov0" title="0">if len(query.ctx.Fields) &gt; 0 </span><span class="cov0" title="0">{
                query.ctx.AppendFieldOnce(poll.FieldOwnerID)
        }</span>
        <span class="cov0" title="0">query.Where(predicate.Poll(func(s *sql.Selector) </span><span class="cov0" title="0">{
                s.Where(sql.InValues(s.C(user.PollsColumn), fks...))
        }</span>))
        <span class="cov0" title="0">neighbors, err := query.All(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, n := range neighbors </span><span class="cov0" title="0">{
                fk := n.OwnerID
                node, ok := nodeids[fk]
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf(`unexpected referenced foreign-key "owner_id" returned %v for node %v`, fk, n.ID)
                }</span>
                <span class="cov0" title="0">assign(node, n)</span>
        }
        <span class="cov0" title="0">return nil</span>
}
func (_q *UserQuery) loadVotes(ctx context.Context, query *VoteQuery, nodes []*User, init func(*User), assign func(*User, *Vote)) error <span class="cov0" title="0">{
        fks := make([]driver.Value, 0, len(nodes))
        nodeids := make(map[int]*User)
        for i := range nodes </span><span class="cov0" title="0">{
                fks = append(fks, nodes[i].ID)
                nodeids[nodes[i].ID] = nodes[i]
                if init != nil </span><span class="cov0" title="0">{
                        init(nodes[i])
                }</span>
        }
        <span class="cov0" title="0">if len(query.ctx.Fields) &gt; 0 </span><span class="cov0" title="0">{
                query.ctx.AppendFieldOnce(vote.FieldUserID)
        }</span>
        <span class="cov0" title="0">query.Where(predicate.Vote(func(s *sql.Selector) </span><span class="cov0" title="0">{
                s.Where(sql.InValues(s.C(user.VotesColumn), fks...))
        }</span>))
        <span class="cov0" title="0">neighbors, err := query.All(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, n := range neighbors </span><span class="cov0" title="0">{
                fk := n.UserID
                node, ok := nodeids[fk]
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf(`unexpected referenced foreign-key "user_id" returned %v for node %v`, fk, n.ID)
                }</span>
                <span class="cov0" title="0">assign(node, n)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (_q *UserQuery) sqlCount(ctx context.Context) (int, error) <span class="cov0" title="0">{
        _spec := _q.querySpec()
        _spec.Node.Columns = _q.ctx.Fields
        if len(_q.ctx.Fields) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Unique = _q.ctx.Unique != nil &amp;&amp; *_q.ctx.Unique
        }</span>
        <span class="cov0" title="0">return sqlgraph.CountNodes(ctx, _q.driver, _spec)</span>
}

func (_q *UserQuery) querySpec() *sqlgraph.QuerySpec <span class="cov0" title="0">{
        _spec := sqlgraph.NewQuerySpec(user.Table, user.Columns, sqlgraph.NewFieldSpec(user.FieldID, field.TypeInt))
        _spec.From = _q.sql
        if unique := _q.ctx.Unique; unique != nil </span><span class="cov0" title="0">{
                _spec.Unique = *unique
        }</span> else<span class="cov0" title="0"> if _q.path != nil </span><span class="cov0" title="0">{
                _spec.Unique = true
        }</span>
        <span class="cov0" title="0">if fields := _q.ctx.Fields; len(fields) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Node.Columns = make([]string, 0, len(fields))
                _spec.Node.Columns = append(_spec.Node.Columns, user.FieldID)
                for i := range fields </span><span class="cov0" title="0">{
                        if fields[i] != user.FieldID </span><span class="cov0" title="0">{
                                _spec.Node.Columns = append(_spec.Node.Columns, fields[i])
                        }</span>
                }
        }
        <span class="cov0" title="0">if ps := _q.predicates; len(ps) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Predicate = func(selector *sql.Selector) </span><span class="cov0" title="0">{
                        for i := range ps </span><span class="cov0" title="0">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov0" title="0">if limit := _q.ctx.Limit; limit != nil </span><span class="cov0" title="0">{
                _spec.Limit = *limit
        }</span>
        <span class="cov0" title="0">if offset := _q.ctx.Offset; offset != nil </span><span class="cov0" title="0">{
                _spec.Offset = *offset
        }</span>
        <span class="cov0" title="0">if ps := _q.order; len(ps) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Order = func(selector *sql.Selector) </span><span class="cov0" title="0">{
                        for i := range ps </span><span class="cov0" title="0">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov0" title="0">return _spec</span>
}

func (_q *UserQuery) sqlQuery(ctx context.Context) *sql.Selector <span class="cov0" title="0">{
        builder := sql.Dialect(_q.driver.Dialect())
        t1 := builder.Table(user.Table)
        columns := _q.ctx.Fields
        if len(columns) == 0 </span><span class="cov0" title="0">{
                columns = user.Columns
        }</span>
        <span class="cov0" title="0">selector := builder.Select(t1.Columns(columns...)...).From(t1)
        if _q.sql != nil </span><span class="cov0" title="0">{
                selector = _q.sql
                selector.Select(selector.Columns(columns...)...)
        }</span>
        <span class="cov0" title="0">if _q.ctx.Unique != nil &amp;&amp; *_q.ctx.Unique </span><span class="cov0" title="0">{
                selector.Distinct()
        }</span>
        <span class="cov0" title="0">for _, p := range _q.predicates </span><span class="cov0" title="0">{
                p(selector)
        }</span>
        <span class="cov0" title="0">for _, p := range _q.order </span><span class="cov0" title="0">{
                p(selector)
        }</span>
        <span class="cov0" title="0">if offset := _q.ctx.Offset; offset != nil </span><span class="cov0" title="0">{
                // limit is mandatory for offset clause. We start
                // with default value, and override it below if needed.
                selector.Offset(*offset).Limit(math.MaxInt32)
        }</span>
        <span class="cov0" title="0">if limit := _q.ctx.Limit; limit != nil </span><span class="cov0" title="0">{
                selector.Limit(*limit)
        }</span>
        <span class="cov0" title="0">return selector</span>
}

// UserGroupBy is the group-by builder for User entities.
type UserGroupBy struct {
        selector
        build *UserQuery
}

// Aggregate adds the given aggregation functions to the group-by query.
func (_g *UserGroupBy) Aggregate(fns ...AggregateFunc) *UserGroupBy <span class="cov0" title="0">{
        _g.fns = append(_g.fns, fns...)
        return _g
}</span>

// Scan applies the selector query and scans the result into the given value.
func (_g *UserGroupBy) Scan(ctx context.Context, v any) error <span class="cov0" title="0">{
        ctx = setContextOp(ctx, _g.build.ctx, ent.OpQueryGroupBy)
        if err := _g.build.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return scanWithInterceptors[*UserQuery, *UserGroupBy](ctx, _g.build, _g, _g.build.inters, v)</span>
}

func (_g *UserGroupBy) sqlScan(ctx context.Context, root *UserQuery, v any) error <span class="cov0" title="0">{
        selector := root.sqlQuery(ctx).Select()
        aggregation := make([]string, 0, len(_g.fns))
        for _, fn := range _g.fns </span><span class="cov0" title="0">{
                aggregation = append(aggregation, fn(selector))
        }</span>
        <span class="cov0" title="0">if len(selector.SelectedColumns()) == 0 </span><span class="cov0" title="0">{
                columns := make([]string, 0, len(*_g.flds)+len(_g.fns))
                for _, f := range *_g.flds </span><span class="cov0" title="0">{
                        columns = append(columns, selector.C(f))
                }</span>
                <span class="cov0" title="0">columns = append(columns, aggregation...)
                selector.Select(columns...)</span>
        }
        <span class="cov0" title="0">selector.GroupBy(selector.Columns(*_g.flds...)...)
        if err := selector.Err(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">rows := &amp;sql.Rows{}
        query, args := selector.Query()
        if err := _g.build.driver.Query(ctx, query, args, rows); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        return sql.ScanSlice(rows, v)</span>
}

// UserSelect is the builder for selecting fields of User entities.
type UserSelect struct {
        *UserQuery
        selector
}

// Aggregate adds the given aggregation functions to the selector query.
func (_s *UserSelect) Aggregate(fns ...AggregateFunc) *UserSelect <span class="cov0" title="0">{
        _s.fns = append(_s.fns, fns...)
        return _s
}</span>

// Scan applies the selector query and scans the result into the given value.
func (_s *UserSelect) Scan(ctx context.Context, v any) error <span class="cov0" title="0">{
        ctx = setContextOp(ctx, _s.ctx, ent.OpQuerySelect)
        if err := _s.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return scanWithInterceptors[*UserQuery, *UserSelect](ctx, _s.UserQuery, _s, _s.inters, v)</span>
}

func (_s *UserSelect) sqlScan(ctx context.Context, root *UserQuery, v any) error <span class="cov0" title="0">{
        selector := root.sqlQuery(ctx)
        aggregation := make([]string, 0, len(_s.fns))
        for _, fn := range _s.fns </span><span class="cov0" title="0">{
                aggregation = append(aggregation, fn(selector))
        }</span>
        <span class="cov0" title="0">switch n := len(*_s.selector.flds); </span>{
        case n == 0 &amp;&amp; len(aggregation) &gt; 0:<span class="cov0" title="0">
                selector.Select(aggregation...)</span>
        case n != 0 &amp;&amp; len(aggregation) &gt; 0:<span class="cov0" title="0">
                selector.AppendSelect(aggregation...)</span>
        }
        <span class="cov0" title="0">rows := &amp;sql.Rows{}
        query, args := selector.Query()
        if err := _s.driver.Query(ctx, query, args, rows); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        return sql.ScanSlice(rows, v)</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "context"
        "errors"
        "fmt"

        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
        "entgo.io/ent/schema/field"
        "github.com/ivankorhner/polling-app/internal/ent/poll"
        "github.com/ivankorhner/polling-app/internal/ent/predicate"
        "github.com/ivankorhner/polling-app/internal/ent/user"
        "github.com/ivankorhner/polling-app/internal/ent/vote"
)

// UserUpdate is the builder for updating User entities.
type UserUpdate struct {
        config
        hooks    []Hook
        mutation *UserMutation
}

// Where appends a list predicates to the UserUpdate builder.
func (_u *UserUpdate) Where(ps ...predicate.User) *UserUpdate <span class="cov0" title="0">{
        _u.mutation.Where(ps...)
        return _u
}</span>

// SetUsername sets the "username" field.
func (_u *UserUpdate) SetUsername(v string) *UserUpdate <span class="cov0" title="0">{
        _u.mutation.SetUsername(v)
        return _u
}</span>

// SetNillableUsername sets the "username" field if the given value is not nil.
func (_u *UserUpdate) SetNillableUsername(v *string) *UserUpdate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetUsername(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// SetEmail sets the "email" field.
func (_u *UserUpdate) SetEmail(v string) *UserUpdate <span class="cov0" title="0">{
        _u.mutation.SetEmail(v)
        return _u
}</span>

// SetNillableEmail sets the "email" field if the given value is not nil.
func (_u *UserUpdate) SetNillableEmail(v *string) *UserUpdate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetEmail(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// AddPollIDs adds the "polls" edge to the Poll entity by IDs.
func (_u *UserUpdate) AddPollIDs(ids ...int) *UserUpdate <span class="cov0" title="0">{
        _u.mutation.AddPollIDs(ids...)
        return _u
}</span>

// AddPolls adds the "polls" edges to the Poll entity.
func (_u *UserUpdate) AddPolls(v ...*Poll) *UserUpdate <span class="cov0" title="0">{
        ids := make([]int, len(v))
        for i := range v </span><span class="cov0" title="0">{
                ids[i] = v[i].ID
        }</span>
        <span class="cov0" title="0">return _u.AddPollIDs(ids...)</span>
}

// AddVoteIDs adds the "votes" edge to the Vote entity by IDs.
func (_u *UserUpdate) AddVoteIDs(ids ...int) *UserUpdate <span class="cov0" title="0">{
        _u.mutation.AddVoteIDs(ids...)
        return _u
}</span>

// AddVotes adds the "votes" edges to the Vote entity.
func (_u *UserUpdate) AddVotes(v ...*Vote) *UserUpdate <span class="cov0" title="0">{
        ids := make([]int, len(v))
        for i := range v </span><span class="cov0" title="0">{
                ids[i] = v[i].ID
        }</span>
        <span class="cov0" title="0">return _u.AddVoteIDs(ids...)</span>
}

// Mutation returns the UserMutation object of the builder.
func (_u *UserUpdate) Mutation() *UserMutation <span class="cov0" title="0">{
        return _u.mutation
}</span>

// ClearPolls clears all "polls" edges to the Poll entity.
func (_u *UserUpdate) ClearPolls() *UserUpdate <span class="cov0" title="0">{
        _u.mutation.ClearPolls()
        return _u
}</span>

// RemovePollIDs removes the "polls" edge to Poll entities by IDs.
func (_u *UserUpdate) RemovePollIDs(ids ...int) *UserUpdate <span class="cov0" title="0">{
        _u.mutation.RemovePollIDs(ids...)
        return _u
}</span>

// RemovePolls removes "polls" edges to Poll entities.
func (_u *UserUpdate) RemovePolls(v ...*Poll) *UserUpdate <span class="cov0" title="0">{
        ids := make([]int, len(v))
        for i := range v </span><span class="cov0" title="0">{
                ids[i] = v[i].ID
        }</span>
        <span class="cov0" title="0">return _u.RemovePollIDs(ids...)</span>
}

// ClearVotes clears all "votes" edges to the Vote entity.
func (_u *UserUpdate) ClearVotes() *UserUpdate <span class="cov0" title="0">{
        _u.mutation.ClearVotes()
        return _u
}</span>

// RemoveVoteIDs removes the "votes" edge to Vote entities by IDs.
func (_u *UserUpdate) RemoveVoteIDs(ids ...int) *UserUpdate <span class="cov0" title="0">{
        _u.mutation.RemoveVoteIDs(ids...)
        return _u
}</span>

// RemoveVotes removes "votes" edges to Vote entities.
func (_u *UserUpdate) RemoveVotes(v ...*Vote) *UserUpdate <span class="cov0" title="0">{
        ids := make([]int, len(v))
        for i := range v </span><span class="cov0" title="0">{
                ids[i] = v[i].ID
        }</span>
        <span class="cov0" title="0">return _u.RemoveVoteIDs(ids...)</span>
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (_u *UserUpdate) Save(ctx context.Context) (int, error) <span class="cov0" title="0">{
        return withHooks(ctx, _u.sqlSave, _u.mutation, _u.hooks)
}</span>

// SaveX is like Save, but panics if an error occurs.
func (_u *UserUpdate) SaveX(ctx context.Context) int <span class="cov0" title="0">{
        affected, err := _u.Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return affected</span>
}

// Exec executes the query.
func (_u *UserUpdate) Exec(ctx context.Context) error <span class="cov0" title="0">{
        _, err := _u.Save(ctx)
        return err
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (_u *UserUpdate) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := _u.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// check runs all checks and user-defined validators on the builder.
func (_u *UserUpdate) check() error <span class="cov0" title="0">{
        if v, ok := _u.mutation.Username(); ok </span><span class="cov0" title="0">{
                if err := user.UsernameValidator(v); err != nil </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: "username", err: fmt.Errorf(`ent: validator failed for field "User.username": %w`, err)}
                }</span>
        }
        <span class="cov0" title="0">if v, ok := _u.mutation.Email(); ok </span><span class="cov0" title="0">{
                if err := user.EmailValidator(v); err != nil </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: "email", err: fmt.Errorf(`ent: validator failed for field "User.email": %w`, err)}
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (_u *UserUpdate) sqlSave(ctx context.Context) (_node int, err error) <span class="cov0" title="0">{
        if err := _u.check(); err != nil </span><span class="cov0" title="0">{
                return _node, err
        }</span>
        <span class="cov0" title="0">_spec := sqlgraph.NewUpdateSpec(user.Table, user.Columns, sqlgraph.NewFieldSpec(user.FieldID, field.TypeInt))
        if ps := _u.mutation.predicates; len(ps) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Predicate = func(selector *sql.Selector) </span><span class="cov0" title="0">{
                        for i := range ps </span><span class="cov0" title="0">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov0" title="0">if value, ok := _u.mutation.Username(); ok </span><span class="cov0" title="0">{
                _spec.SetField(user.FieldUsername, field.TypeString, value)
        }</span>
        <span class="cov0" title="0">if value, ok := _u.mutation.Email(); ok </span><span class="cov0" title="0">{
                _spec.SetField(user.FieldEmail, field.TypeString, value)
        }</span>
        <span class="cov0" title="0">if _u.mutation.PollsCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   user.PollsTable,
                        Columns: []string{user.PollsColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(poll.FieldID, field.TypeInt),
                        },
                }
                _spec.Edges.Clear = append(_spec.Edges.Clear, edge)
        }</span>
        <span class="cov0" title="0">if nodes := _u.mutation.RemovedPollsIDs(); len(nodes) &gt; 0 &amp;&amp; !_u.mutation.PollsCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   user.PollsTable,
                        Columns: []string{user.PollsColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(poll.FieldID, field.TypeInt),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges.Clear = append(_spec.Edges.Clear, edge)</span>
        }
        <span class="cov0" title="0">if nodes := _u.mutation.PollsIDs(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   user.PollsTable,
                        Columns: []string{user.PollsColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(poll.FieldID, field.TypeInt),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges.Add = append(_spec.Edges.Add, edge)</span>
        }
        <span class="cov0" title="0">if _u.mutation.VotesCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   user.VotesTable,
                        Columns: []string{user.VotesColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(vote.FieldID, field.TypeInt),
                        },
                }
                _spec.Edges.Clear = append(_spec.Edges.Clear, edge)
        }</span>
        <span class="cov0" title="0">if nodes := _u.mutation.RemovedVotesIDs(); len(nodes) &gt; 0 &amp;&amp; !_u.mutation.VotesCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   user.VotesTable,
                        Columns: []string{user.VotesColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(vote.FieldID, field.TypeInt),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges.Clear = append(_spec.Edges.Clear, edge)</span>
        }
        <span class="cov0" title="0">if nodes := _u.mutation.VotesIDs(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   user.VotesTable,
                        Columns: []string{user.VotesColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(vote.FieldID, field.TypeInt),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges.Add = append(_spec.Edges.Add, edge)</span>
        }
        <span class="cov0" title="0">if _node, err = sqlgraph.UpdateNodes(ctx, _u.driver, _spec); err != nil </span><span class="cov0" title="0">{
                if _, ok := err.(*sqlgraph.NotFoundError); ok </span><span class="cov0" title="0">{
                        err = &amp;NotFoundError{user.Label}
                }</span> else<span class="cov0" title="0"> if sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                        err = &amp;ConstraintError{msg: err.Error(), wrap: err}
                }</span>
                <span class="cov0" title="0">return 0, err</span>
        }
        <span class="cov0" title="0">_u.mutation.done = true
        return _node, nil</span>
}

// UserUpdateOne is the builder for updating a single User entity.
type UserUpdateOne struct {
        config
        fields   []string
        hooks    []Hook
        mutation *UserMutation
}

// SetUsername sets the "username" field.
func (_u *UserUpdateOne) SetUsername(v string) *UserUpdateOne <span class="cov0" title="0">{
        _u.mutation.SetUsername(v)
        return _u
}</span>

// SetNillableUsername sets the "username" field if the given value is not nil.
func (_u *UserUpdateOne) SetNillableUsername(v *string) *UserUpdateOne <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetUsername(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// SetEmail sets the "email" field.
func (_u *UserUpdateOne) SetEmail(v string) *UserUpdateOne <span class="cov0" title="0">{
        _u.mutation.SetEmail(v)
        return _u
}</span>

// SetNillableEmail sets the "email" field if the given value is not nil.
func (_u *UserUpdateOne) SetNillableEmail(v *string) *UserUpdateOne <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetEmail(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// AddPollIDs adds the "polls" edge to the Poll entity by IDs.
func (_u *UserUpdateOne) AddPollIDs(ids ...int) *UserUpdateOne <span class="cov0" title="0">{
        _u.mutation.AddPollIDs(ids...)
        return _u
}</span>

// AddPolls adds the "polls" edges to the Poll entity.
func (_u *UserUpdateOne) AddPolls(v ...*Poll) *UserUpdateOne <span class="cov0" title="0">{
        ids := make([]int, len(v))
        for i := range v </span><span class="cov0" title="0">{
                ids[i] = v[i].ID
        }</span>
        <span class="cov0" title="0">return _u.AddPollIDs(ids...)</span>
}

// AddVoteIDs adds the "votes" edge to the Vote entity by IDs.
func (_u *UserUpdateOne) AddVoteIDs(ids ...int) *UserUpdateOne <span class="cov0" title="0">{
        _u.mutation.AddVoteIDs(ids...)
        return _u
}</span>

// AddVotes adds the "votes" edges to the Vote entity.
func (_u *UserUpdateOne) AddVotes(v ...*Vote) *UserUpdateOne <span class="cov0" title="0">{
        ids := make([]int, len(v))
        for i := range v </span><span class="cov0" title="0">{
                ids[i] = v[i].ID
        }</span>
        <span class="cov0" title="0">return _u.AddVoteIDs(ids...)</span>
}

// Mutation returns the UserMutation object of the builder.
func (_u *UserUpdateOne) Mutation() *UserMutation <span class="cov0" title="0">{
        return _u.mutation
}</span>

// ClearPolls clears all "polls" edges to the Poll entity.
func (_u *UserUpdateOne) ClearPolls() *UserUpdateOne <span class="cov0" title="0">{
        _u.mutation.ClearPolls()
        return _u
}</span>

// RemovePollIDs removes the "polls" edge to Poll entities by IDs.
func (_u *UserUpdateOne) RemovePollIDs(ids ...int) *UserUpdateOne <span class="cov0" title="0">{
        _u.mutation.RemovePollIDs(ids...)
        return _u
}</span>

// RemovePolls removes "polls" edges to Poll entities.
func (_u *UserUpdateOne) RemovePolls(v ...*Poll) *UserUpdateOne <span class="cov0" title="0">{
        ids := make([]int, len(v))
        for i := range v </span><span class="cov0" title="0">{
                ids[i] = v[i].ID
        }</span>
        <span class="cov0" title="0">return _u.RemovePollIDs(ids...)</span>
}

// ClearVotes clears all "votes" edges to the Vote entity.
func (_u *UserUpdateOne) ClearVotes() *UserUpdateOne <span class="cov0" title="0">{
        _u.mutation.ClearVotes()
        return _u
}</span>

// RemoveVoteIDs removes the "votes" edge to Vote entities by IDs.
func (_u *UserUpdateOne) RemoveVoteIDs(ids ...int) *UserUpdateOne <span class="cov0" title="0">{
        _u.mutation.RemoveVoteIDs(ids...)
        return _u
}</span>

// RemoveVotes removes "votes" edges to Vote entities.
func (_u *UserUpdateOne) RemoveVotes(v ...*Vote) *UserUpdateOne <span class="cov0" title="0">{
        ids := make([]int, len(v))
        for i := range v </span><span class="cov0" title="0">{
                ids[i] = v[i].ID
        }</span>
        <span class="cov0" title="0">return _u.RemoveVoteIDs(ids...)</span>
}

// Where appends a list predicates to the UserUpdate builder.
func (_u *UserUpdateOne) Where(ps ...predicate.User) *UserUpdateOne <span class="cov0" title="0">{
        _u.mutation.Where(ps...)
        return _u
}</span>

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (_u *UserUpdateOne) Select(field string, fields ...string) *UserUpdateOne <span class="cov0" title="0">{
        _u.fields = append([]string{field}, fields...)
        return _u
}</span>

// Save executes the query and returns the updated User entity.
func (_u *UserUpdateOne) Save(ctx context.Context) (*User, error) <span class="cov0" title="0">{
        return withHooks(ctx, _u.sqlSave, _u.mutation, _u.hooks)
}</span>

// SaveX is like Save, but panics if an error occurs.
func (_u *UserUpdateOne) SaveX(ctx context.Context) *User <span class="cov0" title="0">{
        node, err := _u.Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return node</span>
}

// Exec executes the query on the entity.
func (_u *UserUpdateOne) Exec(ctx context.Context) error <span class="cov0" title="0">{
        _, err := _u.Save(ctx)
        return err
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (_u *UserUpdateOne) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := _u.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// check runs all checks and user-defined validators on the builder.
func (_u *UserUpdateOne) check() error <span class="cov0" title="0">{
        if v, ok := _u.mutation.Username(); ok </span><span class="cov0" title="0">{
                if err := user.UsernameValidator(v); err != nil </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: "username", err: fmt.Errorf(`ent: validator failed for field "User.username": %w`, err)}
                }</span>
        }
        <span class="cov0" title="0">if v, ok := _u.mutation.Email(); ok </span><span class="cov0" title="0">{
                if err := user.EmailValidator(v); err != nil </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: "email", err: fmt.Errorf(`ent: validator failed for field "User.email": %w`, err)}
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (_u *UserUpdateOne) sqlSave(ctx context.Context) (_node *User, err error) <span class="cov0" title="0">{
        if err := _u.check(); err != nil </span><span class="cov0" title="0">{
                return _node, err
        }</span>
        <span class="cov0" title="0">_spec := sqlgraph.NewUpdateSpec(user.Table, user.Columns, sqlgraph.NewFieldSpec(user.FieldID, field.TypeInt))
        id, ok := _u.mutation.ID()
        if !ok </span><span class="cov0" title="0">{
                return nil, &amp;ValidationError{Name: "id", err: errors.New(`ent: missing "User.id" for update`)}
        }</span>
        <span class="cov0" title="0">_spec.Node.ID.Value = id
        if fields := _u.fields; len(fields) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Node.Columns = make([]string, 0, len(fields))
                _spec.Node.Columns = append(_spec.Node.Columns, user.FieldID)
                for _, f := range fields </span><span class="cov0" title="0">{
                        if !user.ValidColumn(f) </span><span class="cov0" title="0">{
                                return nil, &amp;ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
                        }</span>
                        <span class="cov0" title="0">if f != user.FieldID </span><span class="cov0" title="0">{
                                _spec.Node.Columns = append(_spec.Node.Columns, f)
                        }</span>
                }
        }
        <span class="cov0" title="0">if ps := _u.mutation.predicates; len(ps) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Predicate = func(selector *sql.Selector) </span><span class="cov0" title="0">{
                        for i := range ps </span><span class="cov0" title="0">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov0" title="0">if value, ok := _u.mutation.Username(); ok </span><span class="cov0" title="0">{
                _spec.SetField(user.FieldUsername, field.TypeString, value)
        }</span>
        <span class="cov0" title="0">if value, ok := _u.mutation.Email(); ok </span><span class="cov0" title="0">{
                _spec.SetField(user.FieldEmail, field.TypeString, value)
        }</span>
        <span class="cov0" title="0">if _u.mutation.PollsCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   user.PollsTable,
                        Columns: []string{user.PollsColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(poll.FieldID, field.TypeInt),
                        },
                }
                _spec.Edges.Clear = append(_spec.Edges.Clear, edge)
        }</span>
        <span class="cov0" title="0">if nodes := _u.mutation.RemovedPollsIDs(); len(nodes) &gt; 0 &amp;&amp; !_u.mutation.PollsCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   user.PollsTable,
                        Columns: []string{user.PollsColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(poll.FieldID, field.TypeInt),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges.Clear = append(_spec.Edges.Clear, edge)</span>
        }
        <span class="cov0" title="0">if nodes := _u.mutation.PollsIDs(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   user.PollsTable,
                        Columns: []string{user.PollsColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(poll.FieldID, field.TypeInt),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges.Add = append(_spec.Edges.Add, edge)</span>
        }
        <span class="cov0" title="0">if _u.mutation.VotesCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   user.VotesTable,
                        Columns: []string{user.VotesColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(vote.FieldID, field.TypeInt),
                        },
                }
                _spec.Edges.Clear = append(_spec.Edges.Clear, edge)
        }</span>
        <span class="cov0" title="0">if nodes := _u.mutation.RemovedVotesIDs(); len(nodes) &gt; 0 &amp;&amp; !_u.mutation.VotesCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   user.VotesTable,
                        Columns: []string{user.VotesColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(vote.FieldID, field.TypeInt),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges.Clear = append(_spec.Edges.Clear, edge)</span>
        }
        <span class="cov0" title="0">if nodes := _u.mutation.VotesIDs(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   user.VotesTable,
                        Columns: []string{user.VotesColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(vote.FieldID, field.TypeInt),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges.Add = append(_spec.Edges.Add, edge)</span>
        }
        <span class="cov0" title="0">_node = &amp;User{config: _u.config}
        _spec.Assign = _node.assignValues
        _spec.ScanValues = _node.scanValues
        if err = sqlgraph.UpdateNode(ctx, _u.driver, _spec); err != nil </span><span class="cov0" title="0">{
                if _, ok := err.(*sqlgraph.NotFoundError); ok </span><span class="cov0" title="0">{
                        err = &amp;NotFoundError{user.Label}
                }</span> else<span class="cov0" title="0"> if sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                        err = &amp;ConstraintError{msg: err.Error(), wrap: err}
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">_u.mutation.done = true
        return _node, nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "fmt"
        "strings"
        "time"

        "entgo.io/ent"
        "entgo.io/ent/dialect/sql"
        "github.com/ivankorhner/polling-app/internal/ent/poll"
        "github.com/ivankorhner/polling-app/internal/ent/polloption"
        "github.com/ivankorhner/polling-app/internal/ent/user"
        "github.com/ivankorhner/polling-app/internal/ent/vote"
)

// Vote is the model entity for the Vote schema.
type Vote struct {
        config `json:"-"`
        // ID of the ent.
        ID int `json:"id,omitempty"`
        // PollID holds the value of the "poll_id" field.
        PollID int `json:"poll_id,omitempty"`
        // OptionID holds the value of the "option_id" field.
        OptionID int `json:"option_id,omitempty"`
        // UserID holds the value of the "user_id" field.
        UserID int `json:"user_id,omitempty"`
        // CreatedAt holds the value of the "created_at" field.
        CreatedAt time.Time `json:"created_at,omitempty"`
        // Edges holds the relations/edges for other nodes in the graph.
        // The values are being populated by the VoteQuery when eager-loading is set.
        Edges        VoteEdges `json:"edges"`
        selectValues sql.SelectValues
}

// VoteEdges holds the relations/edges for other nodes in the graph.
type VoteEdges struct {
        // Poll holds the value of the poll edge.
        Poll *Poll `json:"poll,omitempty"`
        // Option holds the value of the option edge.
        Option *PollOption `json:"option,omitempty"`
        // User holds the value of the user edge.
        User *User `json:"user,omitempty"`
        // loadedTypes holds the information for reporting if a
        // type was loaded (or requested) in eager-loading or not.
        loadedTypes [3]bool
}

// PollOrErr returns the Poll value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e VoteEdges) PollOrErr() (*Poll, error) <span class="cov0" title="0">{
        if e.Poll != nil </span><span class="cov0" title="0">{
                return e.Poll, nil
        }</span> else<span class="cov0" title="0"> if e.loadedTypes[0] </span><span class="cov0" title="0">{
                return nil, &amp;NotFoundError{label: poll.Label}
        }</span>
        <span class="cov0" title="0">return nil, &amp;NotLoadedError{edge: "poll"}</span>
}

// OptionOrErr returns the Option value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e VoteEdges) OptionOrErr() (*PollOption, error) <span class="cov0" title="0">{
        if e.Option != nil </span><span class="cov0" title="0">{
                return e.Option, nil
        }</span> else<span class="cov0" title="0"> if e.loadedTypes[1] </span><span class="cov0" title="0">{
                return nil, &amp;NotFoundError{label: polloption.Label}
        }</span>
        <span class="cov0" title="0">return nil, &amp;NotLoadedError{edge: "option"}</span>
}

// UserOrErr returns the User value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e VoteEdges) UserOrErr() (*User, error) <span class="cov0" title="0">{
        if e.User != nil </span><span class="cov0" title="0">{
                return e.User, nil
        }</span> else<span class="cov0" title="0"> if e.loadedTypes[2] </span><span class="cov0" title="0">{
                return nil, &amp;NotFoundError{label: user.Label}
        }</span>
        <span class="cov0" title="0">return nil, &amp;NotLoadedError{edge: "user"}</span>
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Vote) scanValues(columns []string) ([]any, error) <span class="cov0" title="0">{
        values := make([]any, len(columns))
        for i := range columns </span><span class="cov0" title="0">{
                switch columns[i] </span>{
                case vote.FieldID, vote.FieldPollID, vote.FieldOptionID, vote.FieldUserID:<span class="cov0" title="0">
                        values[i] = new(sql.NullInt64)</span>
                case vote.FieldCreatedAt:<span class="cov0" title="0">
                        values[i] = new(sql.NullTime)</span>
                default:<span class="cov0" title="0">
                        values[i] = new(sql.UnknownType)</span>
                }
        }
        <span class="cov0" title="0">return values, nil</span>
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Vote fields.
func (_m *Vote) assignValues(columns []string, values []any) error <span class="cov0" title="0">{
        if m, n := len(values), len(columns); m &lt; n </span><span class="cov0" title="0">{
                return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
        }</span>
        <span class="cov0" title="0">for i := range columns </span><span class="cov0" title="0">{
                switch columns[i] </span>{
                case vote.FieldID:<span class="cov0" title="0">
                        value, ok := values[i].(*sql.NullInt64)
                        if !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field id", value)
                        }</span>
                        <span class="cov0" title="0">_m.ID = int(value.Int64)</span>
                case vote.FieldPollID:<span class="cov0" title="0">
                        if value, ok := values[i].(*sql.NullInt64); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field poll_id", values[i])
                        }</span> else<span class="cov0" title="0"> if value.Valid </span><span class="cov0" title="0">{
                                _m.PollID = int(value.Int64)
                        }</span>
                case vote.FieldOptionID:<span class="cov0" title="0">
                        if value, ok := values[i].(*sql.NullInt64); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field option_id", values[i])
                        }</span> else<span class="cov0" title="0"> if value.Valid </span><span class="cov0" title="0">{
                                _m.OptionID = int(value.Int64)
                        }</span>
                case vote.FieldUserID:<span class="cov0" title="0">
                        if value, ok := values[i].(*sql.NullInt64); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field user_id", values[i])
                        }</span> else<span class="cov0" title="0"> if value.Valid </span><span class="cov0" title="0">{
                                _m.UserID = int(value.Int64)
                        }</span>
                case vote.FieldCreatedAt:<span class="cov0" title="0">
                        if value, ok := values[i].(*sql.NullTime); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field created_at", values[i])
                        }</span> else<span class="cov0" title="0"> if value.Valid </span><span class="cov0" title="0">{
                                _m.CreatedAt = value.Time
                        }</span>
                default:<span class="cov0" title="0">
                        _m.selectValues.Set(columns[i], values[i])</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// Value returns the ent.Value that was dynamically selected and assigned to the Vote.
// This includes values selected through modifiers, order, etc.
func (_m *Vote) Value(name string) (ent.Value, error) <span class="cov0" title="0">{
        return _m.selectValues.Get(name)
}</span>

// QueryPoll queries the "poll" edge of the Vote entity.
func (_m *Vote) QueryPoll() *PollQuery <span class="cov0" title="0">{
        return NewVoteClient(_m.config).QueryPoll(_m)
}</span>

// QueryOption queries the "option" edge of the Vote entity.
func (_m *Vote) QueryOption() *PollOptionQuery <span class="cov0" title="0">{
        return NewVoteClient(_m.config).QueryOption(_m)
}</span>

// QueryUser queries the "user" edge of the Vote entity.
func (_m *Vote) QueryUser() *UserQuery <span class="cov0" title="0">{
        return NewVoteClient(_m.config).QueryUser(_m)
}</span>

// Update returns a builder for updating this Vote.
// Note that you need to call Vote.Unwrap() before calling this method if this Vote
// was returned from a transaction, and the transaction was committed or rolled back.
func (_m *Vote) Update() *VoteUpdateOne <span class="cov0" title="0">{
        return NewVoteClient(_m.config).UpdateOne(_m)
}</span>

// Unwrap unwraps the Vote entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (_m *Vote) Unwrap() *Vote <span class="cov0" title="0">{
        _tx, ok := _m.config.driver.(*txDriver)
        if !ok </span><span class="cov0" title="0">{
                panic("ent: Vote is not a transactional entity")</span>
        }
        <span class="cov0" title="0">_m.config.driver = _tx.drv
        return _m</span>
}

// String implements the fmt.Stringer.
func (_m *Vote) String() string <span class="cov0" title="0">{
        var builder strings.Builder
        builder.WriteString("Vote(")
        builder.WriteString(fmt.Sprintf("id=%v, ", _m.ID))
        builder.WriteString("poll_id=")
        builder.WriteString(fmt.Sprintf("%v", _m.PollID))
        builder.WriteString(", ")
        builder.WriteString("option_id=")
        builder.WriteString(fmt.Sprintf("%v", _m.OptionID))
        builder.WriteString(", ")
        builder.WriteString("user_id=")
        builder.WriteString(fmt.Sprintf("%v", _m.UserID))
        builder.WriteString(", ")
        builder.WriteString("created_at=")
        builder.WriteString(_m.CreatedAt.Format(time.ANSIC))
        builder.WriteByte(')')
        return builder.String()
}</span>

// Votes is a parsable slice of Vote.
type Votes []*Vote
</pre>
		
		<pre class="file" id="file38" style="display: none">// Code generated by ent, DO NOT EDIT.

package vote

import (
        "time"

        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
)

const (
        // Label holds the string label denoting the vote type in the database.
        Label = "vote"
        // FieldID holds the string denoting the id field in the database.
        FieldID = "id"
        // FieldPollID holds the string denoting the poll_id field in the database.
        FieldPollID = "poll_id"
        // FieldOptionID holds the string denoting the option_id field in the database.
        FieldOptionID = "option_id"
        // FieldUserID holds the string denoting the user_id field in the database.
        FieldUserID = "user_id"
        // FieldCreatedAt holds the string denoting the created_at field in the database.
        FieldCreatedAt = "created_at"
        // EdgePoll holds the string denoting the poll edge name in mutations.
        EdgePoll = "poll"
        // EdgeOption holds the string denoting the option edge name in mutations.
        EdgeOption = "option"
        // EdgeUser holds the string denoting the user edge name in mutations.
        EdgeUser = "user"
        // Table holds the table name of the vote in the database.
        Table = "votes"
        // PollTable is the table that holds the poll relation/edge.
        PollTable = "votes"
        // PollInverseTable is the table name for the Poll entity.
        // It exists in this package in order to avoid circular dependency with the "poll" package.
        PollInverseTable = "polls"
        // PollColumn is the table column denoting the poll relation/edge.
        PollColumn = "poll_id"
        // OptionTable is the table that holds the option relation/edge.
        OptionTable = "votes"
        // OptionInverseTable is the table name for the PollOption entity.
        // It exists in this package in order to avoid circular dependency with the "polloption" package.
        OptionInverseTable = "poll_options"
        // OptionColumn is the table column denoting the option relation/edge.
        OptionColumn = "option_id"
        // UserTable is the table that holds the user relation/edge.
        UserTable = "votes"
        // UserInverseTable is the table name for the User entity.
        // It exists in this package in order to avoid circular dependency with the "user" package.
        UserInverseTable = "users"
        // UserColumn is the table column denoting the user relation/edge.
        UserColumn = "user_id"
)

// Columns holds all SQL columns for vote fields.
var Columns = []string{
        FieldID,
        FieldPollID,
        FieldOptionID,
        FieldUserID,
        FieldCreatedAt,
}

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool <span class="cov0" title="0">{
        for i := range Columns </span><span class="cov0" title="0">{
                if column == Columns[i] </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

var (
        // DefaultCreatedAt holds the default value on creation for the "created_at" field.
        DefaultCreatedAt func() time.Time
)

// OrderOption defines the ordering options for the Vote queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldID, opts...).ToFunc()
}</span>

// ByPollID orders the results by the poll_id field.
func ByPollID(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldPollID, opts...).ToFunc()
}</span>

// ByOptionID orders the results by the option_id field.
func ByOptionID(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldOptionID, opts...).ToFunc()
}</span>

// ByUserID orders the results by the user_id field.
func ByUserID(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldUserID, opts...).ToFunc()
}</span>

// ByCreatedAt orders the results by the created_at field.
func ByCreatedAt(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldCreatedAt, opts...).ToFunc()
}</span>

// ByPollField orders the results by poll field.
func ByPollField(field string, opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return func(s *sql.Selector) </span><span class="cov0" title="0">{
                sqlgraph.OrderByNeighborTerms(s, newPollStep(), sql.OrderByField(field, opts...))
        }</span>
}

// ByOptionField orders the results by option field.
func ByOptionField(field string, opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return func(s *sql.Selector) </span><span class="cov0" title="0">{
                sqlgraph.OrderByNeighborTerms(s, newOptionStep(), sql.OrderByField(field, opts...))
        }</span>
}

// ByUserField orders the results by user field.
func ByUserField(field string, opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return func(s *sql.Selector) </span><span class="cov0" title="0">{
                sqlgraph.OrderByNeighborTerms(s, newUserStep(), sql.OrderByField(field, opts...))
        }</span>
}
func newPollStep() *sqlgraph.Step <span class="cov0" title="0">{
        return sqlgraph.NewStep(
                sqlgraph.From(Table, FieldID),
                sqlgraph.To(PollInverseTable, FieldID),
                sqlgraph.Edge(sqlgraph.M2O, true, PollTable, PollColumn),
        )
}</span>
func newOptionStep() *sqlgraph.Step <span class="cov0" title="0">{
        return sqlgraph.NewStep(
                sqlgraph.From(Table, FieldID),
                sqlgraph.To(OptionInverseTable, FieldID),
                sqlgraph.Edge(sqlgraph.M2O, true, OptionTable, OptionColumn),
        )
}</span>
func newUserStep() *sqlgraph.Step <span class="cov0" title="0">{
        return sqlgraph.NewStep(
                sqlgraph.From(Table, FieldID),
                sqlgraph.To(UserInverseTable, FieldID),
                sqlgraph.Edge(sqlgraph.M2O, true, UserTable, UserColumn),
        )
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">// Code generated by ent, DO NOT EDIT.

package vote

import (
        "time"

        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
        "github.com/ivankorhner/polling-app/internal/ent/predicate"
)

// ID filters vertices based on their ID field.
func ID(id int) predicate.Vote <span class="cov0" title="0">{
        return predicate.Vote(sql.FieldEQ(FieldID, id))
}</span>

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id int) predicate.Vote <span class="cov0" title="0">{
        return predicate.Vote(sql.FieldEQ(FieldID, id))
}</span>

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id int) predicate.Vote <span class="cov0" title="0">{
        return predicate.Vote(sql.FieldNEQ(FieldID, id))
}</span>

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...int) predicate.Vote <span class="cov0" title="0">{
        return predicate.Vote(sql.FieldIn(FieldID, ids...))
}</span>

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...int) predicate.Vote <span class="cov0" title="0">{
        return predicate.Vote(sql.FieldNotIn(FieldID, ids...))
}</span>

// IDGT applies the GT predicate on the ID field.
func IDGT(id int) predicate.Vote <span class="cov0" title="0">{
        return predicate.Vote(sql.FieldGT(FieldID, id))
}</span>

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id int) predicate.Vote <span class="cov0" title="0">{
        return predicate.Vote(sql.FieldGTE(FieldID, id))
}</span>

// IDLT applies the LT predicate on the ID field.
func IDLT(id int) predicate.Vote <span class="cov0" title="0">{
        return predicate.Vote(sql.FieldLT(FieldID, id))
}</span>

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id int) predicate.Vote <span class="cov0" title="0">{
        return predicate.Vote(sql.FieldLTE(FieldID, id))
}</span>

// PollID applies equality check predicate on the "poll_id" field. It's identical to PollIDEQ.
func PollID(v int) predicate.Vote <span class="cov0" title="0">{
        return predicate.Vote(sql.FieldEQ(FieldPollID, v))
}</span>

// OptionID applies equality check predicate on the "option_id" field. It's identical to OptionIDEQ.
func OptionID(v int) predicate.Vote <span class="cov0" title="0">{
        return predicate.Vote(sql.FieldEQ(FieldOptionID, v))
}</span>

// UserID applies equality check predicate on the "user_id" field. It's identical to UserIDEQ.
func UserID(v int) predicate.Vote <span class="cov0" title="0">{
        return predicate.Vote(sql.FieldEQ(FieldUserID, v))
}</span>

// CreatedAt applies equality check predicate on the "created_at" field. It's identical to CreatedAtEQ.
func CreatedAt(v time.Time) predicate.Vote <span class="cov0" title="0">{
        return predicate.Vote(sql.FieldEQ(FieldCreatedAt, v))
}</span>

// PollIDEQ applies the EQ predicate on the "poll_id" field.
func PollIDEQ(v int) predicate.Vote <span class="cov0" title="0">{
        return predicate.Vote(sql.FieldEQ(FieldPollID, v))
}</span>

// PollIDNEQ applies the NEQ predicate on the "poll_id" field.
func PollIDNEQ(v int) predicate.Vote <span class="cov0" title="0">{
        return predicate.Vote(sql.FieldNEQ(FieldPollID, v))
}</span>

// PollIDIn applies the In predicate on the "poll_id" field.
func PollIDIn(vs ...int) predicate.Vote <span class="cov0" title="0">{
        return predicate.Vote(sql.FieldIn(FieldPollID, vs...))
}</span>

// PollIDNotIn applies the NotIn predicate on the "poll_id" field.
func PollIDNotIn(vs ...int) predicate.Vote <span class="cov0" title="0">{
        return predicate.Vote(sql.FieldNotIn(FieldPollID, vs...))
}</span>

// OptionIDEQ applies the EQ predicate on the "option_id" field.
func OptionIDEQ(v int) predicate.Vote <span class="cov0" title="0">{
        return predicate.Vote(sql.FieldEQ(FieldOptionID, v))
}</span>

// OptionIDNEQ applies the NEQ predicate on the "option_id" field.
func OptionIDNEQ(v int) predicate.Vote <span class="cov0" title="0">{
        return predicate.Vote(sql.FieldNEQ(FieldOptionID, v))
}</span>

// OptionIDIn applies the In predicate on the "option_id" field.
func OptionIDIn(vs ...int) predicate.Vote <span class="cov0" title="0">{
        return predicate.Vote(sql.FieldIn(FieldOptionID, vs...))
}</span>

// OptionIDNotIn applies the NotIn predicate on the "option_id" field.
func OptionIDNotIn(vs ...int) predicate.Vote <span class="cov0" title="0">{
        return predicate.Vote(sql.FieldNotIn(FieldOptionID, vs...))
}</span>

// UserIDEQ applies the EQ predicate on the "user_id" field.
func UserIDEQ(v int) predicate.Vote <span class="cov0" title="0">{
        return predicate.Vote(sql.FieldEQ(FieldUserID, v))
}</span>

// UserIDNEQ applies the NEQ predicate on the "user_id" field.
func UserIDNEQ(v int) predicate.Vote <span class="cov0" title="0">{
        return predicate.Vote(sql.FieldNEQ(FieldUserID, v))
}</span>

// UserIDIn applies the In predicate on the "user_id" field.
func UserIDIn(vs ...int) predicate.Vote <span class="cov0" title="0">{
        return predicate.Vote(sql.FieldIn(FieldUserID, vs...))
}</span>

// UserIDNotIn applies the NotIn predicate on the "user_id" field.
func UserIDNotIn(vs ...int) predicate.Vote <span class="cov0" title="0">{
        return predicate.Vote(sql.FieldNotIn(FieldUserID, vs...))
}</span>

// CreatedAtEQ applies the EQ predicate on the "created_at" field.
func CreatedAtEQ(v time.Time) predicate.Vote <span class="cov0" title="0">{
        return predicate.Vote(sql.FieldEQ(FieldCreatedAt, v))
}</span>

// CreatedAtNEQ applies the NEQ predicate on the "created_at" field.
func CreatedAtNEQ(v time.Time) predicate.Vote <span class="cov0" title="0">{
        return predicate.Vote(sql.FieldNEQ(FieldCreatedAt, v))
}</span>

// CreatedAtIn applies the In predicate on the "created_at" field.
func CreatedAtIn(vs ...time.Time) predicate.Vote <span class="cov0" title="0">{
        return predicate.Vote(sql.FieldIn(FieldCreatedAt, vs...))
}</span>

// CreatedAtNotIn applies the NotIn predicate on the "created_at" field.
func CreatedAtNotIn(vs ...time.Time) predicate.Vote <span class="cov0" title="0">{
        return predicate.Vote(sql.FieldNotIn(FieldCreatedAt, vs...))
}</span>

// CreatedAtGT applies the GT predicate on the "created_at" field.
func CreatedAtGT(v time.Time) predicate.Vote <span class="cov0" title="0">{
        return predicate.Vote(sql.FieldGT(FieldCreatedAt, v))
}</span>

// CreatedAtGTE applies the GTE predicate on the "created_at" field.
func CreatedAtGTE(v time.Time) predicate.Vote <span class="cov0" title="0">{
        return predicate.Vote(sql.FieldGTE(FieldCreatedAt, v))
}</span>

// CreatedAtLT applies the LT predicate on the "created_at" field.
func CreatedAtLT(v time.Time) predicate.Vote <span class="cov0" title="0">{
        return predicate.Vote(sql.FieldLT(FieldCreatedAt, v))
}</span>

// CreatedAtLTE applies the LTE predicate on the "created_at" field.
func CreatedAtLTE(v time.Time) predicate.Vote <span class="cov0" title="0">{
        return predicate.Vote(sql.FieldLTE(FieldCreatedAt, v))
}</span>

// HasPoll applies the HasEdge predicate on the "poll" edge.
func HasPoll() predicate.Vote <span class="cov0" title="0">{
        return predicate.Vote(func(s *sql.Selector) </span><span class="cov0" title="0">{
                step := sqlgraph.NewStep(
                        sqlgraph.From(Table, FieldID),
                        sqlgraph.Edge(sqlgraph.M2O, true, PollTable, PollColumn),
                )
                sqlgraph.HasNeighbors(s, step)
        }</span>)
}

// HasPollWith applies the HasEdge predicate on the "poll" edge with a given conditions (other predicates).
func HasPollWith(preds ...predicate.Poll) predicate.Vote <span class="cov0" title="0">{
        return predicate.Vote(func(s *sql.Selector) </span><span class="cov0" title="0">{
                step := newPollStep()
                sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) </span><span class="cov0" title="0">{
                        for _, p := range preds </span><span class="cov0" title="0">{
                                p(s)
                        }</span>
                })
        })
}

// HasOption applies the HasEdge predicate on the "option" edge.
func HasOption() predicate.Vote <span class="cov0" title="0">{
        return predicate.Vote(func(s *sql.Selector) </span><span class="cov0" title="0">{
                step := sqlgraph.NewStep(
                        sqlgraph.From(Table, FieldID),
                        sqlgraph.Edge(sqlgraph.M2O, true, OptionTable, OptionColumn),
                )
                sqlgraph.HasNeighbors(s, step)
        }</span>)
}

// HasOptionWith applies the HasEdge predicate on the "option" edge with a given conditions (other predicates).
func HasOptionWith(preds ...predicate.PollOption) predicate.Vote <span class="cov0" title="0">{
        return predicate.Vote(func(s *sql.Selector) </span><span class="cov0" title="0">{
                step := newOptionStep()
                sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) </span><span class="cov0" title="0">{
                        for _, p := range preds </span><span class="cov0" title="0">{
                                p(s)
                        }</span>
                })
        })
}

// HasUser applies the HasEdge predicate on the "user" edge.
func HasUser() predicate.Vote <span class="cov0" title="0">{
        return predicate.Vote(func(s *sql.Selector) </span><span class="cov0" title="0">{
                step := sqlgraph.NewStep(
                        sqlgraph.From(Table, FieldID),
                        sqlgraph.Edge(sqlgraph.M2O, true, UserTable, UserColumn),
                )
                sqlgraph.HasNeighbors(s, step)
        }</span>)
}

// HasUserWith applies the HasEdge predicate on the "user" edge with a given conditions (other predicates).
func HasUserWith(preds ...predicate.User) predicate.Vote <span class="cov0" title="0">{
        return predicate.Vote(func(s *sql.Selector) </span><span class="cov0" title="0">{
                step := newUserStep()
                sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) </span><span class="cov0" title="0">{
                        for _, p := range preds </span><span class="cov0" title="0">{
                                p(s)
                        }</span>
                })
        })
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.Vote) predicate.Vote <span class="cov0" title="0">{
        return predicate.Vote(sql.AndPredicates(predicates...))
}</span>

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.Vote) predicate.Vote <span class="cov0" title="0">{
        return predicate.Vote(sql.OrPredicates(predicates...))
}</span>

// Not applies the not operator on the given predicate.
func Not(p predicate.Vote) predicate.Vote <span class="cov0" title="0">{
        return predicate.Vote(sql.NotPredicates(p))
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "context"
        "errors"
        "fmt"
        "time"

        "entgo.io/ent/dialect/sql/sqlgraph"
        "entgo.io/ent/schema/field"
        "github.com/ivankorhner/polling-app/internal/ent/poll"
        "github.com/ivankorhner/polling-app/internal/ent/polloption"
        "github.com/ivankorhner/polling-app/internal/ent/user"
        "github.com/ivankorhner/polling-app/internal/ent/vote"
)

// VoteCreate is the builder for creating a Vote entity.
type VoteCreate struct {
        config
        mutation *VoteMutation
        hooks    []Hook
}

// SetPollID sets the "poll_id" field.
func (_c *VoteCreate) SetPollID(v int) *VoteCreate <span class="cov0" title="0">{
        _c.mutation.SetPollID(v)
        return _c
}</span>

// SetOptionID sets the "option_id" field.
func (_c *VoteCreate) SetOptionID(v int) *VoteCreate <span class="cov0" title="0">{
        _c.mutation.SetOptionID(v)
        return _c
}</span>

// SetUserID sets the "user_id" field.
func (_c *VoteCreate) SetUserID(v int) *VoteCreate <span class="cov0" title="0">{
        _c.mutation.SetUserID(v)
        return _c
}</span>

// SetCreatedAt sets the "created_at" field.
func (_c *VoteCreate) SetCreatedAt(v time.Time) *VoteCreate <span class="cov0" title="0">{
        _c.mutation.SetCreatedAt(v)
        return _c
}</span>

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (_c *VoteCreate) SetNillableCreatedAt(v *time.Time) *VoteCreate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _c.SetCreatedAt(*v)
        }</span>
        <span class="cov0" title="0">return _c</span>
}

// SetID sets the "id" field.
func (_c *VoteCreate) SetID(v int) *VoteCreate <span class="cov0" title="0">{
        _c.mutation.SetID(v)
        return _c
}</span>

// SetPoll sets the "poll" edge to the Poll entity.
func (_c *VoteCreate) SetPoll(v *Poll) *VoteCreate <span class="cov0" title="0">{
        return _c.SetPollID(v.ID)
}</span>

// SetOption sets the "option" edge to the PollOption entity.
func (_c *VoteCreate) SetOption(v *PollOption) *VoteCreate <span class="cov0" title="0">{
        return _c.SetOptionID(v.ID)
}</span>

// SetUser sets the "user" edge to the User entity.
func (_c *VoteCreate) SetUser(v *User) *VoteCreate <span class="cov0" title="0">{
        return _c.SetUserID(v.ID)
}</span>

// Mutation returns the VoteMutation object of the builder.
func (_c *VoteCreate) Mutation() *VoteMutation <span class="cov0" title="0">{
        return _c.mutation
}</span>

// Save creates the Vote in the database.
func (_c *VoteCreate) Save(ctx context.Context) (*Vote, error) <span class="cov0" title="0">{
        _c.defaults()
        return withHooks(ctx, _c.sqlSave, _c.mutation, _c.hooks)
}</span>

// SaveX calls Save and panics if Save returns an error.
func (_c *VoteCreate) SaveX(ctx context.Context) *Vote <span class="cov0" title="0">{
        v, err := _c.Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return v</span>
}

// Exec executes the query.
func (_c *VoteCreate) Exec(ctx context.Context) error <span class="cov0" title="0">{
        _, err := _c.Save(ctx)
        return err
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (_c *VoteCreate) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := _c.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// defaults sets the default values of the builder before save.
func (_c *VoteCreate) defaults() <span class="cov0" title="0">{
        if _, ok := _c.mutation.CreatedAt(); !ok </span><span class="cov0" title="0">{
                v := vote.DefaultCreatedAt()
                _c.mutation.SetCreatedAt(v)
        }</span>
}

// check runs all checks and user-defined validators on the builder.
func (_c *VoteCreate) check() error <span class="cov0" title="0">{
        if _, ok := _c.mutation.PollID(); !ok </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "poll_id", err: errors.New(`ent: missing required field "Vote.poll_id"`)}
        }</span>
        <span class="cov0" title="0">if _, ok := _c.mutation.OptionID(); !ok </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "option_id", err: errors.New(`ent: missing required field "Vote.option_id"`)}
        }</span>
        <span class="cov0" title="0">if _, ok := _c.mutation.UserID(); !ok </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "user_id", err: errors.New(`ent: missing required field "Vote.user_id"`)}
        }</span>
        <span class="cov0" title="0">if _, ok := _c.mutation.CreatedAt(); !ok </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "created_at", err: errors.New(`ent: missing required field "Vote.created_at"`)}
        }</span>
        <span class="cov0" title="0">if len(_c.mutation.PollIDs()) == 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "poll", err: errors.New(`ent: missing required edge "Vote.poll"`)}
        }</span>
        <span class="cov0" title="0">if len(_c.mutation.OptionIDs()) == 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "option", err: errors.New(`ent: missing required edge "Vote.option"`)}
        }</span>
        <span class="cov0" title="0">if len(_c.mutation.UserIDs()) == 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "user", err: errors.New(`ent: missing required edge "Vote.user"`)}
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (_c *VoteCreate) sqlSave(ctx context.Context) (*Vote, error) <span class="cov0" title="0">{
        if err := _c.check(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">_node, _spec := _c.createSpec()
        if err := sqlgraph.CreateNode(ctx, _c.driver, _spec); err != nil </span><span class="cov0" title="0">{
                if sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                        err = &amp;ConstraintError{msg: err.Error(), wrap: err}
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">if _spec.ID.Value != _node.ID </span><span class="cov0" title="0">{
                id := _spec.ID.Value.(int64)
                _node.ID = int(id)
        }</span>
        <span class="cov0" title="0">_c.mutation.id = &amp;_node.ID
        _c.mutation.done = true
        return _node, nil</span>
}

func (_c *VoteCreate) createSpec() (*Vote, *sqlgraph.CreateSpec) <span class="cov0" title="0">{
        var (
                _node = &amp;Vote{config: _c.config}
                _spec = sqlgraph.NewCreateSpec(vote.Table, sqlgraph.NewFieldSpec(vote.FieldID, field.TypeInt))
        )
        if id, ok := _c.mutation.ID(); ok </span><span class="cov0" title="0">{
                _node.ID = id
                _spec.ID.Value = id
        }</span>
        <span class="cov0" title="0">if value, ok := _c.mutation.CreatedAt(); ok </span><span class="cov0" title="0">{
                _spec.SetField(vote.FieldCreatedAt, field.TypeTime, value)
                _node.CreatedAt = value
        }</span>
        <span class="cov0" title="0">if nodes := _c.mutation.PollIDs(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2O,
                        Inverse: true,
                        Table:   vote.PollTable,
                        Columns: []string{vote.PollColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(poll.FieldID, field.TypeInt),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_node.PollID = nodes[0]
                _spec.Edges = append(_spec.Edges, edge)</span>
        }
        <span class="cov0" title="0">if nodes := _c.mutation.OptionIDs(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2O,
                        Inverse: true,
                        Table:   vote.OptionTable,
                        Columns: []string{vote.OptionColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(polloption.FieldID, field.TypeInt),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_node.OptionID = nodes[0]
                _spec.Edges = append(_spec.Edges, edge)</span>
        }
        <span class="cov0" title="0">if nodes := _c.mutation.UserIDs(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2O,
                        Inverse: true,
                        Table:   vote.UserTable,
                        Columns: []string{vote.UserColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeInt),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_node.UserID = nodes[0]
                _spec.Edges = append(_spec.Edges, edge)</span>
        }
        <span class="cov0" title="0">return _node, _spec</span>
}

// VoteCreateBulk is the builder for creating many Vote entities in bulk.
type VoteCreateBulk struct {
        config
        err      error
        builders []*VoteCreate
}

// Save creates the Vote entities in the database.
func (_c *VoteCreateBulk) Save(ctx context.Context) ([]*Vote, error) <span class="cov0" title="0">{
        if _c.err != nil </span><span class="cov0" title="0">{
                return nil, _c.err
        }</span>
        <span class="cov0" title="0">specs := make([]*sqlgraph.CreateSpec, len(_c.builders))
        nodes := make([]*Vote, len(_c.builders))
        mutators := make([]Mutator, len(_c.builders))
        for i := range _c.builders </span><span class="cov0" title="0">{
                func(i int, root context.Context) </span><span class="cov0" title="0">{
                        builder := _c.builders[i]
                        builder.defaults()
                        var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) </span><span class="cov0" title="0">{
                                mutation, ok := m.(*VoteMutation)
                                if !ok </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("unexpected mutation type %T", m)
                                }</span>
                                <span class="cov0" title="0">if err := builder.check(); err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">builder.mutation = mutation
                                var err error
                                nodes[i], specs[i] = builder.createSpec()
                                if i &lt; len(mutators)-1 </span><span class="cov0" title="0">{
                                        _, err = mutators[i+1].Mutate(root, _c.builders[i+1].mutation)
                                }</span> else<span class="cov0" title="0"> {
                                        spec := &amp;sqlgraph.BatchCreateSpec{Nodes: specs}
                                        // Invoke the actual operation on the latest mutation in the chain.
                                        if err = sqlgraph.BatchCreate(ctx, _c.driver, spec); err != nil </span><span class="cov0" title="0">{
                                                if sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                                                        err = &amp;ConstraintError{msg: err.Error(), wrap: err}
                                                }</span>
                                        }
                                }
                                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">mutation.id = &amp;nodes[i].ID
                                if specs[i].ID.Value != nil &amp;&amp; nodes[i].ID == 0 </span><span class="cov0" title="0">{
                                        id := specs[i].ID.Value.(int64)
                                        nodes[i].ID = int(id)
                                }</span>
                                <span class="cov0" title="0">mutation.done = true
                                return nodes[i], nil</span>
                        })
                        <span class="cov0" title="0">for i := len(builder.hooks) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                                mut = builder.hooks[i](mut)
                        }</span>
                        <span class="cov0" title="0">mutators[i] = mut</span>
                }(i, ctx)
        }
        <span class="cov0" title="0">if len(mutators) &gt; 0 </span><span class="cov0" title="0">{
                if _, err := mutators[0].Mutate(ctx, _c.builders[0].mutation); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return nodes, nil</span>
}

// SaveX is like Save, but panics if an error occurs.
func (_c *VoteCreateBulk) SaveX(ctx context.Context) []*Vote <span class="cov0" title="0">{
        v, err := _c.Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return v</span>
}

// Exec executes the query.
func (_c *VoteCreateBulk) Exec(ctx context.Context) error <span class="cov0" title="0">{
        _, err := _c.Save(ctx)
        return err
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (_c *VoteCreateBulk) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := _c.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}
</pre>
		
		<pre class="file" id="file41" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "context"

        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
        "entgo.io/ent/schema/field"
        "github.com/ivankorhner/polling-app/internal/ent/predicate"
        "github.com/ivankorhner/polling-app/internal/ent/vote"
)

// VoteDelete is the builder for deleting a Vote entity.
type VoteDelete struct {
        config
        hooks    []Hook
        mutation *VoteMutation
}

// Where appends a list predicates to the VoteDelete builder.
func (_d *VoteDelete) Where(ps ...predicate.Vote) *VoteDelete <span class="cov0" title="0">{
        _d.mutation.Where(ps...)
        return _d
}</span>

// Exec executes the deletion query and returns how many vertices were deleted.
func (_d *VoteDelete) Exec(ctx context.Context) (int, error) <span class="cov0" title="0">{
        return withHooks(ctx, _d.sqlExec, _d.mutation, _d.hooks)
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (_d *VoteDelete) ExecX(ctx context.Context) int <span class="cov0" title="0">{
        n, err := _d.Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return n</span>
}

func (_d *VoteDelete) sqlExec(ctx context.Context) (int, error) <span class="cov0" title="0">{
        _spec := sqlgraph.NewDeleteSpec(vote.Table, sqlgraph.NewFieldSpec(vote.FieldID, field.TypeInt))
        if ps := _d.mutation.predicates; len(ps) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Predicate = func(selector *sql.Selector) </span><span class="cov0" title="0">{
                        for i := range ps </span><span class="cov0" title="0">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov0" title="0">affected, err := sqlgraph.DeleteNodes(ctx, _d.driver, _spec)
        if err != nil &amp;&amp; sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                err = &amp;ConstraintError{msg: err.Error(), wrap: err}
        }</span>
        <span class="cov0" title="0">_d.mutation.done = true
        return affected, err</span>
}

// VoteDeleteOne is the builder for deleting a single Vote entity.
type VoteDeleteOne struct {
        _d *VoteDelete
}

// Where appends a list predicates to the VoteDelete builder.
func (_d *VoteDeleteOne) Where(ps ...predicate.Vote) *VoteDeleteOne <span class="cov0" title="0">{
        _d._d.mutation.Where(ps...)
        return _d
}</span>

// Exec executes the deletion query.
func (_d *VoteDeleteOne) Exec(ctx context.Context) error <span class="cov0" title="0">{
        n, err := _d._d.Exec(ctx)
        switch </span>{
        case err != nil:<span class="cov0" title="0">
                return err</span>
        case n == 0:<span class="cov0" title="0">
                return &amp;NotFoundError{vote.Label}</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

// ExecX is like Exec, but panics if an error occurs.
func (_d *VoteDeleteOne) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := _d.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}
</pre>
		
		<pre class="file" id="file42" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "context"
        "fmt"
        "math"

        "entgo.io/ent"
        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
        "entgo.io/ent/schema/field"
        "github.com/ivankorhner/polling-app/internal/ent/poll"
        "github.com/ivankorhner/polling-app/internal/ent/polloption"
        "github.com/ivankorhner/polling-app/internal/ent/predicate"
        "github.com/ivankorhner/polling-app/internal/ent/user"
        "github.com/ivankorhner/polling-app/internal/ent/vote"
)

// VoteQuery is the builder for querying Vote entities.
type VoteQuery struct {
        config
        ctx        *QueryContext
        order      []vote.OrderOption
        inters     []Interceptor
        predicates []predicate.Vote
        withPoll   *PollQuery
        withOption *PollOptionQuery
        withUser   *UserQuery
        // intermediate query (i.e. traversal path).
        sql  *sql.Selector
        path func(context.Context) (*sql.Selector, error)
}

// Where adds a new predicate for the VoteQuery builder.
func (_q *VoteQuery) Where(ps ...predicate.Vote) *VoteQuery <span class="cov0" title="0">{
        _q.predicates = append(_q.predicates, ps...)
        return _q
}</span>

// Limit the number of records to be returned by this query.
func (_q *VoteQuery) Limit(limit int) *VoteQuery <span class="cov0" title="0">{
        _q.ctx.Limit = &amp;limit
        return _q
}</span>

// Offset to start from.
func (_q *VoteQuery) Offset(offset int) *VoteQuery <span class="cov0" title="0">{
        _q.ctx.Offset = &amp;offset
        return _q
}</span>

// Unique configures the query builder to filter duplicate records on query.
// By default, unique is set to true, and can be disabled using this method.
func (_q *VoteQuery) Unique(unique bool) *VoteQuery <span class="cov0" title="0">{
        _q.ctx.Unique = &amp;unique
        return _q
}</span>

// Order specifies how the records should be ordered.
func (_q *VoteQuery) Order(o ...vote.OrderOption) *VoteQuery <span class="cov0" title="0">{
        _q.order = append(_q.order, o...)
        return _q
}</span>

// QueryPoll chains the current query on the "poll" edge.
func (_q *VoteQuery) QueryPoll() *PollQuery <span class="cov0" title="0">{
        query := (&amp;PollClient{config: _q.config}).Query()
        query.path = func(ctx context.Context) (fromU *sql.Selector, err error) </span><span class="cov0" title="0">{
                if err := _q.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">selector := _q.sqlQuery(ctx)
                if err := selector.Err(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">step := sqlgraph.NewStep(
                        sqlgraph.From(vote.Table, vote.FieldID, selector),
                        sqlgraph.To(poll.Table, poll.FieldID),
                        sqlgraph.Edge(sqlgraph.M2O, true, vote.PollTable, vote.PollColumn),
                )
                fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
                return fromU, nil</span>
        }
        <span class="cov0" title="0">return query</span>
}

// QueryOption chains the current query on the "option" edge.
func (_q *VoteQuery) QueryOption() *PollOptionQuery <span class="cov0" title="0">{
        query := (&amp;PollOptionClient{config: _q.config}).Query()
        query.path = func(ctx context.Context) (fromU *sql.Selector, err error) </span><span class="cov0" title="0">{
                if err := _q.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">selector := _q.sqlQuery(ctx)
                if err := selector.Err(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">step := sqlgraph.NewStep(
                        sqlgraph.From(vote.Table, vote.FieldID, selector),
                        sqlgraph.To(polloption.Table, polloption.FieldID),
                        sqlgraph.Edge(sqlgraph.M2O, true, vote.OptionTable, vote.OptionColumn),
                )
                fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
                return fromU, nil</span>
        }
        <span class="cov0" title="0">return query</span>
}

// QueryUser chains the current query on the "user" edge.
func (_q *VoteQuery) QueryUser() *UserQuery <span class="cov0" title="0">{
        query := (&amp;UserClient{config: _q.config}).Query()
        query.path = func(ctx context.Context) (fromU *sql.Selector, err error) </span><span class="cov0" title="0">{
                if err := _q.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">selector := _q.sqlQuery(ctx)
                if err := selector.Err(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">step := sqlgraph.NewStep(
                        sqlgraph.From(vote.Table, vote.FieldID, selector),
                        sqlgraph.To(user.Table, user.FieldID),
                        sqlgraph.Edge(sqlgraph.M2O, true, vote.UserTable, vote.UserColumn),
                )
                fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
                return fromU, nil</span>
        }
        <span class="cov0" title="0">return query</span>
}

// First returns the first Vote entity from the query.
// Returns a *NotFoundError when no Vote was found.
func (_q *VoteQuery) First(ctx context.Context) (*Vote, error) <span class="cov0" title="0">{
        nodes, err := _q.Limit(1).All(setContextOp(ctx, _q.ctx, ent.OpQueryFirst))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(nodes) == 0 </span><span class="cov0" title="0">{
                return nil, &amp;NotFoundError{vote.Label}
        }</span>
        <span class="cov0" title="0">return nodes[0], nil</span>
}

// FirstX is like First, but panics if an error occurs.
func (_q *VoteQuery) FirstX(ctx context.Context) *Vote <span class="cov0" title="0">{
        node, err := _q.First(ctx)
        if err != nil &amp;&amp; !IsNotFound(err) </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return node</span>
}

// FirstID returns the first Vote ID from the query.
// Returns a *NotFoundError when no Vote ID was found.
func (_q *VoteQuery) FirstID(ctx context.Context) (id int, err error) <span class="cov0" title="0">{
        var ids []int
        if ids, err = _q.Limit(1).IDs(setContextOp(ctx, _q.ctx, ent.OpQueryFirstID)); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if len(ids) == 0 </span><span class="cov0" title="0">{
                err = &amp;NotFoundError{vote.Label}
                return
        }</span>
        <span class="cov0" title="0">return ids[0], nil</span>
}

// FirstIDX is like FirstID, but panics if an error occurs.
func (_q *VoteQuery) FirstIDX(ctx context.Context) int <span class="cov0" title="0">{
        id, err := _q.FirstID(ctx)
        if err != nil &amp;&amp; !IsNotFound(err) </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return id</span>
}

// Only returns a single Vote entity found by the query, ensuring it only returns one.
// Returns a *NotSingularError when more than one Vote entity is found.
// Returns a *NotFoundError when no Vote entities are found.
func (_q *VoteQuery) Only(ctx context.Context) (*Vote, error) <span class="cov0" title="0">{
        nodes, err := _q.Limit(2).All(setContextOp(ctx, _q.ctx, ent.OpQueryOnly))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">switch len(nodes) </span>{
        case 1:<span class="cov0" title="0">
                return nodes[0], nil</span>
        case 0:<span class="cov0" title="0">
                return nil, &amp;NotFoundError{vote.Label}</span>
        default:<span class="cov0" title="0">
                return nil, &amp;NotSingularError{vote.Label}</span>
        }
}

// OnlyX is like Only, but panics if an error occurs.
func (_q *VoteQuery) OnlyX(ctx context.Context) *Vote <span class="cov0" title="0">{
        node, err := _q.Only(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return node</span>
}

// OnlyID is like Only, but returns the only Vote ID in the query.
// Returns a *NotSingularError when more than one Vote ID is found.
// Returns a *NotFoundError when no entities are found.
func (_q *VoteQuery) OnlyID(ctx context.Context) (id int, err error) <span class="cov0" title="0">{
        var ids []int
        if ids, err = _q.Limit(2).IDs(setContextOp(ctx, _q.ctx, ent.OpQueryOnlyID)); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">switch len(ids) </span>{
        case 1:<span class="cov0" title="0">
                id = ids[0]</span>
        case 0:<span class="cov0" title="0">
                err = &amp;NotFoundError{vote.Label}</span>
        default:<span class="cov0" title="0">
                err = &amp;NotSingularError{vote.Label}</span>
        }
        <span class="cov0" title="0">return</span>
}

// OnlyIDX is like OnlyID, but panics if an error occurs.
func (_q *VoteQuery) OnlyIDX(ctx context.Context) int <span class="cov0" title="0">{
        id, err := _q.OnlyID(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return id</span>
}

// All executes the query and returns a list of Votes.
func (_q *VoteQuery) All(ctx context.Context) ([]*Vote, error) <span class="cov0" title="0">{
        ctx = setContextOp(ctx, _q.ctx, ent.OpQueryAll)
        if err := _q.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">qr := querierAll[[]*Vote, *VoteQuery]()
        return withInterceptors[[]*Vote](ctx, _q, qr, _q.inters)</span>
}

// AllX is like All, but panics if an error occurs.
func (_q *VoteQuery) AllX(ctx context.Context) []*Vote <span class="cov0" title="0">{
        nodes, err := _q.All(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return nodes</span>
}

// IDs executes the query and returns a list of Vote IDs.
func (_q *VoteQuery) IDs(ctx context.Context) (ids []int, err error) <span class="cov0" title="0">{
        if _q.ctx.Unique == nil &amp;&amp; _q.path != nil </span><span class="cov0" title="0">{
                _q.Unique(true)
        }</span>
        <span class="cov0" title="0">ctx = setContextOp(ctx, _q.ctx, ent.OpQueryIDs)
        if err = _q.Select(vote.FieldID).Scan(ctx, &amp;ids); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ids, nil</span>
}

// IDsX is like IDs, but panics if an error occurs.
func (_q *VoteQuery) IDsX(ctx context.Context) []int <span class="cov0" title="0">{
        ids, err := _q.IDs(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return ids</span>
}

// Count returns the count of the given query.
func (_q *VoteQuery) Count(ctx context.Context) (int, error) <span class="cov0" title="0">{
        ctx = setContextOp(ctx, _q.ctx, ent.OpQueryCount)
        if err := _q.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return withInterceptors[int](ctx, _q, querierCount[*VoteQuery](), _q.inters)</span>
}

// CountX is like Count, but panics if an error occurs.
func (_q *VoteQuery) CountX(ctx context.Context) int <span class="cov0" title="0">{
        count, err := _q.Count(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return count</span>
}

// Exist returns true if the query has elements in the graph.
func (_q *VoteQuery) Exist(ctx context.Context) (bool, error) <span class="cov0" title="0">{
        ctx = setContextOp(ctx, _q.ctx, ent.OpQueryExist)
        switch _, err := _q.FirstID(ctx); </span>{
        case IsNotFound(err):<span class="cov0" title="0">
                return false, nil</span>
        case err != nil:<span class="cov0" title="0">
                return false, fmt.Errorf("ent: check existence: %w", err)</span>
        default:<span class="cov0" title="0">
                return true, nil</span>
        }
}

// ExistX is like Exist, but panics if an error occurs.
func (_q *VoteQuery) ExistX(ctx context.Context) bool <span class="cov0" title="0">{
        exist, err := _q.Exist(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return exist</span>
}

// Clone returns a duplicate of the VoteQuery builder, including all associated steps. It can be
// used to prepare common query builders and use them differently after the clone is made.
func (_q *VoteQuery) Clone() *VoteQuery <span class="cov0" title="0">{
        if _q == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;VoteQuery{
                config:     _q.config,
                ctx:        _q.ctx.Clone(),
                order:      append([]vote.OrderOption{}, _q.order...),
                inters:     append([]Interceptor{}, _q.inters...),
                predicates: append([]predicate.Vote{}, _q.predicates...),
                withPoll:   _q.withPoll.Clone(),
                withOption: _q.withOption.Clone(),
                withUser:   _q.withUser.Clone(),
                // clone intermediate query.
                sql:  _q.sql.Clone(),
                path: _q.path,
        }</span>
}

// WithPoll tells the query-builder to eager-load the nodes that are connected to
// the "poll" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *VoteQuery) WithPoll(opts ...func(*PollQuery)) *VoteQuery <span class="cov0" title="0">{
        query := (&amp;PollClient{config: _q.config}).Query()
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(query)
        }</span>
        <span class="cov0" title="0">_q.withPoll = query
        return _q</span>
}

// WithOption tells the query-builder to eager-load the nodes that are connected to
// the "option" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *VoteQuery) WithOption(opts ...func(*PollOptionQuery)) *VoteQuery <span class="cov0" title="0">{
        query := (&amp;PollOptionClient{config: _q.config}).Query()
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(query)
        }</span>
        <span class="cov0" title="0">_q.withOption = query
        return _q</span>
}

// WithUser tells the query-builder to eager-load the nodes that are connected to
// the "user" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *VoteQuery) WithUser(opts ...func(*UserQuery)) *VoteQuery <span class="cov0" title="0">{
        query := (&amp;UserClient{config: _q.config}).Query()
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(query)
        }</span>
        <span class="cov0" title="0">_q.withUser = query
        return _q</span>
}

// GroupBy is used to group vertices by one or more fields/columns.
// It is often used with aggregate functions, like: count, max, mean, min, sum.
//
// Example:
//
//        var v []struct {
//                PollID int `json:"poll_id,omitempty"`
//                Count int `json:"count,omitempty"`
//        }
//
//        client.Vote.Query().
//                GroupBy(vote.FieldPollID).
//                Aggregate(ent.Count()).
//                Scan(ctx, &amp;v)
func (_q *VoteQuery) GroupBy(field string, fields ...string) *VoteGroupBy <span class="cov0" title="0">{
        _q.ctx.Fields = append([]string{field}, fields...)
        grbuild := &amp;VoteGroupBy{build: _q}
        grbuild.flds = &amp;_q.ctx.Fields
        grbuild.label = vote.Label
        grbuild.scan = grbuild.Scan
        return grbuild
}</span>

// Select allows the selection one or more fields/columns for the given query,
// instead of selecting all fields in the entity.
//
// Example:
//
//        var v []struct {
//                PollID int `json:"poll_id,omitempty"`
//        }
//
//        client.Vote.Query().
//                Select(vote.FieldPollID).
//                Scan(ctx, &amp;v)
func (_q *VoteQuery) Select(fields ...string) *VoteSelect <span class="cov0" title="0">{
        _q.ctx.Fields = append(_q.ctx.Fields, fields...)
        sbuild := &amp;VoteSelect{VoteQuery: _q}
        sbuild.label = vote.Label
        sbuild.flds, sbuild.scan = &amp;_q.ctx.Fields, sbuild.Scan
        return sbuild
}</span>

// Aggregate returns a VoteSelect configured with the given aggregations.
func (_q *VoteQuery) Aggregate(fns ...AggregateFunc) *VoteSelect <span class="cov0" title="0">{
        return _q.Select().Aggregate(fns...)
}</span>

func (_q *VoteQuery) prepareQuery(ctx context.Context) error <span class="cov0" title="0">{
        for _, inter := range _q.inters </span><span class="cov0" title="0">{
                if inter == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("ent: uninitialized interceptor (forgotten import ent/runtime?)")
                }</span>
                <span class="cov0" title="0">if trv, ok := inter.(Traverser); ok </span><span class="cov0" title="0">{
                        if err := trv.Traverse(ctx, _q); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov0" title="0">for _, f := range _q.ctx.Fields </span><span class="cov0" title="0">{
                if !vote.ValidColumn(f) </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
                }</span>
        }
        <span class="cov0" title="0">if _q.path != nil </span><span class="cov0" title="0">{
                prev, err := _q.path(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">_q.sql = prev</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (_q *VoteQuery) sqlAll(ctx context.Context, hooks ...queryHook) ([]*Vote, error) <span class="cov0" title="0">{
        var (
                nodes       = []*Vote{}
                _spec       = _q.querySpec()
                loadedTypes = [3]bool{
                        _q.withPoll != nil,
                        _q.withOption != nil,
                        _q.withUser != nil,
                }
        )
        _spec.ScanValues = func(columns []string) ([]any, error) </span><span class="cov0" title="0">{
                return (*Vote).scanValues(nil, columns)
        }</span>
        <span class="cov0" title="0">_spec.Assign = func(columns []string, values []any) error </span><span class="cov0" title="0">{
                node := &amp;Vote{config: _q.config}
                nodes = append(nodes, node)
                node.Edges.loadedTypes = loadedTypes
                return node.assignValues(columns, values)
        }</span>
        <span class="cov0" title="0">for i := range hooks </span><span class="cov0" title="0">{
                hooks[i](ctx, _spec)
        }</span>
        <span class="cov0" title="0">if err := sqlgraph.QueryNodes(ctx, _q.driver, _spec); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(nodes) == 0 </span><span class="cov0" title="0">{
                return nodes, nil
        }</span>
        <span class="cov0" title="0">if query := _q.withPoll; query != nil </span><span class="cov0" title="0">{
                if err := _q.loadPoll(ctx, query, nodes, nil,
                        func(n *Vote, e *Poll) </span><span class="cov0" title="0">{ n.Edges.Poll = e }</span>); err != nil <span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">if query := _q.withOption; query != nil </span><span class="cov0" title="0">{
                if err := _q.loadOption(ctx, query, nodes, nil,
                        func(n *Vote, e *PollOption) </span><span class="cov0" title="0">{ n.Edges.Option = e }</span>); err != nil <span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">if query := _q.withUser; query != nil </span><span class="cov0" title="0">{
                if err := _q.loadUser(ctx, query, nodes, nil,
                        func(n *Vote, e *User) </span><span class="cov0" title="0">{ n.Edges.User = e }</span>); err != nil <span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return nodes, nil</span>
}

func (_q *VoteQuery) loadPoll(ctx context.Context, query *PollQuery, nodes []*Vote, init func(*Vote), assign func(*Vote, *Poll)) error <span class="cov0" title="0">{
        ids := make([]int, 0, len(nodes))
        nodeids := make(map[int][]*Vote)
        for i := range nodes </span><span class="cov0" title="0">{
                fk := nodes[i].PollID
                if _, ok := nodeids[fk]; !ok </span><span class="cov0" title="0">{
                        ids = append(ids, fk)
                }</span>
                <span class="cov0" title="0">nodeids[fk] = append(nodeids[fk], nodes[i])</span>
        }
        <span class="cov0" title="0">if len(ids) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">query.Where(poll.IDIn(ids...))
        neighbors, err := query.All(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, n := range neighbors </span><span class="cov0" title="0">{
                nodes, ok := nodeids[n.ID]
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf(`unexpected foreign-key "poll_id" returned %v`, n.ID)
                }</span>
                <span class="cov0" title="0">for i := range nodes </span><span class="cov0" title="0">{
                        assign(nodes[i], n)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
func (_q *VoteQuery) loadOption(ctx context.Context, query *PollOptionQuery, nodes []*Vote, init func(*Vote), assign func(*Vote, *PollOption)) error <span class="cov0" title="0">{
        ids := make([]int, 0, len(nodes))
        nodeids := make(map[int][]*Vote)
        for i := range nodes </span><span class="cov0" title="0">{
                fk := nodes[i].OptionID
                if _, ok := nodeids[fk]; !ok </span><span class="cov0" title="0">{
                        ids = append(ids, fk)
                }</span>
                <span class="cov0" title="0">nodeids[fk] = append(nodeids[fk], nodes[i])</span>
        }
        <span class="cov0" title="0">if len(ids) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">query.Where(polloption.IDIn(ids...))
        neighbors, err := query.All(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, n := range neighbors </span><span class="cov0" title="0">{
                nodes, ok := nodeids[n.ID]
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf(`unexpected foreign-key "option_id" returned %v`, n.ID)
                }</span>
                <span class="cov0" title="0">for i := range nodes </span><span class="cov0" title="0">{
                        assign(nodes[i], n)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
func (_q *VoteQuery) loadUser(ctx context.Context, query *UserQuery, nodes []*Vote, init func(*Vote), assign func(*Vote, *User)) error <span class="cov0" title="0">{
        ids := make([]int, 0, len(nodes))
        nodeids := make(map[int][]*Vote)
        for i := range nodes </span><span class="cov0" title="0">{
                fk := nodes[i].UserID
                if _, ok := nodeids[fk]; !ok </span><span class="cov0" title="0">{
                        ids = append(ids, fk)
                }</span>
                <span class="cov0" title="0">nodeids[fk] = append(nodeids[fk], nodes[i])</span>
        }
        <span class="cov0" title="0">if len(ids) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">query.Where(user.IDIn(ids...))
        neighbors, err := query.All(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, n := range neighbors </span><span class="cov0" title="0">{
                nodes, ok := nodeids[n.ID]
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf(`unexpected foreign-key "user_id" returned %v`, n.ID)
                }</span>
                <span class="cov0" title="0">for i := range nodes </span><span class="cov0" title="0">{
                        assign(nodes[i], n)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (_q *VoteQuery) sqlCount(ctx context.Context) (int, error) <span class="cov0" title="0">{
        _spec := _q.querySpec()
        _spec.Node.Columns = _q.ctx.Fields
        if len(_q.ctx.Fields) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Unique = _q.ctx.Unique != nil &amp;&amp; *_q.ctx.Unique
        }</span>
        <span class="cov0" title="0">return sqlgraph.CountNodes(ctx, _q.driver, _spec)</span>
}

func (_q *VoteQuery) querySpec() *sqlgraph.QuerySpec <span class="cov0" title="0">{
        _spec := sqlgraph.NewQuerySpec(vote.Table, vote.Columns, sqlgraph.NewFieldSpec(vote.FieldID, field.TypeInt))
        _spec.From = _q.sql
        if unique := _q.ctx.Unique; unique != nil </span><span class="cov0" title="0">{
                _spec.Unique = *unique
        }</span> else<span class="cov0" title="0"> if _q.path != nil </span><span class="cov0" title="0">{
                _spec.Unique = true
        }</span>
        <span class="cov0" title="0">if fields := _q.ctx.Fields; len(fields) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Node.Columns = make([]string, 0, len(fields))
                _spec.Node.Columns = append(_spec.Node.Columns, vote.FieldID)
                for i := range fields </span><span class="cov0" title="0">{
                        if fields[i] != vote.FieldID </span><span class="cov0" title="0">{
                                _spec.Node.Columns = append(_spec.Node.Columns, fields[i])
                        }</span>
                }
                <span class="cov0" title="0">if _q.withPoll != nil </span><span class="cov0" title="0">{
                        _spec.Node.AddColumnOnce(vote.FieldPollID)
                }</span>
                <span class="cov0" title="0">if _q.withOption != nil </span><span class="cov0" title="0">{
                        _spec.Node.AddColumnOnce(vote.FieldOptionID)
                }</span>
                <span class="cov0" title="0">if _q.withUser != nil </span><span class="cov0" title="0">{
                        _spec.Node.AddColumnOnce(vote.FieldUserID)
                }</span>
        }
        <span class="cov0" title="0">if ps := _q.predicates; len(ps) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Predicate = func(selector *sql.Selector) </span><span class="cov0" title="0">{
                        for i := range ps </span><span class="cov0" title="0">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov0" title="0">if limit := _q.ctx.Limit; limit != nil </span><span class="cov0" title="0">{
                _spec.Limit = *limit
        }</span>
        <span class="cov0" title="0">if offset := _q.ctx.Offset; offset != nil </span><span class="cov0" title="0">{
                _spec.Offset = *offset
        }</span>
        <span class="cov0" title="0">if ps := _q.order; len(ps) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Order = func(selector *sql.Selector) </span><span class="cov0" title="0">{
                        for i := range ps </span><span class="cov0" title="0">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov0" title="0">return _spec</span>
}

func (_q *VoteQuery) sqlQuery(ctx context.Context) *sql.Selector <span class="cov0" title="0">{
        builder := sql.Dialect(_q.driver.Dialect())
        t1 := builder.Table(vote.Table)
        columns := _q.ctx.Fields
        if len(columns) == 0 </span><span class="cov0" title="0">{
                columns = vote.Columns
        }</span>
        <span class="cov0" title="0">selector := builder.Select(t1.Columns(columns...)...).From(t1)
        if _q.sql != nil </span><span class="cov0" title="0">{
                selector = _q.sql
                selector.Select(selector.Columns(columns...)...)
        }</span>
        <span class="cov0" title="0">if _q.ctx.Unique != nil &amp;&amp; *_q.ctx.Unique </span><span class="cov0" title="0">{
                selector.Distinct()
        }</span>
        <span class="cov0" title="0">for _, p := range _q.predicates </span><span class="cov0" title="0">{
                p(selector)
        }</span>
        <span class="cov0" title="0">for _, p := range _q.order </span><span class="cov0" title="0">{
                p(selector)
        }</span>
        <span class="cov0" title="0">if offset := _q.ctx.Offset; offset != nil </span><span class="cov0" title="0">{
                // limit is mandatory for offset clause. We start
                // with default value, and override it below if needed.
                selector.Offset(*offset).Limit(math.MaxInt32)
        }</span>
        <span class="cov0" title="0">if limit := _q.ctx.Limit; limit != nil </span><span class="cov0" title="0">{
                selector.Limit(*limit)
        }</span>
        <span class="cov0" title="0">return selector</span>
}

// VoteGroupBy is the group-by builder for Vote entities.
type VoteGroupBy struct {
        selector
        build *VoteQuery
}

// Aggregate adds the given aggregation functions to the group-by query.
func (_g *VoteGroupBy) Aggregate(fns ...AggregateFunc) *VoteGroupBy <span class="cov0" title="0">{
        _g.fns = append(_g.fns, fns...)
        return _g
}</span>

// Scan applies the selector query and scans the result into the given value.
func (_g *VoteGroupBy) Scan(ctx context.Context, v any) error <span class="cov0" title="0">{
        ctx = setContextOp(ctx, _g.build.ctx, ent.OpQueryGroupBy)
        if err := _g.build.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return scanWithInterceptors[*VoteQuery, *VoteGroupBy](ctx, _g.build, _g, _g.build.inters, v)</span>
}

func (_g *VoteGroupBy) sqlScan(ctx context.Context, root *VoteQuery, v any) error <span class="cov0" title="0">{
        selector := root.sqlQuery(ctx).Select()
        aggregation := make([]string, 0, len(_g.fns))
        for _, fn := range _g.fns </span><span class="cov0" title="0">{
                aggregation = append(aggregation, fn(selector))
        }</span>
        <span class="cov0" title="0">if len(selector.SelectedColumns()) == 0 </span><span class="cov0" title="0">{
                columns := make([]string, 0, len(*_g.flds)+len(_g.fns))
                for _, f := range *_g.flds </span><span class="cov0" title="0">{
                        columns = append(columns, selector.C(f))
                }</span>
                <span class="cov0" title="0">columns = append(columns, aggregation...)
                selector.Select(columns...)</span>
        }
        <span class="cov0" title="0">selector.GroupBy(selector.Columns(*_g.flds...)...)
        if err := selector.Err(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">rows := &amp;sql.Rows{}
        query, args := selector.Query()
        if err := _g.build.driver.Query(ctx, query, args, rows); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        return sql.ScanSlice(rows, v)</span>
}

// VoteSelect is the builder for selecting fields of Vote entities.
type VoteSelect struct {
        *VoteQuery
        selector
}

// Aggregate adds the given aggregation functions to the selector query.
func (_s *VoteSelect) Aggregate(fns ...AggregateFunc) *VoteSelect <span class="cov0" title="0">{
        _s.fns = append(_s.fns, fns...)
        return _s
}</span>

// Scan applies the selector query and scans the result into the given value.
func (_s *VoteSelect) Scan(ctx context.Context, v any) error <span class="cov0" title="0">{
        ctx = setContextOp(ctx, _s.ctx, ent.OpQuerySelect)
        if err := _s.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return scanWithInterceptors[*VoteQuery, *VoteSelect](ctx, _s.VoteQuery, _s, _s.inters, v)</span>
}

func (_s *VoteSelect) sqlScan(ctx context.Context, root *VoteQuery, v any) error <span class="cov0" title="0">{
        selector := root.sqlQuery(ctx)
        aggregation := make([]string, 0, len(_s.fns))
        for _, fn := range _s.fns </span><span class="cov0" title="0">{
                aggregation = append(aggregation, fn(selector))
        }</span>
        <span class="cov0" title="0">switch n := len(*_s.selector.flds); </span>{
        case n == 0 &amp;&amp; len(aggregation) &gt; 0:<span class="cov0" title="0">
                selector.Select(aggregation...)</span>
        case n != 0 &amp;&amp; len(aggregation) &gt; 0:<span class="cov0" title="0">
                selector.AppendSelect(aggregation...)</span>
        }
        <span class="cov0" title="0">rows := &amp;sql.Rows{}
        query, args := selector.Query()
        if err := _s.driver.Query(ctx, query, args, rows); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        return sql.ScanSlice(rows, v)</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "context"
        "errors"
        "fmt"

        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
        "entgo.io/ent/schema/field"
        "github.com/ivankorhner/polling-app/internal/ent/predicate"
        "github.com/ivankorhner/polling-app/internal/ent/vote"
)

// VoteUpdate is the builder for updating Vote entities.
type VoteUpdate struct {
        config
        hooks    []Hook
        mutation *VoteMutation
}

// Where appends a list predicates to the VoteUpdate builder.
func (_u *VoteUpdate) Where(ps ...predicate.Vote) *VoteUpdate <span class="cov0" title="0">{
        _u.mutation.Where(ps...)
        return _u
}</span>

// Mutation returns the VoteMutation object of the builder.
func (_u *VoteUpdate) Mutation() *VoteMutation <span class="cov0" title="0">{
        return _u.mutation
}</span>

// Save executes the query and returns the number of nodes affected by the update operation.
func (_u *VoteUpdate) Save(ctx context.Context) (int, error) <span class="cov0" title="0">{
        return withHooks(ctx, _u.sqlSave, _u.mutation, _u.hooks)
}</span>

// SaveX is like Save, but panics if an error occurs.
func (_u *VoteUpdate) SaveX(ctx context.Context) int <span class="cov0" title="0">{
        affected, err := _u.Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return affected</span>
}

// Exec executes the query.
func (_u *VoteUpdate) Exec(ctx context.Context) error <span class="cov0" title="0">{
        _, err := _u.Save(ctx)
        return err
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (_u *VoteUpdate) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := _u.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// check runs all checks and user-defined validators on the builder.
func (_u *VoteUpdate) check() error <span class="cov0" title="0">{
        if _u.mutation.PollCleared() &amp;&amp; len(_u.mutation.PollIDs()) &gt; 0 </span><span class="cov0" title="0">{
                return errors.New(`ent: clearing a required unique edge "Vote.poll"`)
        }</span>
        <span class="cov0" title="0">if _u.mutation.OptionCleared() &amp;&amp; len(_u.mutation.OptionIDs()) &gt; 0 </span><span class="cov0" title="0">{
                return errors.New(`ent: clearing a required unique edge "Vote.option"`)
        }</span>
        <span class="cov0" title="0">if _u.mutation.UserCleared() &amp;&amp; len(_u.mutation.UserIDs()) &gt; 0 </span><span class="cov0" title="0">{
                return errors.New(`ent: clearing a required unique edge "Vote.user"`)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (_u *VoteUpdate) sqlSave(ctx context.Context) (_node int, err error) <span class="cov0" title="0">{
        if err := _u.check(); err != nil </span><span class="cov0" title="0">{
                return _node, err
        }</span>
        <span class="cov0" title="0">_spec := sqlgraph.NewUpdateSpec(vote.Table, vote.Columns, sqlgraph.NewFieldSpec(vote.FieldID, field.TypeInt))
        if ps := _u.mutation.predicates; len(ps) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Predicate = func(selector *sql.Selector) </span><span class="cov0" title="0">{
                        for i := range ps </span><span class="cov0" title="0">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov0" title="0">if _node, err = sqlgraph.UpdateNodes(ctx, _u.driver, _spec); err != nil </span><span class="cov0" title="0">{
                if _, ok := err.(*sqlgraph.NotFoundError); ok </span><span class="cov0" title="0">{
                        err = &amp;NotFoundError{vote.Label}
                }</span> else<span class="cov0" title="0"> if sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                        err = &amp;ConstraintError{msg: err.Error(), wrap: err}
                }</span>
                <span class="cov0" title="0">return 0, err</span>
        }
        <span class="cov0" title="0">_u.mutation.done = true
        return _node, nil</span>
}

// VoteUpdateOne is the builder for updating a single Vote entity.
type VoteUpdateOne struct {
        config
        fields   []string
        hooks    []Hook
        mutation *VoteMutation
}

// Mutation returns the VoteMutation object of the builder.
func (_u *VoteUpdateOne) Mutation() *VoteMutation <span class="cov0" title="0">{
        return _u.mutation
}</span>

// Where appends a list predicates to the VoteUpdate builder.
func (_u *VoteUpdateOne) Where(ps ...predicate.Vote) *VoteUpdateOne <span class="cov0" title="0">{
        _u.mutation.Where(ps...)
        return _u
}</span>

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (_u *VoteUpdateOne) Select(field string, fields ...string) *VoteUpdateOne <span class="cov0" title="0">{
        _u.fields = append([]string{field}, fields...)
        return _u
}</span>

// Save executes the query and returns the updated Vote entity.
func (_u *VoteUpdateOne) Save(ctx context.Context) (*Vote, error) <span class="cov0" title="0">{
        return withHooks(ctx, _u.sqlSave, _u.mutation, _u.hooks)
}</span>

// SaveX is like Save, but panics if an error occurs.
func (_u *VoteUpdateOne) SaveX(ctx context.Context) *Vote <span class="cov0" title="0">{
        node, err := _u.Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return node</span>
}

// Exec executes the query on the entity.
func (_u *VoteUpdateOne) Exec(ctx context.Context) error <span class="cov0" title="0">{
        _, err := _u.Save(ctx)
        return err
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (_u *VoteUpdateOne) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := _u.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// check runs all checks and user-defined validators on the builder.
func (_u *VoteUpdateOne) check() error <span class="cov0" title="0">{
        if _u.mutation.PollCleared() &amp;&amp; len(_u.mutation.PollIDs()) &gt; 0 </span><span class="cov0" title="0">{
                return errors.New(`ent: clearing a required unique edge "Vote.poll"`)
        }</span>
        <span class="cov0" title="0">if _u.mutation.OptionCleared() &amp;&amp; len(_u.mutation.OptionIDs()) &gt; 0 </span><span class="cov0" title="0">{
                return errors.New(`ent: clearing a required unique edge "Vote.option"`)
        }</span>
        <span class="cov0" title="0">if _u.mutation.UserCleared() &amp;&amp; len(_u.mutation.UserIDs()) &gt; 0 </span><span class="cov0" title="0">{
                return errors.New(`ent: clearing a required unique edge "Vote.user"`)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (_u *VoteUpdateOne) sqlSave(ctx context.Context) (_node *Vote, err error) <span class="cov0" title="0">{
        if err := _u.check(); err != nil </span><span class="cov0" title="0">{
                return _node, err
        }</span>
        <span class="cov0" title="0">_spec := sqlgraph.NewUpdateSpec(vote.Table, vote.Columns, sqlgraph.NewFieldSpec(vote.FieldID, field.TypeInt))
        id, ok := _u.mutation.ID()
        if !ok </span><span class="cov0" title="0">{
                return nil, &amp;ValidationError{Name: "id", err: errors.New(`ent: missing "Vote.id" for update`)}
        }</span>
        <span class="cov0" title="0">_spec.Node.ID.Value = id
        if fields := _u.fields; len(fields) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Node.Columns = make([]string, 0, len(fields))
                _spec.Node.Columns = append(_spec.Node.Columns, vote.FieldID)
                for _, f := range fields </span><span class="cov0" title="0">{
                        if !vote.ValidColumn(f) </span><span class="cov0" title="0">{
                                return nil, &amp;ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
                        }</span>
                        <span class="cov0" title="0">if f != vote.FieldID </span><span class="cov0" title="0">{
                                _spec.Node.Columns = append(_spec.Node.Columns, f)
                        }</span>
                }
        }
        <span class="cov0" title="0">if ps := _u.mutation.predicates; len(ps) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Predicate = func(selector *sql.Selector) </span><span class="cov0" title="0">{
                        for i := range ps </span><span class="cov0" title="0">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov0" title="0">_node = &amp;Vote{config: _u.config}
        _spec.Assign = _node.assignValues
        _spec.ScanValues = _node.scanValues
        if err = sqlgraph.UpdateNode(ctx, _u.driver, _spec); err != nil </span><span class="cov0" title="0">{
                if _, ok := err.(*sqlgraph.NotFoundError); ok </span><span class="cov0" title="0">{
                        err = &amp;NotFoundError{vote.Label}
                }</span> else<span class="cov0" title="0"> if sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                        err = &amp;ConstraintError{msg: err.Error(), wrap: err}
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">_u.mutation.done = true
        return _node, nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package logging

import (
        "context"
        "log/slog"
)

type ctxKey string

const slogFields ctxKey = "slogFields"

// ContextHandler is a slog.Handler that extracts attributes from context
type ContextHandler struct {
        slog.Handler
}

// Handle implements slog.Handler and adds context attributes to the record
func (h ContextHandler) Handle(ctx context.Context, r slog.Record) error <span class="cov0" title="0">{
        if attrs, ok := ctx.Value(slogFields).([]slog.Attr); ok </span><span class="cov0" title="0">{
                for _, attr := range attrs </span><span class="cov0" title="0">{
                        r.AddAttrs(attr)
                }</span>
        }
        <span class="cov0" title="0">return h.Handler.Handle(ctx, r)</span>
}

// WithAttrs returns a new ContextHandler with the given attributes
func (h ContextHandler) WithAttrs(attrs []slog.Attr) slog.Handler <span class="cov0" title="0">{
        return ContextHandler{Handler: h.Handler.WithAttrs(attrs)}
}</span>

// WithGroup returns a new ContextHandler with the given group name
func (h ContextHandler) WithGroup(name string) slog.Handler <span class="cov0" title="0">{
        return ContextHandler{Handler: h.Handler.WithGroup(name)}
}</span>

// AppendCtx appends slog attributes to the context
func AppendCtx(ctx context.Context, attrs ...slog.Attr) context.Context <span class="cov0" title="0">{
        if existing, ok := ctx.Value(slogFields).([]slog.Attr); ok </span><span class="cov0" title="0">{
                attrs = append(existing, attrs...)
        }</span>
        <span class="cov0" title="0">return context.WithValue(ctx, slogFields, attrs)</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package logging

import (
        "log/slog"
        "os"
)

func NewLogger(level slog.Level) *slog.Logger <span class="cov0" title="0">{
        opts := &amp;slog.HandlerOptions{
                Level: level,
        }

        return slog.New(ContextHandler{Handler: slog.NewJSONHandler(os.Stdout, opts)})
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package server

import (
        "database/sql"
        "log/slog"
        "net/http"
)

// HandleHealth returns a health check handler that verifies database connectivity
func HandleHealth(logger *slog.Logger, db *sql.DB) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if err := db.PingContext(r.Context()); err != nil </span><span class="cov0" title="0">{
                        logger.LogAttrs(
                                r.Context(),
                                slog.LevelError,
                                "health check failed: database unavailable",
                                slog.String("error", err.Error()),
                        )
                        writeError(w, "database unavailable", ErrCodeInternal, http.StatusServiceUnavailable)
                        return
                }</span>

                <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(http.StatusOK)
                _, err := w.Write([]byte(`{"status":"ok"}`))
                if err != nil </span><span class="cov0" title="0">{
                        logger.LogAttrs(
                                r.Context(),
                                slog.LevelError,
                                "failed to write health response",
                                slog.String("error", err.Error()),
                        )
                }</span>
        })
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package middleware

import (
        "log/slog"
        "net/http"
        "time"

        "github.com/ivankorhner/polling-app/internal/logging"
)

type responseWriter struct {
        http.ResponseWriter
        statusCode int
        size       int
}

func (rw *responseWriter) WriteHeader(statusCode int) <span class="cov0" title="0">{
        rw.statusCode = statusCode
        rw.ResponseWriter.WriteHeader(statusCode)
}</span>

func (rw *responseWriter) Write(b []byte) (int, error) <span class="cov0" title="0">{
        size, err := rw.ResponseWriter.Write(b)
        rw.size += size
        return size, err
}</span>

func httpRequest(logger *slog.Logger, next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                start := time.Now()

                ctx := r.Context()
                ctx = logging.AppendCtx(ctx,
                        slog.String("method", r.Method),
                        slog.String("path", r.URL.Path),
                )
                r = r.WithContext(ctx)

                logger.LogAttrs(
                        r.Context(),
                        slog.LevelInfo,
                        "started request",
                )

                rw := &amp;responseWriter{ResponseWriter: w, statusCode: http.StatusOK}
                next.ServeHTTP(rw, r)

                logger.LogAttrs(
                        r.Context(),
                        slog.LevelInfo,
                        "completed request",
                        slog.Int("status", rw.statusCode),
                        slog.Int("size", rw.size),
                        slog.Duration("duration", time.Since(start)),
                )
        }</span>)
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package middleware

import (
        "context"
        "log/slog"
        "net/http"

        "github.com/ivankorhner/polling-app/internal/config"
)

func NewDefaults(
        ctx context.Context,
        config *config.Config,
        logger *slog.Logger,
) func(h http.Handler) http.Handler <span class="cov0" title="0">{
        return func(h http.Handler) http.Handler </span><span class="cov0" title="0">{
                // Correct order: panic recovery outermost, then request tracking, then timeout
                return panicRecovery(logger,
                        requestID(logger,
                                httpRequest(logger,
                                        timeout(config.APITimeout, h),
                                ),
                        ),
                )
        }</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package middleware

import (
        "log/slog"
        "net/http"
)

func panicRecovery(logger *slog.Logger, next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if rec := recover(); rec != nil </span><span class="cov0" title="0">{
                                logger.LogAttrs(
                                        r.Context(),
                                        slog.LevelError,
                                        "panic recovered",
                                        slog.String(RequestIDKey, requestIDFromContext(r.Context())),
                                        slog.String("path", r.URL.Path),
                                        slog.Any("panic", rec),
                                )
                                http.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
                        }</span>
                }()
                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package middleware

import (
        "context"
        "log/slog"
        "net/http"

        "github.com/google/uuid"

        "github.com/ivankorhner/polling-app/internal/logging"
)

// RequestIDKey is the context key for storing request IDs
const RequestIDKey string = "request_id"

func requestIDFromContext(ctx context.Context) string <span class="cov0" title="0">{
        if reqID, ok := ctx.Value(RequestIDKey).(string); ok </span><span class="cov0" title="0">{
                return reqID
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func requestID(logger *slog.Logger, next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                ctx := r.Context()
                if existing := requestIDFromContext(ctx); existing == "" </span><span class="cov0" title="0">{
                        reqID := generateRequestID()
                        ctx = logging.AppendCtx(ctx, slog.String(RequestIDKey, reqID))
                        r = r.WithContext(ctx)
                }</span>
                <span class="cov0" title="0">next.ServeHTTP(w, r.WithContext(ctx))</span>
        })
}

func generateRequestID() string <span class="cov0" title="0">{
        return uuid.New().String()
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">package middleware

import (
        "net/http"
        "time"
)

func timeout(timeout time.Duration, next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.TimeoutHandler(next, timeout, "request took too long")
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">package server

import (
        "context"
        "encoding/json"
        "errors"
        "log/slog"
        "net/http"

        "github.com/ivankorhner/polling-app/internal/ent"
        entpoll "github.com/ivankorhner/polling-app/internal/ent/poll"
        "github.com/ivankorhner/polling-app/internal/ent/user"
)

// CreatePollRequest represents the request body for poll creation
type CreatePollRequest struct {
        OwnerID int      `json:"owner_id"`
        Title   string   `json:"title"`
        Options []string `json:"options"`
}

// HandleCreatePoll handles poll creation
func HandleCreatePoll(logger *slog.Logger, client *ent.Client) http.Handler <span class="cov10" title="6">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov10" title="6">{
                logger.LogAttrs(r.Context(), slog.LevelInfo, "create poll: starting")

                // Limit request body size
                r.Body = http.MaxBytesReader(w, r.Body, MaxRequestBodySize)

                var req CreatePollRequest
                if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov1" title="1">{
                        writeValidationError(w, "invalid request body")
                        return
                }</span>

                // Validate title
                <span class="cov9" title="5">if errMsg := ValidatePollTitle(req.Title); errMsg != "" </span><span class="cov1" title="1">{
                        writeValidationError(w, errMsg)
                        return
                }</span>

                // Validate owner_id
                <span class="cov7" title="4">if req.OwnerID == 0 </span><span class="cov1" title="1">{
                        writeValidationError(w, "owner_id is required")
                        return
                }</span>

                // Validate options
                <span class="cov6" title="3">if errMsg := ValidatePollOptions(req.Options); errMsg != "" </span><span class="cov1" title="1">{
                        writeValidationError(w, errMsg)
                        return
                }</span>

                // Verify owner exists
                <span class="cov4" title="2">exists, err := client.User.Query().Where(user.ID(req.OwnerID)).Exist(r.Context())
                if err != nil </span><span class="cov0" title="0">{
                        logger.LogAttrs(
                                r.Context(),
                                slog.LevelError,
                                "failed to check user existence",
                                slog.String("error", err.Error()),
                        )
                        writeInternalError(w, "failed to create poll")
                        return
                }</span>
                <span class="cov4" title="2">if !exists </span><span class="cov1" title="1">{
                        writeValidationError(w, "owner not found")
                        return
                }</span>

                <span class="cov1" title="1">poll, err := createPollWithOptions(r.Context(), client, req)
                if err != nil </span><span class="cov0" title="0">{
                        logger.LogAttrs(
                                r.Context(),
                                slog.LevelError,
                                "failed to create poll",
                                slog.String("error", err.Error()),
                        )
                        writeInternalError(w, "failed to create poll")
                        return
                }</span>

                // Reload poll with options and vote counts
                <span class="cov1" title="1">poll, err = client.Poll.Query().
                        Where(entpoll.ID(poll.ID)).
                        WithOptions(func(q *ent.PollOptionQuery) </span><span class="cov1" title="1">{
                                q.WithVotes()
                        }</span>).
                        Only(r.Context())
                <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                        logger.LogAttrs(
                                r.Context(),
                                slog.LevelError,
                                "failed to reload poll",
                                slog.String("error", err.Error()),
                        )
                        writeInternalError(w, "failed to create poll")
                        return
                }</span>

                <span class="cov1" title="1">logger.LogAttrs(
                        r.Context(),
                        slog.LevelInfo,
                        "create poll: completed",
                        slog.Int("poll_id", poll.ID),
                        slog.String("title", poll.Title),
                        slog.Int("options_count", len(poll.Edges.Options)),
                )

                w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(http.StatusCreated)
                if err := json.NewEncoder(w).Encode(mapPollToResponse(poll)); err != nil </span><span class="cov0" title="0">{
                        logger.LogAttrs(
                                r.Context(),
                                slog.LevelError,
                                "failed to encode poll response",
                                slog.String("error", err.Error()),
                        )
                }</span>
        })
}

func createPollWithOptions(ctx context.Context, client *ent.Client, req CreatePollRequest) (*ent.Poll, error) <span class="cov1" title="1">{
        tx, err := client.Tx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">poll, err := tx.Poll.Create().
                SetOwnerID(req.OwnerID).
                SetTitle(req.Title).
                Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Join(err, tx.Rollback())
        }</span>

        <span class="cov1" title="1">for _, optionText := range req.Options </span><span class="cov6" title="3">{
                _, err := tx.PollOption.Create().
                        SetPollID(poll.ID).
                        SetText(optionText).
                        Save(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Join(err, tx.Rollback())
                }</span>
        }

        <span class="cov1" title="1">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return poll, nil</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package server

import (
        "context"
        "errors"
        "log/slog"
        "net/http"
        "strconv"

        "github.com/ivankorhner/polling-app/internal/ent"
        entpoll "github.com/ivankorhner/polling-app/internal/ent/poll"
        "github.com/ivankorhner/polling-app/internal/ent/polloption"
        "github.com/ivankorhner/polling-app/internal/ent/vote"
)

// HandleDeletePoll handles poll deletion
func HandleDeletePoll(logger *slog.Logger, client *ent.Client) http.Handler <span class="cov10" title="4">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov10" title="4">{
                idStr := r.PathValue("id")
                id, err := strconv.Atoi(idStr)
                if err != nil </span><span class="cov1" title="1">{
                        writeValidationError(w, "invalid poll id")
                        return
                }</span>

                <span class="cov8" title="3">logger.LogAttrs(r.Context(), slog.LevelInfo, "delete poll: starting", slog.Int("poll_id", id))

                // Check if poll exists
                exists, err := client.Poll.Query().Where(entpoll.ID(id)).Exist(r.Context())
                if err != nil </span><span class="cov0" title="0">{
                        logger.LogAttrs(r.Context(), slog.LevelError, "failed to check poll", slog.String("error", err.Error()))
                        writeInternalError(w, "failed to delete poll")
                        return
                }</span>
                <span class="cov8" title="3">if !exists </span><span class="cov1" title="1">{
                        writeNotFoundError(w, "poll not found")
                        return
                }</span>

                // Delete poll and related entities in transaction
                <span class="cov5" title="2">if err := deletePollWithRelations(r.Context(), client, id); err != nil </span><span class="cov0" title="0">{
                        logger.LogAttrs(r.Context(), slog.LevelError, "failed to delete poll", slog.String("error", err.Error()))
                        writeInternalError(w, "failed to delete poll")
                        return
                }</span>

                <span class="cov5" title="2">logger.LogAttrs(r.Context(), slog.LevelInfo, "delete poll: completed", slog.Int("poll_id", id))

                w.WriteHeader(http.StatusNoContent)</span>
        })
}

func deletePollWithRelations(ctx context.Context, client *ent.Client, pollID int) error <span class="cov5" title="2">{
        tx, err := client.Tx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Delete votes for this poll first
        <span class="cov5" title="2">_, err = tx.Vote.Delete().Where(vote.PollID(pollID)).Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Join(err, tx.Rollback())
        }</span>

        // Delete poll options
        <span class="cov5" title="2">_, err = tx.PollOption.Delete().Where(polloption.PollID(pollID)).Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Join(err, tx.Rollback())
        }</span>

        // Delete the poll itself
        <span class="cov5" title="2">err = tx.Poll.DeleteOneID(pollID).Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Join(err, tx.Rollback())
        }</span>

        <span class="cov5" title="2">return tx.Commit()</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package server

import (
        "encoding/json"
        "log/slog"
        "net/http"
        "strconv"
        "time"

        "github.com/ivankorhner/polling-app/internal/ent"
        entpoll "github.com/ivankorhner/polling-app/internal/ent/poll"
)

// PollResponse represents the response for poll operations
type PollResponse struct {
        ID        int              `json:"id"`
        Title     string           `json:"title"`
        CreatedAt time.Time        `json:"created_at"`
        Options   []OptionResponse `json:"options"`
}

// OptionResponse represents a poll option in responses
type OptionResponse struct {
        ID        int    `json:"id"`
        Text      string `json:"text"`
        VoteCount int    `json:"vote_count"`
}

// HandleListPolls handles listing all polls
func HandleListPolls(logger *slog.Logger, client *ent.Client) http.Handler <span class="cov4" title="2">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov4" title="2">{
                logger.LogAttrs(r.Context(), slog.LevelInfo, "list polls: starting")

                polls, err := client.Poll.Query().
                        WithOptions(func(q *ent.PollOptionQuery) </span><span class="cov4" title="2">{
                                q.WithVotes()
                        }</span>).
                        All(r.Context())
                <span class="cov4" title="2">if err != nil </span><span class="cov0" title="0">{
                        logger.LogAttrs(
                                r.Context(),
                                slog.LevelError,
                                "failed to query polls",
                                slog.String("error", err.Error()),
                        )
                        writeInternalError(w, "failed to retrieve polls")
                        return
                }</span>

                <span class="cov4" title="2">response := make([]PollResponse, len(polls))
                for i, p := range polls </span><span class="cov1" title="1">{
                        response[i] = mapPollToResponse(p)
                }</span>

                <span class="cov4" title="2">logger.LogAttrs(
                        r.Context(),
                        slog.LevelInfo,
                        "list polls: completed",
                        slog.Int("count", len(polls)),
                )

                w.Header().Set("Content-Type", "application/json")
                if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                        logger.LogAttrs(
                                r.Context(),
                                slog.LevelError,
                                "failed to encode polls response",
                                slog.String("error", err.Error()),
                        )
                }</span>
        })
}

// HandleGetPoll handles getting a single poll by ID
func HandleGetPoll(logger *slog.Logger, client *ent.Client) http.Handler <span class="cov5" title="3">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov5" title="3">{
                idStr := r.PathValue("id")
                id, err := strconv.Atoi(idStr)
                if err != nil </span><span class="cov1" title="1">{
                        writeValidationError(w, "invalid poll id")
                        return
                }</span>

                <span class="cov4" title="2">logger.LogAttrs(r.Context(), slog.LevelInfo, "get poll: starting", slog.Int("poll_id", id))

                poll, err := client.Poll.Query().
                        WithOptions(func(q *ent.PollOptionQuery) </span><span class="cov4" title="2">{
                                q.WithVotes()
                        }</span>).
                        Where(entpoll.ID(id)).
                        Only(r.Context())
                <span class="cov4" title="2">if err != nil </span><span class="cov1" title="1">{
                        if ent.IsNotFound(err) </span><span class="cov1" title="1">{
                                writeNotFoundError(w, "poll not found")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.LogAttrs(
                                r.Context(),
                                slog.LevelError,
                                "failed to query poll",
                                slog.String("error", err.Error()),
                                slog.Int("poll_id", id),
                        )
                        writeInternalError(w, "failed to retrieve poll")
                        return</span>
                }

                <span class="cov1" title="1">logger.LogAttrs(
                        r.Context(),
                        slog.LevelInfo,
                        "get poll: completed",
                        slog.Int("poll_id", poll.ID),
                        slog.String("title", poll.Title),
                )

                w.Header().Set("Content-Type", "application/json")
                if err := json.NewEncoder(w).Encode(mapPollToResponse(poll)); err != nil </span><span class="cov0" title="0">{
                        logger.LogAttrs(
                                r.Context(),
                                slog.LevelError,
                                "failed to encode poll response",
                                slog.String("error", err.Error()),
                        )
                }</span>
        })
}

func mapPollToResponse(p *ent.Poll) PollResponse <span class="cov7" title="4">{
        return PollResponse{
                ID:        p.ID,
                Title:     p.Title,
                CreatedAt: p.CreatedAt,
                Options:   mapOptionsToResponse(p.Edges.Options),
        }
}</span>

func mapOptionsToResponse(options []*ent.PollOption) []OptionResponse <span class="cov7" title="4">{
        result := make([]OptionResponse, len(options))
        for i, o := range options </span><span class="cov10" title="8">{
                // Calculate vote count dynamically from the votes edge
                voteCount := len(o.Edges.Votes)
                result[i] = OptionResponse{
                        ID:        o.ID,
                        Text:      o.Text,
                        VoteCount: voteCount,
                }
        }</span>
        <span class="cov7" title="4">return result</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package server

import (
        "encoding/json"
        "net/http"
)

// MaxRequestBodySize is the maximum allowed size for request bodies (1MB)
const MaxRequestBodySize = 1 &lt;&lt; 20

// ErrorResponse represents a unified JSON error response
type ErrorResponse struct {
        Error   string `json:"error"`
        Code    string `json:"code,omitempty"`
        Details string `json:"details,omitempty"`
}

// Error codes for common error scenarios
const (
        ErrCodeValidation   = "VALIDATION_ERROR"
        ErrCodeNotFound     = "NOT_FOUND"
        ErrCodeConflict     = "CONFLICT"
        ErrCodeInternal     = "INTERNAL_ERROR"
        ErrCodeBadRequest   = "BAD_REQUEST"
        ErrCodeUnauthorized = "UNAUTHORIZED"
)

// writeError writes a JSON error response
func writeError(w http.ResponseWriter, message, code string, status int) <span class="cov10" title="26">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)
        _ = json.NewEncoder(w).Encode(ErrorResponse{
                Error: message,
                Code:  code,
        })
}</span>

// writeValidationError writes a validation error response
func writeValidationError(w http.ResponseWriter, message string) <span class="cov9" title="20">{
        writeError(w, message, ErrCodeValidation, http.StatusBadRequest)
}</span>

// writeNotFoundError writes a not found error response
func writeNotFoundError(w http.ResponseWriter, message string) <span class="cov4" title="3">{
        writeError(w, message, ErrCodeNotFound, http.StatusNotFound)
}</span>

// writeConflictError writes a conflict error response
func writeConflictError(w http.ResponseWriter, message string) <span class="cov4" title="3">{
        writeError(w, message, ErrCodeConflict, http.StatusConflict)
}</span>

// writeInternalError writes an internal server error response
func writeInternalError(w http.ResponseWriter, message string) <span class="cov0" title="0">{
        writeError(w, message, ErrCodeInternal, http.StatusInternalServerError)
}</span>
</pre>
		
		<pre class="file" id="file56" style="display: none">package server

import (
        "context"
        "database/sql"
        "log/slog"
        "net/http"

        "github.com/ivankorhner/polling-app/internal/config"
        "github.com/ivankorhner/polling-app/internal/ent"
        "github.com/ivankorhner/polling-app/internal/server/middleware"
)

// AddRoutes configures all HTTP routes for the server
func AddRoutes(
        ctx context.Context,
        config *config.Config,
        logger *slog.Logger,
        db *sql.DB,
        client *ent.Client,
) http.Handler <span class="cov0" title="0">{
        mux := http.NewServeMux()

        middlewares := middleware.NewDefaults(ctx, config, logger)

        mux.Handle(http.MethodGet+" /health", HandleHealth(logger, db))
        mux.Handle(http.MethodGet+" /polls", HandleListPolls(logger, client))
        mux.Handle(http.MethodGet+" /polls/{id}", HandleGetPoll(logger, client))
        mux.Handle(http.MethodPost+" /polls", HandleCreatePoll(logger, client))
        mux.Handle(http.MethodDelete+" /polls/{id}", HandleDeletePoll(logger, client))
        mux.Handle(http.MethodPost+" /polls/{id}/vote", HandleVote(logger, client))
        mux.Handle(http.MethodPost+" /users", HandleRegisterUser(logger, client))

        mux.Handle("/", http.NotFoundHandler())

        return middlewares(mux)
}</span>
</pre>
		
		<pre class="file" id="file57" style="display: none">package server

import (
        "encoding/json"
        "log/slog"
        "net/http"
        "strings"
        "time"

        "github.com/ivankorhner/polling-app/internal/ent"
)

// RegisterUserRequest represents the request body for user registration
type RegisterUserRequest struct {
        Username string `json:"username"`
        Email    string `json:"email"`
}

// UserResponse represents the response for user operations
type UserResponse struct {
        ID        int       `json:"id"`
        Username  string    `json:"username"`
        Email     string    `json:"email"`
        CreatedAt time.Time `json:"created_at"`
}

// HandleRegisterUser handles user registration
func HandleRegisterUser(logger *slog.Logger, client *ent.Client) http.Handler <span class="cov10" title="10">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov10" title="10">{
                logger.LogAttrs(r.Context(), slog.LevelInfo, "register user: starting")

                // Limit request body size
                r.Body = http.MaxBytesReader(w, r.Body, MaxRequestBodySize)

                var req RegisterUserRequest
                if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov1" title="1">{
                        writeValidationError(w, "invalid request body")
                        return
                }</span>

                // Validate username
                <span class="cov9" title="9">if errMsg := ValidateUsername(req.Username); errMsg != "" </span><span class="cov6" title="4">{
                        writeValidationError(w, errMsg)
                        return
                }</span>

                // Validate email
                <span class="cov7" title="5">if errMsg := ValidateEmail(req.Email); errMsg != "" </span><span class="cov3" title="2">{
                        writeValidationError(w, errMsg)
                        return
                }</span>

                // Normalize inputs
                <span class="cov5" title="3">req.Username = strings.TrimSpace(req.Username)
                req.Email = strings.TrimSpace(strings.ToLower(req.Email))

                user, err := client.User.Create().
                        SetUsername(req.Username).
                        SetEmail(req.Email).
                        Save(r.Context())
                if err != nil </span><span class="cov3" title="2">{
                        if ent.IsConstraintError(err) </span><span class="cov3" title="2">{
                                writeConflictError(w, "username or email already exists")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.LogAttrs(
                                r.Context(),
                                slog.LevelError,
                                "failed to create user",
                                slog.String("error", err.Error()),
                        )
                        writeInternalError(w, "failed to create user")
                        return</span>
                }

                <span class="cov1" title="1">logger.LogAttrs(
                        r.Context(),
                        slog.LevelInfo,
                        "register user: completed",
                        slog.Int("user_id", user.ID),
                        slog.String("username", user.Username),
                )

                w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(http.StatusCreated)
                if err := json.NewEncoder(w).Encode(mapUserToResponse(user)); err != nil </span><span class="cov0" title="0">{
                        logger.LogAttrs(
                                r.Context(),
                                slog.LevelError,
                                "failed to encode user response",
                                slog.String("error", err.Error()),
                        )
                }</span>
        })
}

func mapUserToResponse(u *ent.User) UserResponse <span class="cov1" title="1">{
        return UserResponse{
                ID:        u.ID,
                Username:  u.Username,
                Email:     u.Email,
                CreatedAt: u.CreatedAt,
        }
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">package server

import (
        "regexp"
        "strings"
        "unicode"
)

const (
        // UsernameMinLength is the minimum length for usernames
        UsernameMinLength = 3
        // UsernameMaxLength is the maximum length for usernames
        UsernameMaxLength = 32
)

// emailRegex is a simple but effective email validation pattern
var emailRegex = regexp.MustCompile(`^[a-zA-Z0-9._%+\-]+@[a-zA-Z0-9.\-]+\.[a-zA-Z]{2,}$`)

// ValidateUsername validates a username and returns an error message if invalid
func ValidateUsername(username string) string <span class="cov6" title="21">{
        username = strings.TrimSpace(username)

        if username == "" </span><span class="cov3" title="3">{
                return "username is required"
        }</span>

        <span class="cov6" title="18">if len(username) &lt; UsernameMinLength </span><span class="cov2" title="2">{
                return "username must be at least 3 characters"
        }</span>

        <span class="cov6" title="16">if len(username) &gt; UsernameMaxLength </span><span class="cov1" title="1">{
                return "username must be at most 32 characters"
        }</span>

        // Check that username contains only allowed characters (alphanumeric, underscore, hyphen)
        <span class="cov6" title="15">for _, r := range username </span><span class="cov10" title="103">{
                if !unicode.IsLetter(r) &amp;&amp; !unicode.IsDigit(r) &amp;&amp; r != '_' &amp;&amp; r != '-' </span><span class="cov3" title="3">{
                        return "username can only contain letters, numbers, underscores, and hyphens"
                }</span>
        }

        // Username must start with a letter
        <span class="cov5" title="12">if !unicode.IsLetter(rune(username[0])) </span><span class="cov3" title="3">{
                return "username must start with a letter"
        }</span>

        <span class="cov5" title="9">return ""</span>
}

// ValidateEmail validates an email address and returns an error message if invalid
func ValidateEmail(email string) string <span class="cov6" title="15">{
        email = strings.TrimSpace(email)

        if email == "" </span><span class="cov3" title="3">{
                return "email is required"
        }</span>

        <span class="cov5" title="12">if len(email) &gt; 254 </span><span class="cov1" title="1">{ // RFC 5321
                return "email address is too long"
        }</span>

        <span class="cov5" title="11">if !emailRegex.MatchString(email) </span><span class="cov4" title="5">{
                return "invalid email format"
        }</span>

        <span class="cov4" title="6">return ""</span>
}

// ValidatePollTitle validates a poll title and returns an error message if invalid
func ValidatePollTitle(title string) string <span class="cov5" title="9">{
        title = strings.TrimSpace(title)

        if title == "" </span><span class="cov3" title="3">{
                return "title is required"
        }</span>

        <span class="cov4" title="6">if len(title) &gt; 256 </span><span class="cov1" title="1">{
                return "title must be at most 256 characters"
        }</span>

        <span class="cov4" title="5">return ""</span>
}

// ValidatePollOptions validates poll options and returns an error message if invalid
func ValidatePollOptions(options []string) string <span class="cov5" title="12">{
        if len(options) &lt; 2 </span><span class="cov3" title="4">{
                return "at least 2 options are required"
        }</span>

        <span class="cov5" title="8">if len(options) &gt; 20 </span><span class="cov1" title="1">{
                return "at most 20 options are allowed"
        }</span>

        <span class="cov4" title="7">for i, opt := range options </span><span class="cov6" title="17">{
                opt = strings.TrimSpace(opt)
                if opt == "" </span><span class="cov2" title="2">{
                        return "option cannot be empty"
                }</span>
                <span class="cov6" title="15">if len(opt) &gt; 256 </span><span class="cov1" title="1">{
                        return "option text must be at most 256 characters"
                }</span>
                <span class="cov6" title="14">options[i] = opt</span> // Normalize trimmed value
        }

        <span class="cov3" title="4">return ""</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package server

import (
        "context"
        "encoding/json"
        "errors"
        "log/slog"
        "net/http"
        "strconv"

        "github.com/ivankorhner/polling-app/internal/ent"
        entpoll "github.com/ivankorhner/polling-app/internal/ent/poll"
        "github.com/ivankorhner/polling-app/internal/ent/polloption"
        "github.com/ivankorhner/polling-app/internal/ent/user"
)

// VoteRequest represents the request body for voting
type VoteRequest struct {
        OptionID int `json:"option_id"`
        UserID   int `json:"user_id"`
}

// HandleVote handles vote submission
func HandleVote(logger *slog.Logger, client *ent.Client) http.Handler <span class="cov10" title="9">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov10" title="9">{
                // Limit request body size
                r.Body = http.MaxBytesReader(w, r.Body, MaxRequestBodySize)

                pollIDStr := r.PathValue("id")
                pollID, err := strconv.Atoi(pollIDStr)
                if err != nil </span><span class="cov1" title="1">{
                        writeValidationError(w, "invalid poll id")
                        return
                }</span>

                <span class="cov9" title="8">logger.LogAttrs(r.Context(), slog.LevelInfo, "submit vote: starting", slog.Int("poll_id", pollID))

                var req VoteRequest
                if decodeErr := json.NewDecoder(r.Body).Decode(&amp;req); decodeErr != nil </span><span class="cov1" title="1">{
                        writeValidationError(w, "invalid request body")
                        return
                }</span>

                <span class="cov8" title="7">if req.OptionID == 0 </span><span class="cov1" title="1">{
                        writeValidationError(w, "option_id is required")
                        return
                }</span>
                <span class="cov8" title="6">if req.UserID == 0 </span><span class="cov1" title="1">{
                        writeValidationError(w, "user_id is required")
                        return
                }</span>

                // Verify poll exists
                <span class="cov7" title="5">pollExists, err := client.Poll.Query().Where(entpoll.ID(pollID)).Exist(r.Context())
                if err != nil </span><span class="cov0" title="0">{
                        logger.LogAttrs(r.Context(), slog.LevelError, "failed to check poll", slog.String("error", err.Error()))
                        writeInternalError(w, "failed to submit vote")
                        return
                }</span>
                <span class="cov7" title="5">if !pollExists </span><span class="cov1" title="1">{
                        writeNotFoundError(w, "poll not found")
                        return
                }</span>

                // Verify option exists and belongs to poll
                <span class="cov6" title="4">optionExists, err := client.PollOption.Query().
                        Where(polloption.ID(req.OptionID), polloption.PollID(pollID)).
                        Exist(r.Context())
                if err != nil </span><span class="cov0" title="0">{
                        logger.LogAttrs(r.Context(), slog.LevelError, "failed to check option", slog.String("error", err.Error()))
                        writeInternalError(w, "failed to submit vote")
                        return
                }</span>
                <span class="cov6" title="4">if !optionExists </span><span class="cov1" title="1">{
                        writeValidationError(w, "option not found or does not belong to poll")
                        return
                }</span>

                // Verify user exists
                <span class="cov5" title="3">userExists, err := client.User.Query().Where(user.ID(req.UserID)).Exist(r.Context())
                if err != nil </span><span class="cov0" title="0">{
                        logger.LogAttrs(r.Context(), slog.LevelError, "failed to check user", slog.String("error", err.Error()))
                        writeInternalError(w, "failed to submit vote")
                        return
                }</span>
                <span class="cov5" title="3">if !userExists </span><span class="cov1" title="1">{
                        writeValidationError(w, "user not found")
                        return
                }</span>

                // Create vote (no need to increment vote_count anymore - it's calculated dynamically)
                <span class="cov3" title="2">err = createVote(r.Context(), client, pollID, req.OptionID, req.UserID)
                if err != nil </span><span class="cov1" title="1">{
                        if ent.IsConstraintError(err) </span><span class="cov1" title="1">{
                                writeConflictError(w, "user has already voted on this poll")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.LogAttrs(r.Context(), slog.LevelError, "failed to create vote", slog.String("error", err.Error()))
                        writeInternalError(w, "failed to submit vote")
                        return</span>
                }

                // Return updated poll with vote counts
                <span class="cov1" title="1">poll, err := client.Poll.Query().
                        Where(entpoll.ID(pollID)).
                        WithOptions(func(q *ent.PollOptionQuery) </span><span class="cov1" title="1">{
                                q.WithVotes()
                        }</span>).
                        Only(r.Context())
                <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                        logger.LogAttrs(r.Context(), slog.LevelError, "failed to reload poll", slog.String("error", err.Error()))
                        writeInternalError(w, "failed to submit vote")
                        return
                }</span>

                <span class="cov1" title="1">logger.LogAttrs(
                        r.Context(),
                        slog.LevelInfo,
                        "submit vote: completed",
                        slog.Int("poll_id", pollID),
                        slog.Int("option_id", req.OptionID),
                        slog.Int("user_id", req.UserID),
                )

                w.Header().Set("Content-Type", "application/json")
                if err := json.NewEncoder(w).Encode(mapPollToResponse(poll)); err != nil </span><span class="cov0" title="0">{
                        logger.LogAttrs(r.Context(), slog.LevelError, "failed to encode response", slog.String("error", err.Error()))
                }</span>
        })
}

func createVote(ctx context.Context, client *ent.Client, pollID, optionID, userID int) error <span class="cov3" title="2">{
        tx, err := client.Tx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="2">_, err = tx.Vote.Create().
                SetPollID(pollID).
                SetOptionID(optionID).
                SetUserID(userID).
                Save(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return errors.Join(err, tx.Rollback())
        }</span>

        <span class="cov1" title="1">return tx.Commit()</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package testutil

import (
        "context"
        "database/sql"
        "fmt"
        "testing"
        "time"

        "entgo.io/ent/dialect"
        entsql "entgo.io/ent/dialect/sql"
        "github.com/testcontainers/testcontainers-go"
        "github.com/testcontainers/testcontainers-go/modules/postgres"
        "github.com/testcontainers/testcontainers-go/wait"

        "github.com/ivankorhner/polling-app/internal/ent"

        _ "github.com/jackc/pgx/v5/stdlib" // PostgreSQL driver
)

const (
        testDBUser     = "test"
        testDBPassword = "test"
        testDBName     = "test_db"
)

// TestDB holds the container and client for a test database
type TestDB struct {
        Container testcontainers.Container
        Client    *ent.Client
}

// SetupTestDB creates a new PostgreSQL container and returns an Ent client.
// The container is ephemeral with no volumes.
func SetupTestDB(ctx context.Context, t *testing.T) *TestDB <span class="cov0" title="0">{
        t.Helper()

        container, err := postgres.Run(ctx,
                "postgres:16-alpine",
                postgres.WithDatabase(testDBName),
                postgres.WithUsername(testDBUser),
                postgres.WithPassword(testDBPassword),
                testcontainers.WithWaitStrategy(
                        wait.ForLog("database system is ready to accept connections").
                                WithOccurrence(2).
                                WithStartupTimeout(30*time.Second),
                ),
        )
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("failed to start postgres container: %v", err)
        }</span>

        <span class="cov0" title="0">connStr, err := container.ConnectionString(ctx, "sslmode=disable")
        if err != nil </span><span class="cov0" title="0">{
                _ = container.Terminate(ctx)
                t.Fatalf("failed to get connection string: %v", err)
        }</span>

        <span class="cov0" title="0">db, err := sql.Open("pgx", connStr)
        if err != nil </span><span class="cov0" title="0">{
                _ = container.Terminate(ctx)
                t.Fatalf("failed to open database: %v", err)
        }</span>

        <span class="cov0" title="0">drv := entsql.OpenDB(dialect.Postgres, db)
        client := ent.NewClient(ent.Driver(drv))

        // Run auto-migration to create schema
        if err := client.Schema.Create(ctx); err != nil </span><span class="cov0" title="0">{
                client.Close()
                _ = container.Terminate(ctx)
                t.Fatalf("failed to run migrations: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;TestDB{
                Container: container,
                Client:    client,
        }</span>
}

// Teardown cleans up the test database container
func (tdb *TestDB) Teardown(ctx context.Context) error <span class="cov0" title="0">{
        if tdb.Client != nil </span><span class="cov0" title="0">{
                tdb.Client.Close()
        }</span>
        <span class="cov0" title="0">if tdb.Container != nil </span><span class="cov0" title="0">{
                return tdb.Container.Terminate(ctx)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ConnectionString returns the database connection string
func (tdb *TestDB) ConnectionString(ctx context.Context) (string, error) <span class="cov0" title="0">{
        if tdb.Container == nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("container not initialized")
        }</span>
        <span class="cov0" title="0">pc, ok := tdb.Container.(*postgres.PostgresContainer)
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("container is not a PostgresContainer")
        }</span>
        <span class="cov0" title="0">return pc.ConnectionString(ctx, "sslmode=disable")</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
